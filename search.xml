<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>进程的通信方式</title>
    <url>/2020/10/09/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>整理自<a href="https://blog.csdn.net/m0_37907797/article/details/103188294" target="_blank" rel="noopener">帅地：进程之间究竟有哪些通信方式？如何通信？</a></p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>举例：<br><code>netstat -tulnp | grep 8080</code></p>
<p>“ | ”是管道，作用是把前一条命令的输出作为后一条命令的输入。</p>
<p>在这里就是把 <code>netstat -tulnp</code> 的输出结果作为 <code>grep 8080</code> 这条命令的输入。</p>
<p>如果两个进程要通信，就可以使用管道。因为这条<strong>竖线</strong>没有名字，所以这种通信方式称为<strong>匿名管道</strong>。</p>
<p>这种通信方式是<strong>单向</strong>的，只能把第一个命令的输出作为第二个命令的输入。如果进程双向通信，那么要创建两个管道。</p>
<p>有匿名管道，那也有命名管道：</p>
<p><code>mkfifo  test</code><br>这条命令创建了一个名为 <code>test</code> 的命名管道。</p>
<p>接下来用一个进程向这个管道写数据，用·另一个进程把里面的数据读出来。<br><code>echo &quot;this is a pipe&quot; &gt; test   // 写数据</code></p>
<p>如果管道的内容未被读出，那么<code>echo</code>命令会一直阻塞，只有当另一进程把管道的内容读出时<code>echo</code>命令才会结束：<br><code>cat test  // 读数据</code>  </p>
<p>读取线程的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost 桌面]# cat &lt; test</span><br><span class="line">this is a pipe</span><br></pre></td></tr></table></figure>
<p>写入线程的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost 桌面]# mkfifo test</span><br><span class="line">[root@localhost 桌面]# echo &quot;this is a pipe&quot; &gt; test</span><br><span class="line">[root@localhost 桌面]# mkfifo test</span><br></pre></td></tr></table></figure>

<p>可以看到，test管道内的数据被读取了。<code>echo</code>命令也结束了。</p>
<p>管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等待另一进程去拿，并且<strong>管道是单向传输的</strong>。</p>
<p>这种通信方式效率低下：a 进程给 b 进程传输数据，a 进程只能等待 b 进程取完数据后才能返回。</p>
<p>所以管道不适合频繁通信的进程。管道的优点是简单，能够保证数据已经真的被其他进程拿走。</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？</p>
<p>消息队列的通信模式可以解决上述问题。a 进程给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。</p>
<p>如果 a 进程发送的数据占的内存比较大，并且两个进程间的通信特别频繁的话，消息队列模型就不适合了。因为 a 发送的数据很大的话，意味<strong>发送消息（拷贝）</strong>的过程要花很多时间来读内存。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存可以很好地解决拷贝消耗时间的问题。</p>
<p>可能有人会问，每个进程有自己的独立内存，为什么两个进程可以共享一块内存呢？</p>
<p>因为系统加载一个进程的时候，分配给进程的内存不是<strong>实际物理内存</strong>，而是<strong>虚拟内存空间</strong>。我们可以让<strong>两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中</strong>。这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>共享内存最大的问题是<strong>多进程竞争内存</strong>的问题，比如线程安全问题。信号量可以解决这个问题。</p>
<p>信号量的本质是计数器，用来实现进程间的互斥与同步。例如信号量的初始值是 1，a 进程访问内存1，信号量的值设为 0；进程b 访问内存1，看到信号量的值为 0，就知道有进程正在访问内存1了，此时进程 b 无法访问内存1。因此信号量也是进程间的通信方式。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python队列</title>
    <url>/2020/10/07/Python%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列是一种只允许在一端进行插入操作，在另一端进行删除操作的线性表。</p>
<p>Python标准库中包含了四种队列，分别是:</p>
<ul>
<li>queue.Queue</li>
<li>asyncio.Queue</li>
<li>multiprocessing.Queue</li>
<li>collections.deque</li>
</ul>
<p>多个线程之间共享数据，多个线程数据交换时，不能保证数据的安全性和一致性。队列能完美解决线程间的数据交换，保证线程间数据的安全性和一致性（多线程通常要加锁，但很可能死锁；而queue自带锁，所以多线程结合queue会更好）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">my_queue = Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        num = randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">        print(<span class="string">"put: &#123;&#125;"</span>.format(num))</span><br><span class="line">        my_queue.put(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        num = my_queue.get()</span><br><span class="line">        print(<span class="string">"get: &#123;&#125;"</span>.format(num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=put)</span><br><span class="line">t2 = Thread(target=get)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">------------- output -------------</span><br><span class="line">put: <span class="number">1</span></span><br><span class="line">get: <span class="number">1</span></span><br><span class="line">put: <span class="number">1</span></span><br><span class="line">get: <span class="number">1</span></span><br><span class="line">put: <span class="number">10</span></span><br><span class="line">get: <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="FIFO-队列"><a href="#FIFO-队列" class="headerlink" title="FIFO 队列"></a>FIFO 队列</h4><p><strong>class queue.Queue(maxsize=0)</strong></p>
<p>FIFO（First in First Out）。Queue 提供了一个基本的 FIFO 容器，maxsize 指明队列中能存放的最多数据个数。一旦达到上限，插入会导致阻塞，直到队列中的数据被消费掉。如果 maxsize &lt;= 0 ，队列大小没有限制。</p>
<h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><p><code>Queue.qsize()</code>：返回队列大小</p>
<p><code>Queue.empty()</code>：判断队列是否为空</p>
<p><code>Queue.full()</code>：判断队列是否满了</p>
<p><code>Queue.get(block=True, timeout=None)</code>：从队列中移除并返回一个项目。如果可选参数 block 是 true 并且 timeout 是 None (默认值)，则在必要时阻塞至项目可得到。如果 timeout 是个正数，将最多阻塞 timeout 秒，如果在这段时间内项目不能得到，将引发 Empty 异常。反之 (block 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 Empty 异常 (这种情况下，timeout 将被忽略)。</p>
<p><code>Queue.get_nowait(item)</code>：相当于 <code>get(False)</code>。</p>
<p><code>Queue.task_done()</code>：表示前面排队的任务已经被完成。被队列的消费者线程使用。每个 get() 被用于获取一个任务， 后续调用 task_done() 告诉队列，该任务的处理已经完成。</p>
<p>如果 join() 当前正在阻塞，在所有条目都被处理后，将解除阻塞(意味着每个 put() 进队列的条目的 task_done() 都被收到)。</p>
<p>如果被调用的次数多于放入队列中的项目数量，将引发 ValueError 异常 。</p>
<p><code>Queue.put(item, block=True, timeout=None)</code>：将 item 放入队列。如果可选参数 block 是 true 并且 timeout 是 None (默认)，则在必要时阻塞至有空闲插槽可用。如果 timeout 是个正数，将最多阻塞 timeout 秒，如果在这段时间没有可用的空闲插槽，将引发 Full 异常。反之 (block 是 false)，如果空闲插槽立即可用，则把 item 放入队列，否则引发 Full 异常 ( 在这种情况下，timeout 将被忽略)。</p>
<p><code>Queue.put_nowait(item)</code>：相当于 <code>put(item, False)</code>。</p>
<p><code>Queue.join()</code>：阻塞至队列中所有的元素都被接收和处理完毕。<br>当条目添加到队列的时候，未完成任务的计数就会增加。每当消费者线程调用 task_done() 表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， join() 阻塞被解除。<br>监视所有item并阻塞主线程，直到所有item都调用了task_done之后主线程才继续向下执行。<br>假如一个线程开始处理最后一个任务，它从队列中拿走最后一个任务，此时队列为空但最后运行任务的线程还没处理完。当调用了join后，主线程不会因为队列为空而擅自结束，而是等待最后运行任务的线程处理完成再结束。</p>
<p><strong>如何等待排队的任务被完成的示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    print(q.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        print(<span class="string">f'Working on <span class="subst">&#123;item&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'Finished <span class="subst">&#123;item&#125;</span>'</span>)</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># turn-on the worker thread</span></span><br><span class="line">threading.Thread(target=worker, daemon=<span class="literal">True</span>).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># send thirty task requests to the worker</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    q.put(item)</span><br><span class="line">print(<span class="string">'All task requests sent\n'</span>, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># block until all tasks are done</span></span><br><span class="line">q.join()</span><br><span class="line">print(<span class="string">'All work completed'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------- output -------------</span><br><span class="line">All task requests sent</span><br><span class="line">Working on <span class="number">0</span></span><br><span class="line">Finished <span class="number">0</span></span><br><span class="line">Working on <span class="number">1</span></span><br><span class="line">Finished <span class="number">1</span></span><br><span class="line">Working on <span class="number">2</span></span><br><span class="line">Finished <span class="number">2</span></span><br><span class="line">Working on <span class="number">3</span></span><br><span class="line">Finished <span class="number">3</span></span><br><span class="line">Working on <span class="number">4</span></span><br><span class="line">Finished <span class="number">4</span></span><br><span class="line">Working on <span class="number">5</span></span><br><span class="line">Finished <span class="number">5</span></span><br><span class="line">Working on <span class="number">6</span></span><br><span class="line">Finished <span class="number">6</span></span><br><span class="line">Working on <span class="number">7</span></span><br><span class="line">Finished <span class="number">7</span></span><br><span class="line">Working on <span class="number">8</span></span><br><span class="line">Finished <span class="number">8</span></span><br><span class="line">Working on <span class="number">9</span></span><br><span class="line">Finished <span class="number">9</span></span><br><span class="line">All work completed</span><br></pre></td></tr></table></figure>
<h4 id="LIFO-队列"><a href="#LIFO-队列" class="headerlink" title="LIFO 队列"></a>LIFO 队列</h4><p><strong>class queue.LifoQueue(maxsize=0)</strong></p>
<p><strong>源码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifoQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    <span class="string">'''Variant of Queue that retrieves most recently added entries first.'''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init</span><span class="params">(self, maxsize)</span>:</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_qsize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.pop()</span><br></pre></td></tr></table></figure>

<p>LIFO （Last in First Out），与栈类似，用法同上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.LifoQueue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    print(q.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="优先队列-PriorityQueue"><a href="#优先队列-PriorityQueue" class="headerlink" title="优先队列 PriorityQueue"></a>优先队列 PriorityQueue</h4><p>存入数据时加入一个优先级，取数据的时候优先级最高的先取出。</p>
<p><strong>源码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    <span class="string">'''Variant of Queue that retrieves open entries in priority order (lowest first).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Entries are typically tuples of the form:  (priority number, data).</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init</span><span class="params">(self, maxsize)</span>:</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_qsize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        heappush(self.queue, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heappop(self.queue)</span><br></pre></td></tr></table></figure>
<p>PriorityQueue 在插入元素时已经对元素做了排序，把最小的元素放在队尾:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line">items = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">pq = PriorityQueue()</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> items:</span><br><span class="line">    pq.put(element)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> pq.empty():</span><br><span class="line">    print(pq.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>PriorityQueue 对tuple作比较时，按照元素的顺序，找到第一个可比较的元素进行比较。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line">customers = PriorityQueue()</span><br><span class="line">customers.put((<span class="number">2</span>, <span class="string">"Harry"</span>))</span><br><span class="line">customers.put((<span class="number">3</span>, <span class="string">"Charles"</span>))</span><br><span class="line">customers.put((<span class="number">1</span>, <span class="string">"Riya"</span>))</span><br><span class="line">customers.put((<span class="number">4</span>, <span class="string">"Stacy"</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> customers.empty():</span><br><span class="line">    print(customers.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="string">'Riya'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2</span>, <span class="string">'Harry'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">3</span>, <span class="string">'Charles'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">4</span>, <span class="string">'Stacy'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="queue-Queue-amp-asyncio-Queue"><a href="#queue-Queue-amp-asyncio-Queue" class="headerlink" title="queue.Queue &amp; asyncio.Queue"></a>queue.Queue &amp; asyncio.Queue</h4><p>queue.Queue和asyncio.Queue都是支持多生产者、多消费者的队列，基于collections.deque，他们都提供了Queue（FIFO队列）、PriorityQueue（优先级队列）、LifoQueue（LIFO队列），接口方面也相同。</p>
<p>区别在于queue.Queue适用于多线程的场景，asyncio.Queue适用于协程场景下的通信。由于asyncio的加成，queue.Queue下的阻塞接口在asyncio.Queue中是以返回协程对象的方式执行，具体差异如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-15de9fde6c4723e7e36d52c3b9d4ec04_720w.jpg" alt="img"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>collections.deque在数据结构层面实现了队列，但并没有应用场景方面的支持，是一个基础的数据结构。</p>
<p>queue：面向多生产线程、多消费线程的队列。</p>
<p>asyncio.queue：面向多生产协程、多消费协程的队列。</p>
<p>multiprocessing.queue：面向多成产进程、多消费进程的队列。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>详解collections工具库</title>
    <url>/2020/10/05/%E8%AF%A6%E8%A7%A3collections%E5%B7%A5%E5%85%B7%E5%BA%93/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/110476502" target="_blank" rel="noopener">承志：Python——详解collections工具库</a></p>
<h4 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h4><p>defaultdict 解决的是 dict 中最常见的问题：<strong>key 为空</strong>的情况。</p>
<p>通常在 dict 中获取元素时，都要考虑 key 为空的情况。如果不考虑这点，获取一个不存在的 key 会导致异常。我们可以在每次 get 之前写一个if判断，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> dict:</span><br><span class="line">    <span class="keyword">return</span> dict[key]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>当然，这是最笨的方法，dict 为我们提供了带默认值的 get 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> dict.get(key, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>这样，如果 key 不存在 dict 里，会自动返回设置好的默认值。省去了很多麻烦的判断，但仍然存在问题：比如当 key 存在重复，我们希望将 key 相同的 value 存进一个list当中，而不是只保留一个。这种情况下写成代码就会比较复杂：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">in</span> d:</span><br><span class="line">        d[k].append(v)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d[k] = [v]</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>: [<span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>: [<span class="number">1</span>, <span class="number">5</span>], <span class="number">3</span>: [<span class="number">7</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>由于 dict 的 value 是一个 list，所以仍要判断是否为空，不能直接使用默认值，间接操作当然可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    cur = d.get(k, [])</span><br><span class="line">    cur.append(v)</span><br><span class="line">    d[k] = cur</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>: [<span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>: [<span class="number">1</span>, <span class="number">5</span>], <span class="number">3</span>: [<span class="number">7</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>这和使用if区别不大，我们可以使用 collections 当中的<strong>defaultdict</strong>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    d[k].append(v)</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line">&gt;&gt;&gt; defaultdict(&lt;class 'list'&gt;, &#123;1: [3, 4], 2: [1, 5], 3: [7]&#125;)</span><br></pre></td></tr></table></figure>
<p>使用 defaultdict 后，如果key不存在，容器会自动返回预先设置的默认值。defaultdict传入的默认值可以是类型或方法。如果想传入int，那么默认值会被设置成int()的结果，也就是0，如果我们想要自定义或者修改，可以传入一个方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    d[k] += v</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; defaultdict(&lt;class 'int'&gt;, &#123;1: 7, 2: 6, 3: 7&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque是双端队列。对于queue来说，只允许在队尾插入元素，在队首弹出元素。而deque的队首和队尾都支持元素的插入和弹出。比普通的队列更加灵活。</p>
<p>在日常的使用中用到双端队列的算法不太多。大多数情况下使用deque主要有两个原因：</p>
<ol>
<li><p>deque受到GIL的管理，它是线程安全的。而list则没有GIL锁，因此线程不安全。在并发场景下，list可能会导致一致性问题，而deque不会。</p>
</li>
<li><p>deque支持固定长度，当长度满了之后，如果继续append，它会自动弹出最早插入的数据。</p>
</li>
</ol>
<p>当我们拥有海量的数据，但不知道数据的数量，如果想要保留最后出现的指定数量的数据时，就可以使用deque。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">dque = deque(maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 假设我们想要从文件当中获取最后10条数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f.read():</span><br><span class="line">    dque.append(i)</span><br></pre></td></tr></table></figure>
<h4 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h4><p>在常见的面向对象当中，通常都是定义类，再通过类的构造函数来创建实例。元编程指的是我们定义元类，元类创建出来的不是实例，而是类。如果用模具和成品来分别比喻类和实例的话，元类相当于是模具的模具。</p>
<p>namedtuple是一个元类，通过它可以非常方便地定义类。</p>
<p>如果定义一个学生类，有name、score、age这三个字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, score=None, age=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>
<p>使用namedtuple可以简化代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Student = namedtuple(<span class="string">'Student'</span>, [<span class="string">'name'</span>, <span class="string">'score'</span>, <span class="string">'age'</span>])</span><br><span class="line">student = Student(name=<span class="string">'xiaoming'</span>, score=<span class="number">99</span>, age=<span class="number">10</span>)</span><br><span class="line">print(student.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xiaoming</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解数据库行锁与表锁</title>
    <url>/2020/09/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%8C%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/52678870" target="_blank" rel="noopener">加耀：深入理解数据库行锁与表锁</a></p>
<p>数据库如何隔离事务呢？这就牵连到了锁。当插入数据时就锁定表的叫”锁表”；当更新数据时锁定行的叫”行锁”。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">行锁</th>
<th align="center">表锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MyISAM</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">InnoDB</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
</tbody></table>
<p><strong>表锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率高，并发度最低。<br><strong>行锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</p>
<p>当多个用户对数据库进行操作时，可能导致数据不一致。所以，锁用来<strong>在多用户情况下保证数据库数据完整性和一致性。</strong></p>
<p><img src="https://picb.zhimg.com/80/v2-eec522a8cf7d8a38eaea29192edbb2f5_720w.jpg" alt="img"></p>
<p><img src="https://picb.zhimg.com/80/v2-5cf8b96fdca1428e6f3cce863fdfa73e_720w.jpg" alt="img"></p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>行锁锁一行或多行记录，<strong>mysql的行锁是基于索引加载的</strong>，所以<strong>行锁要加在索引响应的行上，即命中索引</strong>。</p>
<p><img src="https://pic1.zhimg.com/80/v2-81420e5b7f1a256b86346781f0379bc6_720w.jpg" alt="img"></p>
<p>上表中有一个主键索引（id）和一个普通索引（email），sql语句基于索引查询命中两条记录。此时行锁锁定了两条记录，当其他事务访问该表时，被锁定的记录不能被访问，其它记录能被访问。</p>
<p>打开两个窗口 A 和 B，在 A 中根据 id 更新一条记录，再在 B 中也执行相同的SQL语句：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e7cb6996c72c83c495ee940ffd6964a2_720w.jpg" alt="img"></p>
<p>窗口 A 先修改了 id 为3的用户信息后，还未提交事务，窗口 B 再更新同一条记录，数据库提示 <code>Lock wait timeout exceeded; try restarting transaction</code>。由于窗口 A 未提交事务，导致锁一直未被释放，出现了锁冲突。窗口 B 一直等待锁的释放，所以出现了超过锁定超时的警告了。</p>
<p>此时如果更新 id 为3它旁边的记录会怎样呢？我们新打开一个窗口更新 id 为2的记录。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2b69c74a17cfe1ef6b0f29cca0ee130c_720w.jpg" alt="img"></p>
<p>在窗口B中更新 id 为3的记录报错，但在窗口 C 中可以更新 id 为2的记录，说明此时锁定了id为 3 的记录但未锁定其它记录。</p>
<p>在 InnoDB 中， 行锁是基于索引实现的。如果某个加锁操作未使用索引，那么该锁就会退化为表锁。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁锁一整张表。在表被锁定期间，其他事务不能操作该表，必须等该表的锁被释放后再操作。<strong>表锁响应的是非索引字段，即全表扫描</strong>，全表扫描时锁定整张表。</p>
<p><img src="https://pic3.zhimg.com/80/v2-54fde24a455d14e96d364f633f87b680_720w.jpg" alt="img"></p>
<p>表锁每次都锁整张表，所以表锁的锁冲突概率高，表锁不会出现死锁。</p>
<p>打开两个窗口 A 和 B，在 A 中更新一条记录，条件为<strong>非索引字段</strong>，不提交事务，再在 B 中任意再更新一条记录：</p>
<p><img src="https://picb.zhimg.com/80/v2-a3da10ada0e98184ca99dc31ee68c3a1_720w.jpg" alt="img"></p>
<p>因为更新数据时未触发索引，所以锁表。锁表后对表做的任何变更操作都会导致锁冲突，所以表锁的锁冲突概率高。</p>
<p>行锁又衍生了三种算法锁：记录锁、间隙锁、临键锁。</p>
<h4 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁 (Record Lock)"></a>记录锁 (Record Lock)</h4><p>行锁是命中索引，锁了表的一条或多条记录，记录锁是行锁衍生的锁。</p>
<p>记录锁锁的是表中的某<strong>一条</strong>记录，记录锁的出现条件<strong>必须是精准命中索引并且索引是唯一索引</strong>，如主键id。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e7cb6996c72c83c495ee940ffd6964a2_720w.jpg" alt="img"></p>
<p>图中 id 是唯一索引，此时锁的就是一条记录，命中索引为唯一索引，此时使用的锁就是记录锁。</p>
<p>通过<strong>主键索引或唯一索引</strong> UPDATE 数据时，也会对该行数据加记录锁：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">SET</span> age = <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<p>需要注意：</p>
<ul>
<li><p>记录锁必须使用主键索引或唯一索引，否则记录锁会退化成临键锁。</p>
</li>
<li><p>查询语句必须为精准匹配（<code>=</code>），不能为 <code>&gt;、&lt;、like</code>等，否则记录锁会退化成临键锁。</p>
</li>
</ul>
<h4 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 (Gap Lock)"></a>间隙锁 (Gap Lock)</h4><p>间隙锁每次都锁定一个区间，也属于行锁。间隙锁的触发条件也是命中索引，当我们查询数据用范围查询而非精准匹配（<code>=</code>）时，<strong>查询条件命中索引，但没有查询到符合条件的记录</strong>，此时就会将查询条件中的范围数据进行锁定（即使是范围中不存在的数据也会被锁定）。</p>
<p>打开两个窗口，在窗口 A 中根据id做一个范围更改操作，不提交事务，然后在窗口 B 中插入一条记录，该记录的id值位于窗口 A 中的条件范围内：</p>
<p><img src="https://pic1.zhimg.com/80/v2-32fd1eb4a26fa35610703d98f6b36a79_720w.jpg" alt="img"></p>
<p>如上所示，程序报错：<code>Lock wait timeout exceeded; try restarting transaction</code>，这就是间隙锁的作用。<strong>间隙锁只出现在可重复读的事务隔离级别中，<code>mysql5.7</code>默认就是可重复读</strong>。间隙锁锁的是一个区间范围，查询命中索引但没有匹配到记录时，锁定的是查询的这个区间范围，上图锁定的区间就是 (1,3]这个左开右闭的区间。</p>
<p>如果将 mysql 数据库隔离级别修改为读已提交会是怎样的呢？验证一下间隙锁只会出现在可重复读的事务隔离级别中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置事务隔离级别为读已提交</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line"><span class="comment">-- 查看当前事务级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @@tx_isolation</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-018f7b3ebf9bdac04068b77714dc430c_720w.jpg" alt="img"></p>
<p>修改了数据库隔离级别后，再次测试间隙锁，间隙锁没有生效。</p>
<p><strong>产生间隙锁的条件（Repeatable-Read事务隔离级别下）</strong>：</p>
<ul>
<li><p>在普通索引列上，不论何种查询，只要加锁，就产生间隙锁</p>
</li>
<li><p>使用多列唯一索引</p>
</li>
<li><p>使用唯一索引锁定多行记录</p>
</li>
</ul>
<p>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。</p>
<h4 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁 (Next-Key Lock)"></a>临键锁 (Next-Key Lock)</h4><p>mysql 的行锁默认就是临键锁，临键锁由记录锁和间隙锁共同实现。间隙锁的触发条件是命中索引，范围查询没有匹配的记录。而临键锁恰好相反，临键锁的触发条件也是<strong>查询条件命中索引，但临键锁匹配到了记录</strong>。</p>
<p><strong>间隙锁锁定了一个左开右闭的区间，而临键锁锁定了当前记录的区间和下一个记录的区间：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-0a82d8e24b998db426e0363e6140343f_720w.jpg" alt="img"></p>
<p><img src="https://picb.zhimg.com/80/v2-2693531707b096359a778852d943c12b_720w.jpg" alt="img"></p>
<p>数据库中只有三条数据1、5、7，当修改范围为<code>(1， 8]</code>时，间隙锁锁定的区间为<code>(1,+∞)</code>，锁定了查询的范围和查询范围的下一个范围区间。在数据库中是不存在id 为8的记录，如果查询条件是<code>&lt;=8</code>，也是锁定8到后面的区间。</p>
<p>如果查询的结尾是一个存在的值，又会怎样呢？现在数据库有三条数据id分别是1、5、7，将查询条件改为大于1小于7：</p>
<p><img src="https://pic1.zhimg.com/80/v2-44833c3c68bd57d7112967ab4797e07c_720w.jpg" alt="img"></p>
<p>7 在数据库中是已知记录，此时只锁定了<code>(1,7]</code>，7之后的数据未被锁定。我们可以正常插入id为8的数据和后面的数据。</p>
<p><strong>临键锁的锁定区间和查询范围的后匹配值有关</strong>。如果后匹配值存在，则只锁定当前的查询区间，否则锁定查询区间和后匹配值与它的下一个值的区间。</p>
<p>为什么临键锁后匹配值会这样呢？因为 mysql 的索引是基于B+树实现的，每个树节点上都有多个元素，即关键字数，当我们的索引树上只有1、5、7时，我们查询1~8，此时由于树节点关键字中并没有8，所以就把8到正无穷的区间范围都给锁定了。</p>
<p>如果数据库中id有1、5、7、10，此时模糊匹配id为 <code>(1， 8]</code> 的时候，由于关键字中并没有 8 ，所以找到了比 8 大的 10，根据左开右闭原则，此时区间为<code>(1， 10]</code>，10 也被锁定了，但<code>id=11</code>的记录仍可以正常插入。</p>
<p>锁是基于索引的，mysql 中索引的底层是B+树，了解了B+树的特性后，就更容易理解锁的问题了。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Mysql 索引底层原理</title>
    <url>/2020/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Mysql%20%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/113917726" target="_blank" rel="noopener">腾讯技术工程：深入理解 Mysql 索引底层原理</a></p>
<p>Mysql底层的存储引擎和数据检索引擎的设计非常重要，尤其是 Mysql 数据的存储形式和索引的设计，决定了 Mysql 的数据检索性能。</p>
<p>索引的作用是做<strong>数据的快速检索</strong>，快速检索的本质是数据结构。不同的数据结构实现了不同的数据快速检索。</p>
<p>数据库中存储了大量数据，高效的索引能节省巨大的时间。如下图所示，如果 Mysql 没有索引，那么查找 id=7 这个数据，只能采取暴力顺序遍历查找，需要比较 7 次。如果表存储了 1000W 个数据，查找 id=1000W 这个数据要比较 1000W 次。</p>
<p><img src="https://pic1.zhimg.com/80/v2-5141ed6f1bddd61750763b51bdc9ecb4_720w.jpg" alt="img"></p>
<h4 id="一、Mysql-索引底层数据结构选型"><a href="#一、Mysql-索引底层数据结构选型" class="headerlink" title="一、Mysql 索引底层数据结构选型"></a>一、Mysql 索引底层数据结构选型</h4><h5 id="1-哈希表（Hash）"><a href="#1-哈希表（Hash）" class="headerlink" title="1.哈希表（Hash）"></a>1.哈希表（Hash）</h5><p>哈希算法（散列算法）：<strong>把任意值(key)通过哈希函数变换为固定长度的 key 地址，通过地址查找具体数据的数据结构。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-7805f7b4bab4c98adc045e3667046398_720w.jpg" alt="img"></p>
<p>考虑上面的数据库表 user，表中共有 7 个数据，如果检索 id=7 的数据，SQL 语法是：</p>
<p><code>select * from user where id=7;</code></p>
<p>哈希算法首先计算存储 id=7 这个数据的物理地址 addr=hash(7)=4231，4231 映射的物理地址是 0x77，0x77 就是 id=7 存储数据的物理地址，通过该物理地址能找到对应 user_name=’g’这个数据。这就是哈希算法快速检索数据的计算过程。</p>
<p><strong>哈希算法有数据碰撞的问题，哈希函数可能对不同的 key 计算出相同结果</strong>。hash(7)可能跟 hash(199)的结果一样，不同的 key 映射到同一结果，这就是碰撞问题。解决碰撞问题的一个常见方法就是<strong>链地址法</strong>，用链表把碰撞的数据连接。计算哈希值后，检查该哈希值是否存在碰撞数据链表，有则一直遍历到链表尾，直到找到真正的 key 对应的数据为止。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4deae667d7d5c9a1a166cb0e8bac9dd6_720w.jpg" alt="img"></p>
<p><img src="https://picb.zhimg.com/80/v2-df9820ea9f7146d09af8280040f185f5_720w.jpg" alt="img"></p>
<p>哈希算法时间复杂度为 O(1)，检索速度非常快。哈希索引只需计算一次就能得到数据。但 Mysql 没有采取哈希作为底层算法，因为数据检索经常<strong>范围查找</strong>，比如这个 SQL 语句：</p>
<p><code>select * from user where id &gt;3;</code></p>
<p>如果使用了哈希算法实现的索引，一个简单的思路就是一次性把所有数据加载到内存，在内存里筛选目标范围内的数据。这个方法笨重且没有效率。</p>
<p><strong>哈希算法实现的索引能做到快速检索数据，但不能高效地范围查找数据，因此哈希索引不适合作为 Mysql 的底层索引的数据结构。</strong></p>
<h5 id="2-二叉查找树-BST"><a href="#2-二叉查找树-BST" class="headerlink" title="2.二叉查找树(BST)"></a>2.二叉查找树(BST)</h5><p>二叉查找树是一种支持数据快速查找的数据结构。</p>
<p><img src="https://pic2.zhimg.com/80/v2-032790aff0ddf52b676413573acce776_720w.jpg" alt="img"></p>
<p>二叉查找树的时间复杂度是 O(lgn)，上面的二叉树结构只需要比较 3 次就能检索到 id=7 的数据。</p>
<p>二叉树能否解决哈希索引不能提供的范围查找功能呢？</p>
<p>能。观察上图，<strong>二叉树的叶子节点按序排列，从左到右依次升序，如果要找 id&gt;5 的数据，取出值为6 的节点以及其右子树就可以了。</strong></p>
<p>但普通的二叉查找树有个致命缺点：<strong>极端情况下会退化为线性链表，二分查找退化为遍历查找，时间复杂度退化为 O(n)，检索性能急剧下降</strong>。</p>
<p>如下图所示，二叉树极度不平衡，退化为链表，检索速度大大降低。此时检索 id=7 的数据需计算7次。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1cc416d59d4c44cf029e9e2103347bb8_720w.jpg" alt="img"></p>
<p>在数据库中，数据的自增很常见，比如一个表的主键是 id，主键一般默认自增，如果采取二叉树作为索引，那不平衡状态导致的线性查找的问题必然出现。<strong>简单的二叉查找树存在不平衡状态，会导致检索性能降低，不能直接用于 Mysql 底层索引</strong>。</p>
<h5 id="3-AVL-树和红黑树"><a href="#3-AVL-树和红黑树" class="headerlink" title="3.AVL 树和红黑树"></a>3.AVL 树和红黑树</h5><p>二叉查找树存在不平衡状态的问题，因此学者提出通过树节点的自动旋转和调整，让二叉树始终保持平衡状态，就能保持二叉查找树的查找性能了。基于这种思路的自调整平衡状态的二叉树有 AVL 树和红黑树。</p>
<p><strong>红黑树是一颗会自动调整树形态的树结构</strong>，比如当二叉树处于不平衡状态时，红黑树会自动左/右旋节点以及节点变色，调整树形态，使其保持平衡状态（时间复杂度为 O(logn)），保证了查找效率不会明显减低。</p>
<p>比如从 1 到 7 升序插入数据节点，普通的二叉查找树会退化成链表，但红黑树会不断调整树形态，使其保持平衡状态，如下图所示。这个红黑树查找 id=7 的数据要比较4次，保持了二叉树不错的查找效率。</p>
<p><img src="https://pic3.zhimg.com/80/v2-46e7e44e8ba85e606d68ea9644092d08_720w.jpg" alt="img"></p>
<p>红黑树平均查找效率较好，也没有极端的 O(n)情况，那红黑树作为 Mysql 底层索引实现是否可以呢？观察下面的例子。</p>
<p>红黑树顺序插入 1~7 个节点，查找 id=7 时需比较 4 次。</p>
<p><img src="https://pic3.zhimg.com/80/v2-46e7e44e8ba85e606d68ea9644092d08_720w.jpg" alt="img"></p>
<p>红黑树顺序插入 1~16 个节点，查找 id=16 需比较 6 次。观察这个树的形态：当数据顺序插入时，树的形态一直“右倾”。从根本上看，红黑树没有完全解决二叉查找树存在的问题。虽然红黑树的“右倾”趋势远没有二叉查找树退化为线性链表那么夸张，但数据库的主键基本都是自增的，主键一般都是成百上千万的，红黑树的这种问题对于查找性能而言也是巨大的消耗。</p>
<p><img src="https://pic3.zhimg.com/80/v2-60cea4af963b156ee5f40030977ab77c_720w.jpg" alt="img"></p>
<p>现在考虑另一种更为严格的自平衡二叉树 AVL 树。<strong>AVL 树是绝对平衡的二叉树，因此它在调整二叉树的形态上消耗更多的性能。</strong></p>
<p>AVL 树顺序插入 1~7 个节点，查找 id=7 要比较 3 次。</p>
<p><img src="https://pic3.zhimg.com/80/v2-4c39b8eacc6879d661ddb1ed4190aff2_720w.jpg" alt="img"></p>
<p>AVL 树顺序插入 1~16 个节点，查找 id=16 要比较 4 次。从查找效率而言，AVL 树查找速度（4次）高于红黑树（6次）。<strong>AVL 树不存在红黑树“右倾”问题，大量的顺序插入不会导致查询性能的降低，这从根本上解决了红黑树的问题。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-0dad51645707e973b152e44e4b7479c5_720w.jpg" alt="img"></p>
<p>AVL 树的优点：</p>
<ol>
<li><p>不错的查找性能（O(logn)），不存在极端的低效查找的情况。</p>
</li>
<li><p>可以实现范围查找、数据排序。</p>
</li>
</ol>
<p>AVL 树也不适合做 Mysql 数据库的索引数据结构，考虑这个问题：</p>
<p><strong>数据库查询数据的瓶颈在于磁盘 IO</strong>，如果使用了 AVL 树，每一个树节点只存储一个数据，一次磁盘 IO 只能取出一个节点上的数据加载到内存，比如查询 id=7 这个数据，要进行磁盘 IO 三次，消耗很多时间。<strong>所以设计数据库索引时首先考虑怎么尽可能减少磁盘 IO 的次数</strong>。</p>
<p>磁盘 IO 有个特点，<strong>从磁盘读取 1B 数据和 1KB 数据所消耗的时间基本一样</strong>，我们可以根据这个思路，<strong>在一个树节点上尽可能多地存储数据，一次磁盘 IO 加载了更多的数据到内存</strong>，这就是 B 树和B+树的设计原理。</p>
<h5 id="4-B树"><a href="#4-B树" class="headerlink" title="4.B树"></a>4.B树</h5><p>下面这个 B 树，每个节点限制最多存储两个 key，一个节点如果超过两个 key 就会自动分裂。比如下面这个存储了 7 个数据的 B 树，只需要查询两个节点就能知道 id=7 这个数据的具体位置，两次磁盘 IO 就能查询到指定数据，优于 AVL 树。</p>
<p><img src="https://picb.zhimg.com/80/v2-f508590121487b595c4ad4fa83d8aa15_720w.jpg" alt="img"></p>
<p>下面是一个存储了 16 个数据的 B 树，每个节点最多存储 2 个 key，查询 id=16 这个数据需要比较 4 个节点（4 次磁盘 IO）。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f335bdb3e922a5f334416f557df20848_720w.jpg" alt="img"></p>
<p>但考虑到<strong>磁盘 IO 读 1 个数据和读 100 个数据消耗的时间基本一致</strong>，那优化思路就可以改为：尽可能在一次磁盘 IO 中读更多的数据到内存。直接反映到树的结构就是，每个节点能存储的 key 可以适当增加。</p>
<p>当把单个节点限制的 key 个数设置为 6 之后，一个存储了 7 个数据的 B 树，查询 id=7 这个数据需要 2 次磁盘 IO 。</p>
<p><img src="https://pic4.zhimg.com/80/v2-0fdff8f9a516383548cd0e636f593e52_720w.jpg" alt="img"></p>
<p>一个存储了 16 个数据的 B 树，查询 id=7 这个数据只要 2 次磁盘 IO。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7d5e34c698b1e4192ad0ff93c2c897d0_720w.jpg" alt="img"></p>
<p>B 树用作数据库索引有以下优点：</p>
<ol>
<li><p>优秀检索速度，时间复杂度：B 树的查找性能等于 O（h*logn），其中 h 为树高，n 为每个节点关键词的个数</p>
</li>
<li><p>尽可能少的磁盘 IO，加快了检索速度</p>
</li>
<li><p>支持范围查找</p>
</li>
</ol>
<h5 id="5-B-树"><a href="#5-B-树" class="headerlink" title="5.B+树"></a>5.B+树</h5><h6 id="B-树和-B-树的区别："><a href="#B-树和-B-树的区别：" class="headerlink" title="B 树和 B+树的区别："></a>B 树和 B+树的区别：</h6><p><img src="https://images2015.cnblogs.com/blog/576154/201609/576154-20160907130956629-1833512478.png" alt="img"></p>
<p>第一，B+ 树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节点存不了很多数据，但 B+树一个节点能存很多索引，B+树的叶子节点存所有数据。</p>
<p>第二，B+ 树中所有叶子节点通过指针连接，便于范围查找；而B树不会。</p>
<h6 id="B-树的优点："><a href="#B-树的优点：" class="headerlink" title="B+树的优点："></a>B+树的优点：</h6><ol>
<li><p>非叶子节点不会带上ROWID，因此一个块中能容纳更多的索引项。可以降低树的高度，并且一个内部节点可以定位更多的叶子节点。</p>
</li>
<li><p>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</p>
</li>
</ol>
<h6 id="B树的优点："><a href="#B树的优点：" class="headerlink" title="B树的优点："></a>B树的优点：</h6><p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p>
<p><img src="https://pic3.zhimg.com/80/v2-bda6661499c51dcff63eb12fd4b3795d_720w.png" alt="img"></p>
<p><strong>B+树节点存储的是索引，在单个节点存储容量有限的情况下，单节点也能存储大量索引，使得整个 B+树高度降低，减少了磁盘 IO。其次，B+树的叶子节点是真正数据存储的地方，叶子节点用链表连接，链表本身就有序，在数据范围查找时效率更高。因此 Mysql 的索引用的就是 B+树，B+树在查找效率、范围查找中都有着非常不错的性能。</strong></p>
<h4 id="二、Innodb-引擎和-Myisam-引擎的实现"><a href="#二、Innodb-引擎和-Myisam-引擎的实现" class="headerlink" title="二、Innodb 引擎和 Myisam 引擎的实现"></a>二、Innodb 引擎和 Myisam 引擎的实现</h4><p>Mysql 底层数据引擎最常见的是 Innodb 引擎和 Myisam 引擎，B+树作为 Mysql 的索引的数据结构非常合适，但是数据和索引如何组织起来也需要一番设计，设计理念的不同也导致了 Innodb 和 Myisam 的出现。</p>
<p><strong>MyISAM 虽然数据查找性能极佳，但不支持事务处理。Innodb 支持了 ACID 兼容的事务功能，而且也支持行级锁</strong>。Mysql 建立表的时候就可以指定引擎，比如下面的例子，分别指定了 Innodb 和 Myisam 作为 user 表和 user2 表的数据引擎。</p>
<p><img src="https://pic4.zhimg.com/80/v2-0df18cce6c3871fa9e4ac99050bf1692_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-e4e24288dca3ef02735c41a2a3a69556_720w.jpg" alt="img"></p>
<p>执行这两个指令后，系统出现了以下的文件，说明这两个引擎数据和索引的组织方式是不一样的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8a065d6e21a2adbf06d2e6b5dd02e969_720w.jpg" alt="img"></p>
<p>Innodb 创建表后生成的文件有：</p>
<ul>
<li><p>frm:创建表的语句</p>
</li>
<li><p>idb:表里面的数据+索引文件</p>
</li>
</ul>
<p>Myisam 创建表后生成的文件有</p>
<ul>
<li><p>frm:创建表的语句</p>
</li>
<li><p>MYD:表里面的数据文件（myisam data）</p>
</li>
<li><p>MYI:表里面的索引文件（myisam index）</p>
</li>
</ul>
<p>MyISAM 引擎把数据和索引分开了，一人一个文件，这是<strong>非聚集索引方式</strong>；Innodb 引擎把数据和索引放在同一文件里，这是<strong>聚集索引方式</strong>。</p>
<p><strong>1.MyISAM 引擎的底层实现（非聚集索引方式）</strong></p>
<p>MyISAM 用的是非聚集索引方式，即数据和索引在两个文件上。MyISAM 在建表时以主键作为 KEY 来建立主索引 B+树，树的叶子节点存的是对应数据的物理地址。拿到物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录了。</p>
<p><img src="https://pic1.zhimg.com/80/v2-d9a03627e8e1319e46f42e6963c35e30_720w.jpg" alt="img"></p>
<p>当我们为某个字段添加索引时，同样会生成对应字段的索引树，该字段的索引树的叶子节点同样记录了对应数据的物理地址，也是拿着物理地址去数据文件里定位到具体的数据记录。</p>
<p><strong>2.Innodb 引擎的底层实现（聚集索引方式）</strong></p>
<p>InnoDB 是聚集索引方式，数据和索引存储在同一文件里。首先 InnoDB 会根据主键 ID 作为 KEY 建立索引 B+树，如左下图所示，而 B+树的叶子节点存储的是主键 ID 对应的数据，比如在执行 <code>select * from user_info where id=15</code> 时，InnoDB 会查询这颗主键 ID 索引 B+树，找到对应的 user_name=’Bob’。</p>
<p>建表的时候 InnoDB 就会自动建立好主键 ID 索引树，这也是为什么 Mysql 在建表时要求必须指定主键的原因。当我们为表里某个字段加索引时, InnoDB 会怎么建立索引树呢？比如我们要给 <code>user_name</code> 这个字段加索引，那么 InnoDB 就会建立 user_name 索引 B+树，节点里存的是 <code>user_name</code> 这个 KEY，叶子节点存储的数据的是主键 KEY。注意，<strong>叶子存储的是主键 KEY！拿到主键 KEY 后，InnoDB 才会去主键索引树里根据刚在 <code>user_name</code> 索引树找到的主键 KEY 查找到对应的数据。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-6e16b355e3d0f05ed8bfb0f7c71de8f1_720w.jpg" alt="img"></p>
<p>为什么 InnoDB 只在主键索引树的叶子节点存储具体数据，但其他的索引树不存具体数据呢？为什么要多此一举先找到主键，再在主键索引树找到对应的数据呢?</p>
<p>原因是 InnoDB 要节省存储空间。一个表里可能有很多个索引，InnoDB 都会给每个加了索引的字段生成索引树，如果每个字段的索引树都存储了具体数据，那么这个表的索引数据文件就变得非常巨大（数据极度冗余）。从节约磁盘空间的角度来说，没有必要每个字段索引树都存具体数据，这种看似“多此一举”的步骤，在牺牲较少查询的性能下节省了巨大的磁盘空间，是非常值得的。</p>
<p>MyISAM 查询性能更好，MyISAM 直接找到物理地址后就可以直接定位到数据记录；InnoDB 查询到叶子节点后，还需再查询一次主键索引树，才能定位到具体数据。MyISAM 一步就查到了数据，但是 InnoDB 要两步，当然 MyISAM 查询性能更高。</p>
<p>总结一下何时需要给表里的字段加索引：</p>
<ol>
<li><p>较频繁的作为查询条件的字段应该创建索引</p>
</li>
<li><p>唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件</p>
</li>
<li><p>更新非常频繁的字段不适合创建索引</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面经</title>
    <url>/2020/08/04/Python%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>全局变量和局部变量的区别在于作用域。全局变量在整个py文件中声明，全局范围内使用；局部变量在函数内声明，只能在函数内使用，在函数外使用会报错。<br>在函数内部，如果局部变量与全局变量变量名一样，优先调用局部变量。<br>如果想在函数内改变全局变量，需要在函数内使用<code>global</code>关键字。函数执行后全局变量的值会改变。<br>如果全局变量是列表类型，可以通过list的列表方法修改变量，可以不用<code>global</code>声明。</p>
<hr>
<h4 id="python标准数据类型"><a href="#python标准数据类型" class="headerlink" title="python标准数据类型"></a>python标准数据类型</h4><ol>
<li>Number</li>
<li>String</li>
<li>List</li>
<li>Tuple</li>
<li>Set</li>
<li>Dictionary</li>
</ol>
<p><strong>不可变数据</strong>：Number、String、Tuple<br><strong>可变数据</strong>：List、Dictionary、Set</p>
<hr>
<h4 id="元组和列表区别"><a href="#元组和列表区别" class="headerlink" title="元组和列表区别"></a>元组和列表区别</h4><p><strong>相同点：</strong></p>
<ul>
<li>都是序列</li>
<li>都可以存储任何数据类型</li>
<li>可以通过索引访问</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>元组不可变列表可变，元组能作为字典的键，或集合的元素，而列表不行。</li>
<li>元组不能修改元素（内存结构设计上更精简），性能更好；创建元组比列表快，存储空间比列表更小。</li>
</ul>
<hr>
<h4 id="python关键字"><a href="#python关键字" class="headerlink" title="python关键字"></a>python关键字</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">print(keyword.kwlist)</span><br></pre></td></tr></table></figure>
<p><code>[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;async&#39;, &#39;await&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</code></p>
<hr>
<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>深拷贝和浅拷贝的本质区别是拷贝出来的对象的地址是否和原对象一样，区别在于地址复制还是值复制。</p>
<p><strong>可变对象</strong>：对象在不改变其指向地址的前提下，可以修改其指向地址中的值；</p>
<p><strong>不可变对象</strong>：对象指向地址上的值不能修改。如果修改了对象的值，那么它指向的地址就改变。相当于复制对象指向的值再修改后存到另一个地址上。可变对象就不会这样，而是直接在对象指向的地址上修改值，对象依然指向这个地址。</p>
<p><strong>深拷贝和浅拷贝需要注意的地方就是可变元素的拷贝：</strong></p>
<p>浅拷贝拷贝出的新对象的地址不同于原对象，但新对象里的可变元素（如列表）的地址和原对象里的可变元素的地址相同。浅拷贝拷贝的是浅层次的数据结构（不可变元素），对象里的可变元素（深层次的数据结构）并未拷贝到新地址，而是和原对象里的可变元素指向同一地址。在新对象或原对象里修改可变元素，两个对象同时改变。但深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line">b = a  <span class="comment"># 赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment"># 浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment"># 深拷贝</span></span><br><span class="line">print(<span class="string">"a="</span>, a, <span class="string">"    id(a)="</span>, id(a), <span class="string">"id(a[5])="</span>, id(a[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"b="</span>, b, <span class="string">"    id(b)="</span>, id(b), <span class="string">"id(b[5])="</span>, id(b[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"c="</span>, c, <span class="string">"    id(c)="</span>, id(c), <span class="string">"id(c[5])="</span>, id(c[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"d="</span>, d, <span class="string">"    id(d)="</span>, id(d), <span class="string">"id(d[5])="</span>, id(d[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"*"</span> * <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">a.append(<span class="number">6</span>)  <span class="comment"># 修改对象a</span></span><br><span class="line">a[<span class="number">5</span>].append(<span class="string">'c'</span>)  <span class="comment"># 修改对象a中的['a','b']数组对象</span></span><br><span class="line">print(<span class="string">"a="</span>, a, <span class="string">"    id(a)="</span>, id(a), <span class="string">"id(a[5])="</span>, id(a[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"b="</span>, b, <span class="string">"    id(b)="</span>, id(b), <span class="string">"id(b[5])="</span>, id(b[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"c="</span>, c, <span class="string">"    id(c)="</span>, id(c), <span class="string">"id(c[5])="</span>, id(c[<span class="number">5</span>]))</span><br><span class="line">print(<span class="string">"d="</span>, d, <span class="string">"    id(d)="</span>, id(d), <span class="string">"id(d[5])="</span>, id(d[<span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]     id(a)= <span class="number">1643637134408</span> id(a[<span class="number">5</span>])= <span class="number">1643637133896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]     id(b)= <span class="number">1643637134408</span> id(b[<span class="number">5</span>])= <span class="number">1643637133896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]     id(c)= <span class="number">1643893203016</span> id(c[<span class="number">5</span>])= <span class="number">1643637133896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]     id(d)= <span class="number">1643638403016</span> id(d[<span class="number">5</span>])= <span class="number">1643892964488</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>**********************************************************************</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">6</span>]     id(a)= <span class="number">1643637134408</span> id(a[<span class="number">5</span>])= <span class="number">1643637133896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">6</span>]     id(b)= <span class="number">1643637134408</span> id(b[<span class="number">5</span>])= <span class="number">1643637133896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]     id(c)= <span class="number">1643893203016</span> id(c[<span class="number">5</span>])= <span class="number">1643637133896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]     id(d)= <span class="number">1643638403016</span> id(d[<span class="number">5</span>])= <span class="number">1643892964488</span></span><br></pre></td></tr></table></figure>

<p>深拷贝跟原对象没有任何关系，原对象改变不会影响到当前对象。</p>
<p>浅拷贝中改变原对象的list元素会改变当前对象，反之亦然。</p>
<p>通常要用深拷贝复制。<strong>因为浅拷贝后，两个对象中不可变对象指向不同地址，相互不影响；但两个对象中的可变元素指向相同地址，一个变了另一个也会变，相互影响。</strong></p>
<hr>
<h4 id="关键字-pass-with"><a href="#关键字-pass-with" class="headerlink" title="关键字 pass/ with"></a>关键字 pass/ with</h4><p><strong>pass</strong>   </p>
<p>pass 是空语句，保持程序结构的完整性；不做任何事情，一般用做占位语句。</p>
<p><strong>with</strong></p>
<p>上下文管理器：任何实现了 <code>__enter__()</code> 和 <code>__exit__()</code> 方法的对象都是上下文管理器，上下文管理器对象能使用<code>with</code>关键字。例如文件（file）对象实现了上下文管理器。</p>
<p>Python提供了<code>contextmanager</code>装饰器，进一步简化了上下文管理器的实现。通过<code>yield</code>将函数分成两部分，<code>yield</code>前的语句在 <code>__enter__()</code>中执行，<code>yield</code>后的语句在 <code>__exit__()</code> 中执行。<code>yield</code>的值是函数的返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"first step"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">"third step"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_A</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"first step"</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">"third step"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> A() <span class="keyword">as</span> f:</span><br><span class="line">        print(<span class="string">"second step"</span>)</span><br><span class="line"></span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">with</span> my_A() <span class="keyword">as</span> a:</span><br><span class="line">        print(<span class="string">"second step"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first step</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second step</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>third step</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first step</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second step</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>third step</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="GIL锁"><a href="#GIL锁" class="headerlink" title="GIL锁"></a>GIL锁</h4><h4 id="字典的底层结构-字典常用方法"><a href="#字典的底层结构-字典常用方法" class="headerlink" title="字典的底层结构/字典常用方法"></a>字典的底层结构/字典常用方法</h4><hr>
<h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><p><strong>引用计数：</strong>  </p>
<p>Python中变量的本质是对内存数据区域的引用，Python给所有对象（内存中的区域）维护一个引用计数的属性。   </p>
<p>在一个引用被创建或复制时，Python把该对象的引用计数+1；<br>当引用被销毁时把该对象的引用计数-1。</p>
<p>当对象的引用计数减到0，可以认为Python中不会再引用这个对象，就可以释放对象占据的内存空间了。</p>
<p>优点：实时性。其他语言的垃圾回收可能只在固定的时间点上进行，如内存分配失败时进行垃圾回收，而引用计数可以动态管理内存。</p>
<p>缺点：引用计数在每次引用创建和销毁时都要多做一些操作，创建和销毁很频繁时效率会不足。并且<strong>不能解决循环引用</strong>。</p>
<p><strong>标记-清除：</strong><br>标记-清除能解决循环引用的问题。只有容器对象（列表、字典、类、元组）才会出现循环引用的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>] <span class="comment"># a的引用为1</span></span><br><span class="line">b=[<span class="number">3</span>,<span class="number">4</span>] <span class="comment"># b的引用为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#循环引用</span></span><br><span class="line">a.append(b) <span class="comment"># b的引用为2</span></span><br><span class="line">b.append(a) <span class="comment"># a的引用为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要删除a,应该如何回收呢？（注意删除a可以使用del a，这样a这个引用就不存在了，但是它指向的对象，在标记删除后还存在，因为还被b使用着）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c=[<span class="number">5</span>,<span class="number">6</span>] <span class="comment"># c的引用为1</span></span><br><span class="line">d=[<span class="number">7</span>,<span class="number">8</span>] <span class="comment"># d的引用为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#循环引用</span></span><br><span class="line">c.append(d) <span class="comment">#c的引用为2</span></span><br><span class="line">d.append(c) <span class="comment">#d的引用为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要同时删除c、d，应该如何回收呢？</span></span><br></pre></td></tr></table></figure>
<p>上面的哪种情况都无法通过引用计数完成回收，因为引用始终大于0，不会回收。</p>
<p>Python 标记-清除通过两个容器来完成的：死亡容器和存活容器。</p>
<p>首先分析情况2：删除c、d</p>
<p>删除后，c和d的引用都为1，根据引用计数还是无法删除。</p>
<p>标记-清除 第一步：对执行删除操作后的每个引用-1，此时c和d的引用都为0，把它们都放入死亡容器。把那些引用大于0的放入存活容器。</p>
<p>标记-清除 第二步：遍历存活容器，查看是否有存活容器内的对象引用了死亡容器内的对象，如果有就把该对象(注意是对象，比如0x7f94bb602f80，不是对象的引用)从死亡容器内取出并放入存活容器。</p>
<p>由于c、d都没有对象引用它们了，所以经过上述步骤，它们还是在死亡容器内。</p>
<p>标记删除第三步：删除死亡容器内的所有对象。</p>
<p>这样就完成了对从c、d的删除。</p>
<p>同样道理分析情况1：只删除a</p>
<p>标记-清除 第一步：对执行删除（-1）后的每个引用-1，那么a的引用就是0，b的引用为1，将a放到死亡容器，将b放到存活容器。</p>
<p>标记-清除 第二步：循环存活容器，发现b引用a，复活a：将a放到存活容器内。</p>
<p>标记-清除 第三步：删除死亡容器内的所有对象。</p>
<p>对于循环引用，必须将循环引用的双方对象都删除，才能被回收。</p>
<p><strong>分代回收：</strong></p>
<p>了解分类回收要先了解GC的阈值。阈值是一个临界点的值。随着程序运行，Python解释器保持对新创建的对象和因为引用计数为零被释放的对象的追踪。理论上创建数量应该等于释放数量。如果存在循环引用，那么创建数量就大于释放数量，当创建数量与释放数量的差值达到规定的阈值时，就需要分代回收机制。</p>
<p>垃圾回收=垃圾检测+释放。</p>
<p>分代回收将对象分为三代。幼年对象（0代），青年对象（1代），老年对象（2代）。根据弱代假说（年轻对象易死掉，老年对象活更久）新生对象被放入0代，如果该对象在第0代的一次gc垃圾回收中存活，它就被放到第1代里。如果第1代的对象在第1代的一次gc垃圾回收中存活，它就被放到第2代里。</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx动静分离实例一</title>
    <url>/2020/04/17/Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%AE%9E%E4%BE%8B%E4%B8%80/</url>
    <content><![CDATA[<p>首先创建一个文件夹data，文件夹目录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data</span><br><span class="line">|</span><br><span class="line">|---image</span><br><span class="line">|     |---final.jpg</span><br><span class="line">|</span><br><span class="line">|---www</span><br><span class="line">      |---test.html</span><br></pre></td></tr></table></figure>
<p>接下来需要在 nginx.conf 进行动静分离的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        # 监听192.168.1.165：9080 这个服务器端口</span><br><span class="line">        listen       9080;</span><br><span class="line">        server_name  192.168.1.165;</span><br><span class="line"></span><br><span class="line">        location &#x2F;www&#x2F; &#123;</span><br><span class="line">            # 文件夹存储路径</span><br><span class="line">            root   C:&#x2F;Users&#x2F;qiany&#x2F;Desktop&#x2F;data&#x2F;;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location &#x2F;image&#x2F; &#123;</span><br><span class="line">            root   C:&#x2F;Users&#x2F;qiany&#x2F;Desktop&#x2F;data&#x2F;;</span><br><span class="line">            autoindex  on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/04/18/JeVykj.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/18/JeV2pq.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/18/JeVR10.png" alt="avatar"></p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx负载均衡实例一</title>
    <url>/2020/04/17/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%E4%B8%80/</url>
    <content><![CDATA[<h5 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h5><p>实现效果：在浏览器地址栏输入地址 <a href="http://192.168.1.165:8088/edu/" target="_blank" rel="noopener">http://192.168.1.165:8088/edu/</a> ,实现负载均衡效果，平均在8080和8081两个端口中。</p>
<p>首先使用Django新建两个项目server1和server2，并且分别添加一个index.html，端口号分别是8080和8081，index的路由都是edu/</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZbr8I.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZbgr8.png" alt="avatar"></p>
<p>接下来需要在 nginx.conf 进行负载均衡的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">		server 192.168.1.165:8080;</span><br><span class="line">		server 192.168.1.165:8081;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8088;</span><br><span class="line">        server_name  192.168.1.165;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">			proxy_pass  http:&#x2F;&#x2F;myserver;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们试着在浏览器里输入<a href="http://192.168.1.165:8088/edu/" target="_blank" rel="noopener">http://192.168.1.165:8088/edu/</a> ，试着多刷新几次，会发现界面来回跳转，说明负载均衡在8080和8081两个服务器上成功实现。</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZbjIJ.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZqPsK.png" alt="avatar"></p>
<h5 id="几种不同的负载均衡的实现方式"><a href="#几种不同的负载均衡的实现方式" class="headerlink" title="几种不同的负载均衡的实现方式"></a>几种不同的负载均衡的实现方式</h5><p>一. 轮询：默认的策略，把每个请求按顺序逐一分配到不同的server，如果server挂掉，能自动剔除。</p>
<p>二.权重：使用weight来指定server访问比率，weight默认是1。以下配置会是server2访问的比例是server1的两倍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　server 127.0.0.1:4501  weight&#x3D;1; #服务器A</span><br><span class="line">　　server 127.0.0.1:4502  weight&#x3D;2; #服务器B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三. 最少连接：把请求分配到连接数最少的server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　least_conn;</span><br><span class="line">　　server 127.0.0.1:4501; #真实服务器A(sxwgf-PC)</span><br><span class="line">　　server 127.0.0.1:4502; #真实服务器B(hzdk-vpc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四. ip_hash：每个请求会按照访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一server进行处理，可以解决session的问题。如果server挂掉，能自动剔除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　ip_hash;</span><br><span class="line">　　server 127.0.0.1:4501; #真实服务器A(sxwgf-PC)</span><br><span class="line">　　server 127.0.0.1:4502; #真实服务器B(hzdk-vpc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>五. fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　server 127.0.0.1:4501; #真实服务器A(sxwgf-PC)</span><br><span class="line">　　server 127.0.0.1:4502; #真实服务器B(hzdk-vpc)</span><br><span class="line">    fair</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理实例二</title>
    <url>/2020/04/17/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B%E4%BA%8C/</url>
    <content><![CDATA[<h5 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h5><p>实现效果：使用Nginx反向代理，根据访问的路径跳转到不同服务端口的服务中。<br>Nginx监听端口为9001<br>访问：<a href="http://127.0.0.1:9001/edu/" target="_blank" rel="noopener">http://127.0.0.1:9001/edu/</a> 直接跳转到127.0.0.1:8080<br>访问：<a href="http://127.0.0.1:9001/vod/" target="_blank" rel="noopener">http://127.0.0.1:9001/vod/</a> 直接跳转到127.0.0.1:8081</p>
<p>首先使用Django新建两个项目server1和server2，并且分别添加一个index.html，index的路由分别是edu/和vod/</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZhqSS.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZ4KfK.png" alt="avatar"></p>
<p>接下来需要在 nginx.conf 进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我们通过Django创建了两个项目，那么就是两个服务器，端口号分别是 8080 和 8081</span><br><span class="line"># Nginx通过监听 192.168.1.165:9001 这个端口，然后分别将 edu&#x2F; 和 vod&#x2F; 的 url 分发至服务器 127.0.0.1:8080 和 127.0.0.1:8081</span><br><span class="line"># location 使我们新加的一个字段</span><br><span class="line"># ‘~’ 用于表示URI包含正则表达式，并且区分大小写</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       9001;</span><br><span class="line">    server_name  192.168.1.165;</span><br><span class="line"></span><br><span class="line">    location ~ &#x2F;edu&#x2F; &#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ &#x2F;vod&#x2F; &#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8081;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们试着在浏览器里输入<a href="http://192.168.1.165:9001/edu/" target="_blank" rel="noopener">http://192.168.1.165:9001/edu/</a> 和 <a href="http://192.168.1.165:9001/vod/" target="_blank" rel="noopener">http://192.168.1.165:9001/vod/</a></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZ5iNt.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZ5E38.png" alt="avatar"></p>
<p>实验成功。</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理实例一</title>
    <url>/2020/04/16/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B%E4%B8%80/</url>
    <content><![CDATA[<p>我使用了Nginx + Django自带的服务器来进行反向代理的实例</p>
<p>首先新建一个Django项目，然后进入 settings 进行配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS = [<span class="string">'*'</span>,]</span><br></pre></td></tr></table></figure>
<p>然后启动Django，使用如下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
<p>因为我设置的服务器端的ip地址是：192.168.1.165，所以在浏览器输入 192.168.1.165：8000，可以看到Django启动页面</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JE8YZV.png" alt="avatar"></p>
<p>然后在本地的HOST文件进行ip映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.165 www.mydjango.com</span><br></pre></td></tr></table></figure>
<p>试着在浏览器输入 mydjango.com:8000</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JE8NIU.png" alt="avatar"></p>
<p>假如我们想通过 mydjango.com:80 来访问服务器，那么我们需要添加一个Nginx反向代理服务器，它通过监听 mydjango.com:80，然后将请求转发给目标服务器的8000端口。接下来配置nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我们找到server块</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.1.165; # 目标服务器的ip地址</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8000 # 反向代理的目标服务器</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mydjango.com</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/04/17/JE8RiD.png" alt="avatar"><br>成功访问。</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门</title>
    <url>/2020/04/16/Nginx%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h5 id="Nginx的介绍"><a href="#Nginx的介绍" class="headerlink" title="Nginx的介绍"></a>Nginx的介绍</h5><p>Nginx 是一个高性能的HTTP和反向代理web服务器。</p>
<p>其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</p>
<p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是<strong>占有内存少，并发能力强</strong>。中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<h5 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h5><p>一. 可以高并发连接：官方测试Nginx能够支撑5万并发连接。</p>
<p>二. 内存消耗少。</p>
<p>三. 成本低廉：购买F5BIG-IP、NetScaler等硬件负载均衡交换机，需要十多万到几十万人民币；Nginx为开源软件，可以免费试用并用于商业用途。</p>
<p>BSD开源协议可以自由使用、修改源代码、也可以将修改后的代码作为开源或专用软件再发布。</p>
<p>四. 配置文件非常简单。</p>
<p>五. 支持Rewrite重写：能够根据域名、URL的不同，将http请求分到不同的后端服务器群组。</p>
<p>六. 内置的健康检查功能：如果NginxProxy后端的某台Web服务器宕机了，不会影响前端的访问。</p>
<p>七. 稳定性高：用于反向代理，宕机的概率微乎其微。</p>
<p>八. 支持热部署：它的自动特别容易，几乎可以7天*24小时不间断的运行。即使运行数个月也无需重启，还能在不间断服务的情况下，升级软件版本。</p>
<h5 id="Nginx的相关特性"><a href="#Nginx的相关特性" class="headerlink" title="Nginx的相关特性"></a>Nginx的相关特性</h5><p><strong>正向代理</strong> ：是位于客户端和目标服务器之间的代理（中间）服务器。为了从目标服务器取得内容，客户端向代理服务器发送请求并指定目标服务器。代理服务器向目标服务器转交并且将获得的内容返回给客户端。</p>
<p>正向代理需要客户端进行一些设置才能使用。</p>
<p><img src="https://pic4.zhimg.com/v2-b2c357e187a1259829f0d08e1de16737_b.jpg" alt="avatar"></p>
<p><strong>反向代理</strong> ：客户端对代理服务器是无感知的，客户端无需任何配置。用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。反向代理服务器和目标服务器对外而言就是一个服务器，只暴露了代理服务器地址，隐藏了真实服务器的IP地址。</p>
<p><img src="https://pic2.zhimg.com/v2-7a3cf7885df57a322cab8c9d8dc25cc5_b.jpg" alt="avatar"></p>
<p><strong>负载均衡</strong> ：将原先请求集中到单个服务器上的情况改为增加服务器的数量。将请求分发到各个服务器上，将负载分发到不同的服务器，即负载均衡。</p>
<p><img src="https://pic2.zhimg.com/v2-744d9c94b3fcdebceab2ae1b7c7798e9_b.jpg" alt="avatar"></p>
<p><strong>动静分离</strong> ：为了加快网站的解析速度，把静态页面和动态页面由不同服务器解析，加快解析速度，降低单个服务器的压力。</p>
<p><img src="https://pic1.zhimg.com/v2-8257f63059cd86ff676d3e2e4a9d10d0_b.jpg" alt="avatar"></p>
<p><strong>高可用</strong> ：为了提高系统的可用性和容错能力，可以增加nginx服务器的数量，当主服务器发生故障或宕机，备份服务器可以立即充当主服务器进行不间断工作。</p>
<p><img src="https://pic1.zhimg.com/v2-d26d65f53f88cec4d7553637ca56cb00_b.jpg" alt="avatar"></p>
<h5 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h5><h6 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h6><p>Nginx 配置文件由全局块、events块和http块三部分组成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123;</span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN]</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一. 第一部分 全局块<br>主要设置一些影响 Nginx 服务器整体运行的配置指令。  比如： worker_processes 1; ， worker_processes 值越大，可以支持的并发处理量就越多。</p>
<p>二. 第二部分 events块<br>events 块涉及的指令主要影响Nginx服务器与用户的网络连接。  比如： worker_connections 1024; ，支持的最大连接数。</p>
<p>三. 第三部分 http块<br>http 块又包括 http 全局块和 server 块，是服务器配置中最频繁的部分，包括配置代理、缓存、日志定义等绝大多数功能。</p>
<p>server块：配置虚拟主机的相关参数。<br>location块：配置请求路由，以及各种页面的处理情况。</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>百度翻译PythonAPI的简单使用</title>
    <url>/2020/04/12/%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91PythonAPI%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>美国疫情一天比一天严重了，回国的计划也被打乱了。现在有大把的时间来写一写Python简单的小demo来娱乐一下。  </p>
<p>百度翻译API链接：<a href="http://api.fanyi.baidu.com/doc/21" target="_blank" rel="noopener">http://api.fanyi.baidu.com/doc/21</a></p>
<p>下面是官方给的Python3的demo</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#百度通用翻译API,不包含词典、tts语音合成等资源，如有相关需求请联系translate_api@baidu.com</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">appid = <span class="string">''</span>  <span class="comment"># 填写你的appid</span></span><br><span class="line">secretKey = <span class="string">''</span>  <span class="comment"># 填写你的密钥</span></span><br><span class="line"></span><br><span class="line">httpClient = <span class="literal">None</span></span><br><span class="line">myurl = <span class="string">'/api/trans/vip/translate'</span></span><br><span class="line"></span><br><span class="line">fromLang = <span class="string">'auto'</span>   <span class="comment">#原文语种</span></span><br><span class="line">toLang = <span class="string">'zh'</span>   <span class="comment">#译文语种</span></span><br><span class="line">salt = random.randint(<span class="number">32768</span>, <span class="number">65536</span>)</span><br><span class="line">q= <span class="string">'apple'</span></span><br><span class="line">sign = appid + q + str(salt) + secretKey</span><br><span class="line">sign = hashlib.md5(sign.encode()).hexdigest()</span><br><span class="line">myurl = myurl + <span class="string">'?appid='</span> + appid + <span class="string">'&amp;q='</span> + urllib.parse.quote(q) + <span class="string">'&amp;from='</span> + fromLang + <span class="string">'&amp;to='</span> + toLang + <span class="string">'&amp;salt='</span> + str(</span><br><span class="line">salt) + <span class="string">'&amp;sign='</span> + sign</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    httpClient = http.client.HTTPConnection(<span class="string">'api.fanyi.baidu.com'</span>)</span><br><span class="line">    httpClient.request(<span class="string">'GET'</span>, myurl)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># response是HTTPResponse对象</span></span><br><span class="line">    response = httpClient.getresponse()</span><br><span class="line">    result_all = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    result = json.loads(result_all)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">print</span> (e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> httpClient:</span><br><span class="line">        httpClient.close()</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'from'</span>: <span class="string">'en'</span>, <span class="string">'to'</span>: <span class="string">'zh'</span>, <span class="string">'trans_result'</span>: [&#123;<span class="string">'src'</span>: <span class="string">'apple'</span>, <span class="string">'dst'</span>: <span class="string">'苹果'</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>简单地用面向对象方式改写一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaiduTranslate</span>:</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, q)</span>:</span></span><br><span class="line">       self.q = q</span><br><span class="line">       self.__appid = <span class="string">''</span>  <span class="comment"># appid</span></span><br><span class="line">       self.__secretKey = <span class="string">''</span>  <span class="comment"># 密钥</span></span><br><span class="line">       self.__myurl = <span class="string">"http://api.fanyi.baidu.com/api/trans/vip/translate"</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">       fromLang = <span class="string">'auto'</span>  <span class="comment"># 原文语种</span></span><br><span class="line">       toLang = <span class="string">'zh'</span>  <span class="comment"># 译文语种</span></span><br><span class="line">       salt = random.randint(<span class="number">32768</span>, <span class="number">65536</span>)  <span class="comment"># 随机数</span></span><br><span class="line">       sign = self.__appid + self.q + str(salt) + self.__secretKey</span><br><span class="line">       sign = hashlib.md5(sign.encode()).hexdigest()  <span class="comment"># "appid+q+salt+密钥 的MD5值"</span></span><br><span class="line"></span><br><span class="line">       params = &#123;<span class="string">'appid'</span>: self.__appid, <span class="string">'q'</span>: self.q, <span class="string">'from'</span>: fromLang, <span class="string">'to'</span>: toLang, <span class="string">'salt'</span>: salt, <span class="string">'sign'</span>: sign&#125;</span><br><span class="line">       r = requests.get(self.__myurl, params=params)</span><br><span class="line">       print(r.url)</span><br><span class="line">       dict_json = json.loads(r.content.decode())</span><br><span class="line">       print(<span class="string">"查询的英文单词: "</span>, dict_json[<span class="string">'trans_result'</span>][<span class="number">0</span>][<span class="string">'src'</span>])</span><br><span class="line">       print(<span class="string">"结果为: "</span>, dict_json[<span class="string">'trans_result'</span>][<span class="number">0</span>][<span class="string">'dst'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   bt = BaiduTranslate(<span class="string">'sunflower'</span>)</span><br><span class="line">   bt.run()</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>查询的英文单词:  sunflower</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>结果为:  向日葵</span><br></pre></td></tr></table></figure>
<p>难度系数为0，非常简单。之所以选择官方的api是因为我爬网页版的百度翻译爬不到了，具体原因之后有时间会解决。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程进阶</title>
    <url>/2020/03/24/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h5 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h5><p><code>threading.currentThread(): 返回当前的线程变量。</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(threading.currentThread)</span><br><span class="line">print(threading.current_thread)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;function current_thread at <span class="number">0x000001DB08FAE1F8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;function current_thread at <span class="number">0x000001DB08FAE1F8</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return a list of all Thread objects currently alive.</span></span><br><span class="line">print(threading.enumerate())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[&lt;_MainThread(MainThread, started <span class="number">24368</span>)&gt;]</span><br><span class="line"></span><br><span class="line">print(len(threading.enumerate()))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return the number of Thread objects currently alive.</span></span><br><span class="line">print(threading.activeCount())</span><br><span class="line">print(threading.active_count())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>线程模块还提供了Thread类来处理线程:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">run(): 表示线程活动的方法。</span><br><span class="line">start():启动线程活动。</span><br><span class="line">join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</span><br><span class="line">isAlive(): 返回线程是否活动。</span><br><span class="line">getName(): 返回线程名。</span><br><span class="line">setName(): 设置线程名。</span><br></pre></td></tr></table></figure>
<h5 id="自定义线程"><a href="#自定义线程" class="headerlink" title="自定义线程"></a>自定义线程</h5><p>继承threading.Thread自定义线程类，本质是重构Thread类中的run方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"task&#123;&#125;\n"</span>.format(self.n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'2s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'1s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'0s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"t1"</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">"t2"</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task t1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task t2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>s</span><br></pre></td></tr></table></figure>
<h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p><strong>守护线程的理解：</strong><br>守护线程是“不重要”的。“不重要”意味着如果<strong>它的主进程结束了但它没运行完，它会被强制结束。如果线程是非守护线程，那么父进程只有等到非守护线程运行完毕后再结束。</strong>  </p>
<p>在python中，线程通过<code>threadName.setDaemon(True|False)</code>来设置是否为守护线程。</p>
<p><strong>守护线程的作用：</strong>  </p>
<p>为其他线程提供便利服务，守护线程最典型的应用就是 GC (垃圾收集器)。</p>
<p><strong>守护线程的特点：</strong>  </p>
<p>如果主线程的任一非守护线程未结束，那么守护线程就全部工作；只有当全部非守护线程结束时，守护线程随主线程一同结束工作。</p>
<p>情况一：线程为非守护线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start fun"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end fun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main thread"</span>)</span><br><span class="line">    t1 = threading.Thread(target=fun)</span><br><span class="line">    t1.setDaemon(<span class="literal">False</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">"main thread end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>start fun</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>end fun</span><br></pre></td></tr></table></figure>
<p>说明程序在等待子线程结束再退出。  </p>
<p>情况二：线程为守护线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start fun"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end fun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main thread"</span>)</span><br><span class="line">    t1 = threading.Thread(target=fun)</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">"main thread end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>start fun</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread end</span><br></pre></td></tr></table></figure>
<p>说明程序在主线程结束后直接退出，子线程没有运行完。</p>
<h5 id="多线程共享全局变量"><a href="#多线程共享全局变量" class="headerlink" title="多线程共享全局变量"></a>多线程共享全局变量</h5><p>线程是进程的执行单元，进程是系统分配资源的最小单位。同一个进程中的多线程可以共享资源。</p>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>线程之间随机调度，多个线程同时修改同一数据时可能出现脏数据。如果没有很好地保护该对象，会造成程序结果的不可预期(“线程不安全”)。</p>
<p>线程锁：<strong>同一时刻只允许一个线程执行操作</strong>。线程锁用于锁定资源，<strong>我们可以定义多个锁, 当线程需要独占某一资源时，任何一个锁都可以锁资源，就好比用不同的锁都可以锁住相同的一个门。</strong></p>
<p>未使用线程锁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">my_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum1:&#123;&#125;"</span>.format(my_num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum2:&#123;&#125;"</span>.format(my_num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    first_thread = threading.Thread(target=sum1)</span><br><span class="line">    second_thread = threading.Thread(target=sum2)</span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum1:<span class="number">1014346</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum2:<span class="number">1071272</span></span><br></pre></td></tr></table></figure>
<p>互斥锁为资源引入一个状态：锁定/非锁定。</p>
<p>某个线程要更改共享数据时，先将其锁定，此时资源状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源状态变成“非锁定”，其他线程才能锁定该资源。<strong>互斥锁保证每次只有一个线程运行，保证了多线程情况下数据的正确性。</strong>    </p>
<p>当一个线程调用锁的<code>acquire()</code>获得锁时，锁进入“locked”状态。</p>
<p>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态(“阻塞”)。直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。</p>
<p>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">my_num = <span class="number">0</span>  <span class="comment"># 全局变量</span></span><br><span class="line">lock = threading.Lock()  <span class="comment"># 创建互斥锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum1:"</span>, my_num)</span><br><span class="line">    lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum2:"</span>, my_num)</span><br><span class="line">    lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    first_thread = threading.Thread(target=sum1)</span><br><span class="line">    second_thread = threading.Thread(target=sum2)</span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 互斥锁:能保证统一时刻只有一个线程执行，哪个线程抢到这个互斥锁我们决定不了，但能保证数据最终不会有问题</span></span><br><span class="line">    <span class="comment"># 加上互斥锁把多任务瞬间变成单任务，执行效率会下降。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum1:<span class="number">1000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum2:<span class="number">2000000</span></span><br></pre></td></tr></table></figure>
<p>锁的好处：</p>
<ol>
<li>确保了某段代码只由一个线程执行。</li>
</ol>
<p>锁的坏处：</p>
<ol>
<li>阻止了多线程并发执行，包含锁的代码实际上以单线程模式执行，效率下降。</li>
<li>由于可以存在多个锁，不同的线程持有不同的锁，当试图获取对方持有的锁时，可能造成死锁。</li>
</ol>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>举个生活中死锁的例子</p>
<ol>
<li>A拿了苹果</li>
<li>B拿了香蕉</li>
<li>A现在想拿香蕉，就等待B释放香蕉</li>
<li>B想拿苹果，就等待A释放苹果</li>
<li>AB陷入僵局(死锁)</li>
</ol>
<p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并同时等待对方释放资源，就会造成死锁。因为这部分资源都正在使用，所以这两个线程在无外力作用下将一直等待下去。下面是一个死锁的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock_apple = threading.Lock()</span><br><span class="line">lock_banana = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fun1()</span><br><span class="line">        self.fun2()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock_apple.acquire()  <span class="comment"># 如果锁被占用,则阻塞在这里,等待锁的释放</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line"></span><br><span class="line">        lock_banana.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line">        lock_banana.release()</span><br><span class="line"></span><br><span class="line">        lock_apple.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock_banana.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line"></span><br><span class="line">        lock_apple.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line">        lock_apple.release()</span><br><span class="line"></span><br><span class="line">        lock_banana.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):  <span class="comment">#建立10个线程</span></span><br><span class="line">        my_thread = MyThread()</span><br><span class="line">        my_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-1</span> , 想拿: 苹果</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-2</span> , 想拿: 苹果</span><br></pre></td></tr></table></figure>
<p>我们来看执行流程：</p>
<ol>
<li>fun1中，线程1先拿了苹果又拿了香蕉，然后释放香蕉和苹果.然后在在fun2中拿了香蕉。</li>
<li>在线程1执行时，线程2开始执行。苹果被线程1释放，线程2获得了苹果，然后想拿香蕉。</li>
<li>线程1拿完香蕉后想拿苹果，发现苹果被线程2拿到了；线程2拿完苹果后想拿香蕉，发现香蕉被线程1持有。</li>
<li>双向等待，出现死锁，代码执行不下去。</li>
</ol>
<p>上面就是大概的执行流程和死锁出现的原因。这就是同一线程中多次请求同一资源时候出现的问题。</p>
<h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>递归锁就是维护一个计数器。<strong>比如A线程获得一个锁,计数器+1；释放锁，计数器-1。如果计数器不为0，其他线程无法获得锁，只能等待。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock = threading.RLock()  <span class="comment">#递归锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fun1()</span><br><span class="line">        self.fun2()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock.acquire()  <span class="comment"># 如果锁被占用,则阻塞在这里,等待锁的释放</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line"></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):  <span class="comment">#建立10个线程</span></span><br><span class="line">        my_thread = MyThread()</span><br><span class="line">        my_thread.start()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 苹果</span><br></pre></td></tr></table></figure>
<h5 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h5><p>semaphore是一个内置的计数器</p>
<ol>
<li>调用<code>acquire()</code>，计数器-1</li>
<li>调用<code>release()</code>，计数器+1</li>
</ol>
<p>计数器不能小于0。当计数器为0时，<code>acquire()</code>将阻塞，直到其他线程调用<code>release()</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"ok &#123;&#125;\n"</span>.format(time.ctime()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t1 = threading.Thread(target=foo)</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>
<p>程序会在很短时间内生成10个线程来打印一句话。</p>
<p>如果在主机执行IO密集型任务的时候执行这类程序，主机很可能宕机。可以为程序添加计数器功能，来限制一个时间点内的线程数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">s1=threading.Semaphore(<span class="number">5</span>)	<span class="comment">#添加一个计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	s1.acquire()</span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line">	print(<span class="string">"ok&#123;&#125;\n"</span>.format(time.ctime()))</span><br><span class="line">	s1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	t1=threading.Thread(target=foo)</span><br><span class="line">	t1.start()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>
<h5 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set() — 全局内置标志Flag，将标志Flag 设置为 <span class="literal">True</span>,通知在等待状态(wait)的线程恢复运行;</span><br><span class="line"></span><br><span class="line">isSet() — 获取标志Flag当前状态，返回<span class="literal">True</span> 或者 <span class="literal">False</span>;</span><br><span class="line"></span><br><span class="line">wait() — 一旦调用，线程将会处于阻塞状态，直到等待其他线程调用set()函数恢复运行;</span><br><span class="line"></span><br><span class="line">clear() — 将标志设置为<span class="literal">False</span>；</span><br></pre></td></tr></table></figure>
<p>事件event中有一个全局内置标志Flag，值为 True 或者False。使用wait()函数的线程会处于阻塞状态,此时Flag指为False，直到有其他线程调用set()函数让全局标志Flag置为True，其阻塞的线程立刻恢复运行，还可以用isSet()函数检查当前的Flag状态.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建event事件</span></span><br><span class="line">eEvent = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_girl_friend</span><span class="params">(id)</span>:</span></span><br><span class="line">    print(<span class="string">"单身狗&#123;&#125;都准备完毕，Flag状态：&#123;&#125;\n"</span>.format(id,eEvent.isSet()))</span><br><span class="line">    eEvent.wait()</span><br><span class="line">    print(<span class="string">"单身狗&#123;&#125;告别单身\n"</span>.format(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    thread_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> id <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        t = threading.Thread(target=get_girl_friend,args=(id,))</span><br><span class="line">        t.start()</span><br><span class="line">        thread_list.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 所有线程准备完毕，将event内置Flag设置为True,恢复正在阻塞的线程</span></span><br><span class="line">    eEvent.set()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历列表，阻塞主线程</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        <span class="comment"># 阻塞主线程，等待所有子线程结束</span></span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">单身狗<span class="number">1</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">2</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">3</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">4</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">5</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">6</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">7</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">8</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">9</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">10</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">1</span>告别单身</span><br><span class="line">单身狗<span class="number">2</span>告别单身</span><br><span class="line">单身狗<span class="number">3</span>告别单身</span><br><span class="line">单身狗<span class="number">4</span>告别单身</span><br><span class="line">单身狗<span class="number">6</span>告别单身</span><br><span class="line">单身狗<span class="number">7</span>告别单身</span><br><span class="line">单身狗<span class="number">5</span>告别单身</span><br><span class="line">单身狗<span class="number">8</span>告别单身</span><br><span class="line">单身狗<span class="number">9</span>告别单身</span><br><span class="line">单身狗<span class="number">10</span>告别单身</span><br></pre></td></tr></table></figure>
<p>注意互斥锁Lock与事件Event区别，需求不同，使用方式也不同：</p>
<ol>
<li><p>互斥锁Lock主要针对多个线程同时操作同一个数据，使用互斥锁可以保证数据正常修改或者访问；</p>
</li>
<li><p>事件Event主要用于唤醒正在阻塞等待状态的线程;</p>
</li>
</ol>
<h5 id="线程优先级队列（Queue）"><a href="#线程优先级队列（Queue）" class="headerlink" title="线程优先级队列（Queue）"></a>线程优先级队列（Queue）</h5><p>Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。</p>
<p>这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p>
<p>Queue 模块中的常用方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Queue.qsize() 返回队列的大小</span><br><span class="line">Queue.empty() 如果队列为空，返回<span class="literal">True</span>,反之<span class="literal">False</span></span><br><span class="line">Queue.full() 如果队列满了，返回<span class="literal">True</span>,反之<span class="literal">False</span></span><br><span class="line">Queue.full 与 maxsize 大小对应</span><br><span class="line">Queue.get([block[, timeout]])获取队列，timeout等待时间</span><br><span class="line">Queue.get_nowait() 相当Queue.get(<span class="literal">False</span>)</span><br><span class="line">Queue.put(item) 写入队列，timeout等待时间</span><br><span class="line">Queue.put_nowait(item) 相当Queue.put(item, <span class="literal">False</span>)</span><br><span class="line">Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</span><br><span class="line">Queue.join() 实际上意味着等到队列为空，再执行别的操作</span><br></pre></td></tr></table></figure>
<h5 id="GIL（Global-Interpreter-Lock）全局解释器锁"><a href="#GIL（Global-Interpreter-Lock）全局解释器锁" class="headerlink" title="GIL（Global Interpreter Lock）全局解释器锁"></a>GIL（Global Interpreter Lock）全局解释器锁</h5><p>在非python环境中，单核CPU同时只能有一个任务执行。多核CPU支持多个线程同时执行。但在python中,无论CPU有多少核,同时只能执行一个线程。这是GIL导致的。</p>
<p>GIL：Global Interpreter Lock(全局解释器锁)，是python设计之初为了数据安全所做的决定。某个线程想要执行前，必须先拿到GIL(“通行证”)。在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许执行。GIL只在cpython中才有，因为cpython调用c语言的原生线程，所以它不直接操作cpu，只能利用GIL保证同一时间只有一个线程拿到数据。而在pypy和jpython中是没有GIL的。</p>
<p>Python多线程的工作过程：</p>
<p>python在使用多线程的时候，调用的是c语言的原生线程。</p>
<ol>
<li>拿到公共数据</li>
<li>申请GIL</li>
<li>python解释器调用os原生线程</li>
<li>os操作cpu执行运算</li>
<li>当该线程执行时间到后，无论运算是否执行完，GIL都被释放</li>
<li>其他线程重复上面的过程</li>
<li>等其他线程执行完后，又会切换到之前的线程（从他记录的上下文继续执行），整个过程是每个线程执行自己的运算，当执行时间到就进行切换。</li>
</ol>
<p>python针对不同类型的代码执行效率也是不同的：</p>
<ol>
<li>CPU密集型代码(各种循环处理、计算等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。</li>
<li>IO密集型代码(文件处理、网络爬虫等涉及文件读写的操作)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。</li>
</ol>
<p>使用建议:</p>
<p>python下想要充分利用多核CPU，就用多进程。因为每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。</p>
<p>GIL在python中的版本差异：</p>
<ol>
<li>在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100时进行释放。（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过sys.setcheckinterval 来调整）。而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。</li>
<li>在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程基础</title>
    <url>/2020/03/23/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>多线程是多个任务同时运行的一种方式</strong>。假设一个循环就是一个任务，我们希望第一次循环运行还没结束时，就能开始第二次循环，以此节省时间。</p>
<p>使用多线程的目的是最大化利用CPU的计算能力，利用等待的时间。如果程序耗时不是因为等待的时间，而是任务非常多，那么多线程无法改善运行时间。</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><p>先看下面这个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<p>运行10次<code>myfun()</code>，运行时间主要取决于每次<code>time.sleep(1)</code>，a的计算耗时可以忽略不计。这种情况可以用多线程提高效率。</p>
<p>不使用多线程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    myfun()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5.000431537628174</span></span><br></pre></td></tr></table></figure>
<p>使用多线程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br></pre></td></tr></table></figure>
<p>运行1秒后同时打印5个2，说明5次循环几乎同时运行。因为5次1秒的等待时间同时进行，所以最后只等待了1秒。</p>
<p>这里多线程包括了两步：</p>
<ol>
<li>Thread创建新线程，每一次循环创建新线程并执行<code>myfun()</code>。</li>
<li><code>start()</code>运行线程，每个线程都需要这样显式开启才会运行。一个线程开启后，无需等待它运行完成，就能继续向下运行，即下一次循环（然后又新建了第二个线程，运行未结束即开启第三个……）</li>
</ol>
<h5 id="join的使用"><a href="#join的使用" class="headerlink" title="join的使用"></a>join的使用</h5><p>线程的join()方法表示等这个线程运行完毕，程序再往下运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">    th.join()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5.0054051876068115</span></span><br></pre></td></tr></table></figure>
<p><code>start()</code>之后马上<code>join()</code>，表示每个线程都要运行结束才能进行下一次循环。这样就和单线程一样了。</p>
<p>未使用<code>join()</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.0019860267639160156</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">22</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>程序立即输出了结果，但5个2是在打印秒数之后才打印的。这是因为<code>print(time.time() - t)</code>是区别于5次循环线程外的第6个线程。它不会等待5个线程运行结束再开始运行，所以无法获得5个线程的运行时间，需要用<code>join()</code>等待5个线程都运行结束。</p>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line">ths = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">    ths.append(th)</span><br><span class="line"><span class="keyword">for</span> th <span class="keyword">in</span> ths:</span><br><span class="line">    th.join()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为 1.0038363933563232</span></span><br></pre></td></tr></table></figure>
<p>定义ths列表存储线程，最后用循环确保每一个线程都已经运行完成再计算时间差。</p>
<p><code>join()</code>不只适用于这种情形。当当前代码运行依赖之前代码运行完成时，就要加入<code>join()</code>命令。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程</title>
    <url>/2020/03/23/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>整理自<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376" target="_blank" rel="noopener">廖雪峰的官方网站——Python进程和线程</a>  </p>
<p><strong>现代操作系统都是支持“多任务”的操作系统。</strong></p>
<p>“多任务”是操作系统能同时运行多个任务。比如我们一边用浏览器上网，一边听MP3，一边用Word赶作业。这就是多任务，至少同时有3个任务在运行。还有很多任务悄悄地在后台同时运行，只是桌面上没有显示而已。</p>
<p>除了多核CPU，单核CPU也能执行多任务。由于CPU顺序执行代码，那单核CPU怎么执行多任务呢？</p>
<p>答案就是<strong>操作系统轮流让各个任务交替执行</strong>。任务1执行0.01秒，切换到任务2。任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行。每个任务交替执行，但CPU执行速度太快了，我们感觉就像所有任务都在同时执行。</p>
<p>真正的并行执行多任务只能在多核CPU上实现。因为任务数量远远多于CPU的核心数量，所以操作系统会自动把很多任务轮流调度到每个核心上执行。</p>
<p>对于操作系统来说，<strong>一个任务就是一个进程（Process）</strong>。打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还同时干很多事，比如Word，它可以同时进行打字、拼写检查、打印等事情。<strong>在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</strong></p>
<p><strong>由于每个进程至少要干一件事，所以一个进程至少有一个线程。</strong> 像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。真正地同时执行多线程需要多核CPU才可能实现。</p>
<p>平时编写的Python程序都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p>
<p>有三种解决方案：</p>
<ol>
<li><p>启动多个进程，每个进程只有一个线程，但多个进程一块执行多个任务。</p>
</li>
<li><p>启动一个进程，在一个进程内启动多个线程，多个线程一块执行多个任务。</p>
</li>
<li><p>启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了。这种模型更复杂，实际很少采用。</p>
</li>
</ol>
<p>总结一下就是，多任务的实现有3种方式：</p>
<ol>
<li><p>多进程模式；</p>
</li>
<li><p>多线程模式；</p>
</li>
<li><p>多进程+多线程模式。</p>
</li>
</ol>
<p>同时执行多个任务通常各个任务之间是有关联的，需要相互通信和协调。有时，任务1必须暂停等待任务2完成后才能继续执行；有时，任务3和任务4又不能同时执行。</p>
<p>多任务是必须的。例如在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频。否则单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频。</p>
<p>小结：</p>
<ol>
<li><p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定何时执行，执行多久。</p>
</li>
<li><p>多进程和多线程的程序涉及到同步、数据共享的问题，编写复杂。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>对可迭代对象、迭代器和生成器的理解</title>
    <url>/2020/03/23/%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h5 id="可迭代对象和迭代器"><a href="#可迭代对象和迭代器" class="headerlink" title="可迭代对象和迭代器"></a>可迭代对象和迭代器</h5><p>序列可以迭代的原因：<strong>iter</strong> 函数。Python解释器需要迭代对象 x 时，会自动调用 iter(x)。内置的 iter 函数作用如下：</p>
<ol>
<li><p>检查对象是否实现了 __ <strong>iter__</strong> 方法，实现了就调用它，获取一个迭代器。</p>
</li>
<li><p>没有实现 __ <strong>iter__</strong> 方法，但实现了 __ <strong>getitem__</strong> 方法，而且参数是从零开始的索引，Python会创建一个迭代器，尝试按顺序（从索引 0 开始）获取元素。</p>
</li>
<li><p>如果前两步都失败，Python抛出 TypeError 异常，通常会提示“C object is not iterable”，其中 C 是目标对象所属的类。</p>
</li>
</ol>
<p>由此可以明确可迭代对象（Iterable）： 使用 iter 内置函数可以获取迭代器（Iterator）的对象。即对象实现了能返回迭代器的 __ <strong>iter__</strong> 方法或实现了 __ <strong>getitem__</strong> 方法，而且其参数是从零开始的索引。</p>
<p>一个实现 __ <strong>getitem__</strong> 的demo：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.text[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o1 = Test(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o1:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>下面来看一个实现 __ <strong>iter__</strong> 的例子。因为用到了迭代器，所以先明确一下迭代器的用法。 标准的迭代器接口有两个方法：  </p>
<ol>
<li><p>__ <strong>next__</strong> ：返回下一个可用的元素，如果没有元素了就抛出 <strong>StopIteration</strong> 异常。</p>
</li>
<li><p>__ <strong>iter__</strong> ：返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如 for 循环。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Eg2Iterator(self.text) <span class="comment"># 获取一个迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg2Iterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            subtext = self.text[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> subtext</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o2 = Eg2(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o2:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>我们明确可迭代的对象和迭代器之间的关系：</p>
<ol>
<li><p>Python 从可迭代对象中获取迭代器。</p>
</li>
<li><p>__ <strong>iter__</strong> 方法从我们自己创建的迭代器类中获取迭代器，而__ <strong>getitem__</strong> 方法是python内部自动创建迭代器。</p>
</li>
</ol>
<p>我们来了解一下使用更符合 Python 的方式实现 Eg2类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg3</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.text:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o3 = Eg3(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o3:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>
<p>这里使用了 <strong>yield</strong> 关键字， 只要 Python 函数体中有 yield 关键字，该函数就是生成器函数。调用生成器函数时会返回一个生成器对象。也就是说生成器函数是生成器工厂。 上述代码还可以使用yield from进一步简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg3</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o3 = Eg3(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o3:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>还可以使用生成器表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg5</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (item <span class="keyword">for</span> item <span class="keyword">in</span> self.text) <span class="comment"># 生成器表达式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o5 = Eg5(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o5:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><p>可迭代对象（Iterable）要么实现了能返回迭代器的 __ <strong>iter__</strong> 方法，要么实现了 __ <strong>getitem__</strong> 方法而且其参数是从零开始的索引。</p>
</li>
<li><p>迭代器（Iterator）是这样的对象：实现了无参数的 __ <strong>next__</strong> 方法，返回下一个元素，如果没有元素就抛出 StopIteration 异常；并且实现 __ <strong>iter__</strong> 方法，返回迭代器本身。</p>
</li>
<li><p>生成器是带有 yield 关键字的函数。调用生成器函数时，会返回一个生成器对象。</p>
</li>
<li><p>生成器表达式是创建生成器的简洁句法，这样无需先定义函数再调用。</p>
</li>
<li><p>什么是迭代器模式？按需一次获取一个数据项。</p>
</li>
<li><p>生成器和迭代器有什么不同？</p>
<p>相同点：所有生成器都是迭代器，因为生成器完全实现了迭代器接口。</p>
<p>不同点：迭代器用于从集合中取出元素；生成器用于凭空生成元素。</p>
</li>
</ol>
<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>迭代是处理大量数据的好方法。以列表为例，迭代存在两个问题。第一，列表中的元素太多将大量占用内存。第二，我们有时候只需要使用一次数据，如果用列表把数据全部保存起来，将会造成内存浪费。</p>
<p>生成器是创建迭代器的工具。它们像常规函数一样撰写，但是在需要返回数据时使用yield语句。每当对它调用next()函数，生成器从它上次停止的地方重新开始（它会记住所有的数据值和上次执行的语句）。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的property动态属性</title>
    <url>/2020/03/21/Python%E7%9A%84property%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>我们首先定义一个User类，包含两个属性 name 和 birthday</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br></pre></td></tr></table></figure>
<p>如果想获得User实例的年龄，我们可以定义一个方法，然后使用函数调用的方式获得年龄。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br></pre></td></tr></table></figure>
<p>举例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User(<span class="string">"zqy"</span>, date(year=<span class="number">1997</span>, month=<span class="number">6</span>, day=<span class="number">15</span>))</span><br><span class="line">    print(user.get_age()) <span class="comment"># 返回23</span></span><br></pre></td></tr></table></figure>
<p>如果我们想使用调用属性的方式获得年龄（user.age），那么就可以使用property装饰器。<br>为了区别上面的代码，以下是完整的使用property装饰器的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" 将函数调用装饰成属性调用 """</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(<span class="string">"zqy"</span>, date(year=<span class="number">1997</span>, month=<span class="number">6</span>, day=<span class="number">15</span>))</span><br><span class="line">    print(user.age)</span><br></pre></td></tr></table></figure>
<p>我们并没有定义age属性，但是通过property装饰器装饰的age函数，可以直接通过实例调用函数名的方式，作为一个属性返回。<br>那么setter装饰器又是什么呢？  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br><span class="line">        self._age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" 取函数调用的模式编程取属性调用 """</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._age = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(<span class="string">"zqy"</span>, date(year=<span class="number">1997</span>, month=<span class="number">6</span>, day=<span class="number">15</span>))</span><br><span class="line">    user.age = <span class="number">30</span></span><br><span class="line">    print(user._age) <span class="comment"># 30</span></span><br><span class="line">    print(user.age) <span class="comment"># 23</span></span><br></pre></td></tr></table></figure>
<p>1、只有 @property 表示只读。<br>2、同时有 @property 和 @*.setter 表示可读可写。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB的简单介绍</title>
    <url>/2020/03/14/MongoDB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>首先将下载好的文件夹的bin目录添加到系统环境变量中</p>
<p><img src="https://s1.ax1x.com/2020/03/14/81S88f.png" alt="81S88f.png"></p>
<p>在cmd命令行里输入 <strong>mongo</strong> 测试连接</p>
<p><img src="https://s1.ax1x.com/2020/03/14/81Sgr4.png" alt="81Sgr4.png"><br><strong>mongo</strong> 适用于本地连接MongoDB， MongoDB的<strong>默认端口号是27017</strong>。</p>
<h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db</span><br><span class="line">test</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>此命令返回的是MongoDB默认的数据库<strong>test</strong>，下面是返回全部数据库的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show databases;</span><br><span class="line">Qianyi_Zhang_lab6  0.000GB</span><br><span class="line">admin              0.000GB</span><br><span class="line">config             0.000GB</span><br><span class="line">local              0.000GB</span><br><span class="line">students           0.000GB</span><br><span class="line">test               0.000GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h5 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use test</span><br><span class="line">switched to db test</span><br><span class="line">&gt; use students</span><br><span class="line">switched to db students</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h5 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h5><p>官方文档：<a href="https://docs.mongodb.com/manual/reference/insert-methods/" target="_blank" rel="noopener">Insert Methods</a><br>The <strong>db.myCollection.insertOne()</strong> 是 mongo shell 中的一种方法。  </p>
<ul>
<li>db：是当前的数据库</li>
<li>myCollection：当前的collection名字                      </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use myNewDatabase</span><br><span class="line">switched to db myNewDatabase</span><br><span class="line">&gt; db.myCollection.insertOne(&#123;x:1&#125;);</span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedId&quot; : ObjectId(&quot;5e6d1ff57ea55eb9ea1ab738&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.myCollection.insertOne(&#123;x:2, y:3&#125;);</span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedId&quot; : ObjectId(&quot;5e6d203d7ea55eb9ea1ab739&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>MongoDB Compass展示数据库：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/81KET0.png" alt="81KET0.png"></p>
<h5 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h5><p>使用 <strong>db.collection.insertMany()</strong> 方法向inventory collection插入多个新文档（documents）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.inventory.insertMany([</span><br><span class="line">...    &#123; item: &quot;journal&quot;, qty: 25, status: &quot;A&quot;, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, tags: [ &quot;blank&quot;, &quot;red&quot; ] &#125;,</span><br><span class="line">...    &#123; item: &quot;notebook&quot;, qty: 50, status: &quot;A&quot;, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, tags: [ &quot;red&quot;, &quot;blank&quot; ] &#125;,</span><br><span class="line">...    &#123; item: &quot;paper&quot;, qty: 10, status: &quot;D&quot;, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, tags: [ &quot;red&quot;, &quot;blank&quot;, &quot;plain&quot; ] &#125;,</span><br><span class="line">...    &#123; item: &quot;planner&quot;, qty: 0, status: &quot;D&quot;, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, tags: [ &quot;blank&quot;, &quot;red&quot; ] &#125;,</span><br><span class="line">...    &#123; item: &quot;postcard&quot;, qty: 45, status: &quot;A&quot;, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, tags: [ &quot;blue&quot; ] &#125;</span><br><span class="line">... ]);</span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedIds&quot; : [</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace112fe&quot;),</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace112ff&quot;),</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace11300&quot;),</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace11301&quot;),</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace11302&quot;)</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>MongoDB Compass展示数据库：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/81M9N6.png" alt="81M9N6.png">   </p>
<p>其中一个对象的完整内容：  </p>
<p><img src="https://s1.ax1x.com/2020/03/15/81MC4K.png" alt="81MC4K.png"></p>
<h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>数据库内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.insertMany([</span><br><span class="line">   &#123; item: &quot;journal&quot;, qty: 25, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;notebook&quot;, qty: 50, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;A&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;paper&quot;, qty: 100, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;D&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;planner&quot;, qty: 75, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, status: &quot;D&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;postcard&quot;, qty: 45, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/15/81MQC8.png" alt="81MQC8.png"></p>
<p>查询所有数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.inventory.find(&#123;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11304&quot;), &quot;item&quot; : &quot;notebook&quot;, &quot;qty&quot; : 50, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11305&quot;), &quot;item&quot; : &quot;paper&quot;, &quot;qty&quot; : 100, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11306&quot;), &quot;item&quot; : &quot;planner&quot;, &quot;qty&quot; : 75, &quot;size&quot; : &#123; &quot;h&quot; : 22.85, &quot;w&quot; : 30, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11307&quot;), &quot;item&quot; : &quot;postcard&quot;, &quot;qty&quot; : 45, &quot;size&quot; : &#123; &quot;h&quot; : 10, &quot;w&quot; : 15.25, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>按条件查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用这种格式：&#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;</span><br><span class="line"></span><br><span class="line">查询 status&#x3D;D 的数据</span><br><span class="line">&gt; db.inventory.find( &#123; status: &quot;D&quot; &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11305&quot;), &quot;item&quot; : &quot;paper&quot;, &quot;qty&quot; : 100, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11306&quot;), &quot;item&quot; : &quot;planner&quot;, &quot;qty&quot; : 75, &quot;size&quot; : &#123; &quot;h&quot; : 22.85, &quot;w&quot; : 30, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&gt;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询 status&#x3D;A or D 的数据</span><br><span class="line">&gt; db.inventory.find( &#123; status: &#123; $in: [ &quot;A&quot;, &quot;D&quot; ] &#125; &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11304&quot;), &quot;item&quot; : &quot;notebook&quot;, &quot;qty&quot; : 50, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11305&quot;), &quot;item&quot; : &quot;paper&quot;, &quot;qty&quot; : 100, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11306&quot;), &quot;item&quot; : &quot;planner&quot;, &quot;qty&quot; : 75, &quot;size&quot; : &#123; &quot;h&quot; : 22.85, &quot;w&quot; : 30, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11307&quot;), &quot;item&quot; : &quot;postcard&quot;, &quot;qty&quot; : 45, &quot;size&quot; : &#123; &quot;h&quot; : 10, &quot;w&quot; : 15.25, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;   </span><br><span class="line">等价于：SELECT * FROM inventory WHERE status in (&quot;A&quot;, &quot;D&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询 status&#x3D;A and qty&lt;30 的数据</span><br><span class="line">&gt; db.inventory.find( &#123; status: &quot;A&quot;, qty: &#123; $lt: 30 &#125; &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">等价于：SELECT * FROM inventory WHERE status &#x3D; &quot;A&quot; AND qty &lt; 30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询 status&#x3D;A or qty&lt;30 的数据</span><br><span class="line">&gt; db.inventory.find( &#123; $or: [ &#123; status: &quot;A&quot; &#125;, &#123; qty: &#123; $lt: 30 &#125; &#125; ] &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11304&quot;), &quot;item&quot; : &quot;notebook&quot;, &quot;qty&quot; : 50, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11307&quot;), &quot;item&quot; : &quot;postcard&quot;, &quot;qty&quot; : 45, &quot;size&quot; : &#123; &quot;h&quot; : 10, &quot;w&quot; : 15.25, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;   </span><br><span class="line">等价于：SELECT * FROM inventory WHERE status &#x3D; &quot;A&quot; OR qty &lt; 30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询 status&#x3D;A and (qty&lt;30 or item以p开头) 的数据</span><br><span class="line">&gt; db.inventory.find( &#123;</span><br><span class="line">...      status: &quot;A&quot;,</span><br><span class="line">...      $or: [ &#123; qty: &#123; $lt: 30 &#125; &#125;, &#123; item: &#x2F;^p&#x2F; &#125; ]</span><br><span class="line">... &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11307&quot;), &quot;item&quot; : &quot;postcard&quot;, &quot;qty&quot; : 45, &quot;size&quot; : &#123; &quot;h&quot; : 10, &quot;w&quot; : 15.25, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;   </span><br><span class="line">等价于：SELECT * FROM inventory WHERE status &#x3D; &quot;A&quot; AND ( qty &lt; 30 OR item LIKE &quot;p%&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="更新一条数据"><a href="#更新一条数据" class="headerlink" title="更新一条数据"></a>更新一条数据</h5><p>官方文档：<a href="https://docs.mongodb.com/manual/reference/update-methods/" target="_blank" rel="noopener">Update Methods</a>  </p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask入门</title>
    <url>/2020/03/12/Flask%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h5 id="一个最小的应用"><a href="#一个最小的应用" class="headerlink" title="一个最小的应用"></a>一个最小的应用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 Flask 类，该类的实例成为我们的 WSGI 应用</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Flask 类的实例。第一个参数是应用模块或者包的名称</span></span><br><span class="line"><span class="comment"># 若使用一个单一模块（就像本例），则使用 __name__</span></span><br><span class="line"><span class="comment"># 名称根据模块是按应用方式使用或作为模块导入而变化</span></span><br><span class="line"><span class="comment"># （可能是 '__main__' 或实际导入的名称）</span></span><br><span class="line"><span class="comment"># 此参数是必需的，这样 Flask 才知道在哪里能找到模板和静态文件等东西</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 route() 装饰器把函数绑定到 URL:</span></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, World'</span></span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/8myzWR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8myzWR.png" alt="8myzWR.png"></a></p>
<h5 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h5><p>通过把 URL 的一部分标记为 &#60;variable_name&#62; 就可以在 URL 中添加变量。标记的部分会作为关键字参数传递给函数。通过使用 &#60;converter:variable_name&#62; ，可以选择性的加上一个转换器，为变量指定规则。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/user/&lt;username&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_user_profile</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="comment"># show the user profile for that user</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'User &#123;&#125;'</span>.format(username)</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/8m6POK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8m6POK.png" alt="8m6POK.png"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/post/&lt;int:post_id&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_post</span><span class="params">(post_id)</span>:</span></span><br><span class="line">    <span class="comment"># show the post with the given id, the id is an integer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Post &#123;&#125;'</span>.format(post_id)</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/8m6Cy6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8m6Cy6.png" alt="8m6Cy6.png"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/path/&lt;path:subpath&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_subpath</span><span class="params">(subpath)</span>:</span></span><br><span class="line">    <span class="comment"># show the subpath after /path/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Subpath &#123;&#125;'</span>.format(subpath)</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/8myvFJ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8myvFJ.png" alt="8myvFJ.png"></a></p>
<h5 id="唯一的-URL-重定向行为"><a href="#唯一的-URL-重定向行为" class="headerlink" title="唯一的 URL / 重定向行为"></a>唯一的 URL / 重定向行为</h5><p>以下两条规则的不同之处在于是否使用尾部的斜杠。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/projects/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">projects</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'The project page'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/about')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">about</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'The about page'</span></span><br></pre></td></tr></table></figure>
<p>projects 的 URL 是中规中矩的，尾部有一个斜杠，如同文件夹。 访问一个没有斜杠结尾的 URL 时 Flask 会自动进行重定并尾部加上一个斜杠。</p>
<p>about 的 URL 没有尾部斜杠，与文件类似。如果访问这个 URL 时添加了尾部斜杠就会得到一个 404 错误。这样可以保持 URL 唯一，并帮助搜索引擎避免重复索引同一页面。<br><a href="https://imgchr.com/i/8m6R6x" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8m6R6x.png" alt="8m6R6x.png"></a></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">sting</td>
<td align="center">（缺省值） 接受任何不包含斜杠的文本</td>
</tr>
<tr>
<td align="left">int</td>
<td align="center">接受正整数</td>
</tr>
<tr>
<td align="left">float</td>
<td align="center">接受正浮点数</td>
</tr>
<tr>
<td align="left">path</td>
<td align="center">类似 string ，但可以包含斜杠</td>
</tr>
<tr>
<td align="left">uuid</td>
<td align="center">接受 UUID 字符串</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Python __name__</title>
    <url>/2020/03/12/%E5%85%B3%E4%BA%8EPython-name/</url>
    <content><![CDATA[<h5 id="关于-name"><a href="#关于-name" class="headerlink" title="关于 __ name__"></a>关于 __ <strong>name__</strong></h5><p>__ <strong>name__</strong> 属于 python 的内置类属性，它天生存在于一个 python 程序中，代表对应程序名称。  </p>
<p>比如下面的代码里面（app.py），当运行此代码时，这个代码的 <strong>name</strong> 的值为 <strong>main</strong> （一段程序作为主线运行程序时其内置名称就是 <strong>main</strong>）。  </p>
<p>文件夹目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">folder</span><br><span class="line">│</span><br><span class="line">└─── __init__.py</span><br><span class="line">│</span><br><span class="line">└─── app.py</span><br><span class="line">│</span><br><span class="line">└─── task_name.py</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(__name__)</span><br><span class="line">&gt;&gt;&gt;__main__</span><br></pre></td></tr></table></figure>
<p>当 app.py 作为模块被 (task_name.py) 调用时，则它的 <strong>name</strong> 就是它自己的名字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># task_name.py</span></span><br><span class="line"><span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line">print(app.__name__)</span><br><span class="line">&gt;&gt;&gt;app</span><br></pre></td></tr></table></figure>
<p>自己的 __ <strong>name__</strong> 在自己用时就是 main，当自己作为模块被调用时就是自己的名字。  </p>
<h5 id="实际项目的应用"><a href="#实际项目的应用" class="headerlink" title="实际项目的应用"></a>实际项目的应用</h5><p>如果在a.py里写了一个函数并且写了测试用例a_test， 运行a.py会显示测试用例a_test的结果。在b.py导入a并在b.py写了测试用例b_test，如果直接运行b.py会返回a_test和b_test的结果。显然a_test的结果不是我们想要的，我们只需要在b.py的b_test之前加上“if __ <strong>name__</strong> == __ <strong>name__</strong>:”，这样就不会返回a_test的结果了。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAlchemy的基本使用</title>
    <url>/2020/03/11/SQLAlchemy%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>数据库表是一个二维表，包含多行多列。用Python的数据结构表示表的数据，可以用一个list表示多行，list的每一个元素是tuple，表示一行记录，比如，包含id和name的user表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   (<span class="string">'1'</span>, <span class="string">'Michael'</span>),</span><br><span class="line">   (<span class="string">'2'</span>, <span class="string">'Bob'</span>),</span><br><span class="line">   (<span class="string">'3'</span>, <span class="string">'Adam'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Python的DB-API返回的数据结构如上所示。<br>但用tuple表示一行很难看出表的结构。如果把一个tuple用class实例来表示，就可以更容易地看出表的结构来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name)</span>:</span></span><br><span class="line">        self.id = id</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    User(<span class="string">'1'</span>, <span class="string">'Michael'</span>),</span><br><span class="line">    User(<span class="string">'2'</span>, <span class="string">'Bob'</span>),</span><br><span class="line">    User(<span class="string">'3'</span>, <span class="string">'Adam'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这就是ORM技术(Object-Relational Mapping)，把关系数据库的表结构映射到对象上。由ORM框架来做转换。<br>Python中最有名的ORM框架是SQLAlchemy。以下是SQLAlchemy的常用用法。   </p>
<h6 id="Install-SQLAlchemy-via-pip"><a href="#Install-SQLAlchemy-via-pip" class="headerlink" title="Install SQLAlchemy via pip:"></a>Install SQLAlchemy via pip:</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ pip install sqlalchemy</span><br></pre></td></tr></table></figure>
<h6 id="Version-Check"><a href="#Version-Check" class="headerlink" title="Version Check:"></a>Version Check:</h6><p>A quick check to verify that we are on at least version 1.3 of SQLAlchemy:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sqlalchemy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqlalchemy.__version__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.3</span><span class="number">.14</span></span><br></pre></td></tr></table></figure>
<h6 id="Connecting"><a href="#Connecting" class="headerlink" title="Connecting:"></a>Connecting:</h6><p>To connect we use create_engine():</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root : MySQL username</span></span><br><span class="line"><span class="comment"># mysql://root:(MySQL password, if the password is '', add nothing)</span></span><br><span class="line"><span class="comment"># news_test: the new defined database name</span></span><br><span class="line">engine = create_engine(<span class="string">'mysql://root:@localhost:3306/news_test?charset=utf8'</span>)</span><br></pre></td></tr></table></figure>
<p>The return value of create_engine() is an instance of Engine, and it represents the core interface to the database, adapted through a dialect that handles the details of the database and DBAPI in use. In this case the MySQL dialect will interpret instructions to the Python built-in MySQL module.</p>
<h6 id="Declare-a-Mapping"><a href="#Declare-a-Mapping" class="headerlink" title="Declare a Mapping:"></a>Declare a Mapping:</h6><p>When using the ORM, the configurational process starts by describing the database tables we’ll be dealing with, and then by defining our own classes which will be mapped to those tables. In modern SQLAlchemy, these two tasks are usually performed together, using a system known as Declarative, which allows us to create classes that include directives to describe the actual database table they will be mapped to.</p>
<p>Classes mapped using the Declarative system are defined in terms of a base class which maintains a catalog of classes and tables relative to that base - this is known as the declarative base class. Our application will usually have just one instance of this base in a commonly imported module. We create the base class using the declarative_base() function, as follows:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Base = declarative_base()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String, DateTime, Boolean</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">'mysql://root:@localhost:3306/news_test?charset=utf8'</span>)</span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">News</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"news"</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = Column(String(<span class="number">200</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    content = Column(String(<span class="number">2000</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    types = Column(String(<span class="number">10</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    image = Column(String(<span class="number">300</span>), )</span><br><span class="line">    author = Column(String(<span class="number">20</span>), )</span><br><span class="line">    view_count = Column(Integer)</span><br><span class="line">    created_at = Column(DateTime)</span><br><span class="line">    is_valid = Column(Boolean)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrmTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.session = Session()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        new_obj = News(</span><br><span class="line">            title=<span class="string">'标题'</span>,</span><br><span class="line">            content=<span class="string">'内容'</span>,</span><br><span class="line">            types=<span class="string">'百家'</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.session.add(new_obj)</span><br><span class="line">        self.session.commit()</span><br><span class="line">        <span class="keyword">return</span> new_obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""查询一条数据"""</span></span><br><span class="line">        <span class="keyword">return</span> self.session.query(News).get(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_more</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""查询多条数据"""</span></span><br><span class="line">        <span class="keyword">return</span> self.session.query(News).filter_by(is_valid=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_data</span><span class="params">(self, pk)</span>:</span></span><br><span class="line">        <span class="string">"""修改数据"""</span></span><br><span class="line">        new_obj = self.session.query(News).get(pk)</span><br><span class="line">        <span class="keyword">if</span> new_obj:</span><br><span class="line">            new_obj.is_valid = <span class="number">0</span></span><br><span class="line">            self.session.add(new_obj)</span><br><span class="line">            self.session.commit()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = OrmTest()</span><br><span class="line">    <span class="comment"># res = obj.add_one()</span></span><br><span class="line">    print(obj.update_data(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
</search>

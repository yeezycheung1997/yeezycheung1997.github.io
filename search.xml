<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis的持久化机制</title>
    <url>/2020/12/05/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/106997927" target="_blank" rel="noopener">Redis的持久化机制(RDB、AOF)</a></p>
<h2 id="1-为什么需要持久化？"><a href="#1-为什么需要持久化？" class="headerlink" title="1. 为什么需要持久化？"></a>1. 为什么需要持久化？</h2><p>Redis是内存数据库，数据存储在内存里。为了避免数据丢失，Redis提供了持久化机制：<strong>将存储在内存中的数据保存到磁盘中，一旦Redis服务器进程退出或运行Redis服务器的计算机停机导致数据丢失时，可以快速恢复之前Redis存储在内存中的数据。</strong></p>
<p>Redis提供了2种持久化方式：</p>
<ol>
<li><p>RDB持久化</p>
</li>
<li><p>AOF持久化</p>
</li>
</ol>
<h2 id="2-RDB持久化"><a href="#2-RDB持久化" class="headerlink" title="2. RDB持久化"></a>2. RDB持久化</h2><p>RDB持久化：将某个时间点Redis中的数据保存到RDB文件中：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-d477adb19e5dc7ca72211c25c8b368e1_720w.jpg" alt="img"></p>
<p>该文件是经过压缩的二进制文件，通过该文件可以还原生成RDB文件时Redis中的数据：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-483dda2e7139aafbe4c0c95cf1a8891e_720w.jpg" alt="img"></p>
<h3 id="2-1-创建RDB文件"><a href="#2-1-创建RDB文件" class="headerlink" title="2.1 创建RDB文件"></a>2.1 创建RDB文件</h3><p>Redis提供了2个命令创建RDB文件：<code>SAVE</code> 和 <code>BGSAVE</code>。</p>
<p><code>SAVE</code>命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止。在服务器进程阻塞期间，服务器不能处理任何命令请求：</p>
<p><img src="https://s3.ax1x.com/2020/12/09/r91eAJ.jpg" alt="img"></p>
<p><code>BGSAVE</code>命令会派生出一个子进程，由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-ff9360549e3991cc17df9accf286169b_720w.jpg" alt="img"></p>
<p>推荐使用BGSAVE命令，因为该命令可以不阻塞服务器进程。</p>
<p>除了手动执行上述两个命令，还可以配置Redis服务器配置文件的save选项，让服务器每隔一段时间自动执行一次<code>BGSAVE</code>命令。</p>
<p>save选项有多个保存条件，其中任意一个条件被满足，服务器就会执行<code>BGSAVE</code>命令。</p>
<p>save选项设置的默认条件：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-0aa8c6475ab870cc4aa5658ee1d6e9e5_720w.jpg" alt="img"></p>
<p>默认的配置条件：</p>
<ul>
<li>服务器在900s（15分钟）内，对数据库进行了至少1次修改</li>
<li>服务器在300s（5分钟）内，对数据库进行了至少10次修改</li>
<li>服务器在60s（1分钟）内，对数据库进行了至少10000次修改</li>
</ul>
<p>当满足条件执行BGSAVE命令时，输出日志如下图所示：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-b712556dc9ac6b31130eaf5fd10b7c50_720w.png" alt="img"></p>
<p>生成的RDB文件会根据Redis配置文件中的名称和路径来保存：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-c90e2e95bff1082447883877ab392699_720w.jpg" alt="img"></p>
<p>最终生成的RDB文件：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-a25615bcf3c99f850ee915644bf68487_720w.jpg" alt="img"></p>
<h3 id="2-2-载入RDB文件"><a href="#2-2-载入RDB文件" class="headerlink" title="2.2 载入RDB文件"></a>2.2 载入RDB文件</h3><p>载入RDB文件的目的是为了Redis服务器进程重启后还原之前存储在Redis中的数据。</p>
<p>Redis没有专门的命令载入RDB文件，Redis服务器启动时自动执行。</p>
<p>Redis服务器启动时是否会载入RDB文件取决于<strong>服务器是否启用了AOF持久化功能</strong>：</p>
<ol>
<li><p>如果AOF持久化功能关闭，服务器使用RDB文件还原数据。</p>
</li>
<li><p>如果AOF持久化功能开启，服务器优先使用AOF文件还原数据。</p>
</li>
</ol>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-02846b978a016f3888191ac4c2a55dd0_720w.jpg" alt="img"></p>
<p>默认情况下，AOF持久化功能是关闭的，所以Redis服务器在启动时会载入RDB文件，</p>
<p>启动日志如下：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-b50e388e533e68935ca61a53713fd0cf_720w.jpg" alt="img"></p>
<h3 id="2-3-服务器状态"><a href="#2-3-服务器状态" class="headerlink" title="2.3 服务器状态"></a>2.3 服务器状态</h3><p>创建和载入RDB文件，服务器可能存在的状态有以下3种：</p>
<ol>
<li><p>执行<code>SAVE</code>命令，Redis服务器被阻塞。此时客户端发送的所有命令请求都被阻塞。只有服务器执行完<code>SAVE</code>命令后，客户端发送的命令请求才会被处理。</p>
</li>
<li><p>执行<code>BGSAVE</code>命令，Redis服务器不被阻塞，Redis服务器可以继续处理客户端发送的命令请求。</p>
</li>
<li><p>服务器在载入RDB文件期间，一直处于阻塞状态直到RDB文件载入成功。</p>
</li>
</ol>
<h2 id="3-AOF持久化"><a href="#3-AOF持久化" class="headerlink" title="3. AOF持久化"></a>3. AOF持久化</h2><p>AOF持久化是<strong>通过保存Redis服务器执行的写命令来记录数据库数据的</strong>。</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-420d66c1596a1271dc3b7426d32b496e_720w.jpg" alt="img"></p>
<p>默认情况下，AOF持久化功能是关闭的。可以修改下图所示的配置打开：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-7a2641ac6682b6064331f1595d869779_720w.jpg" alt="img"></p>
<p>假设Redis中未存储任何数据，执行如下命令：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-66ada753cd94512c3e498bc4ddc1ca1b_720w.jpg" alt="img"></p>
<p>生成了<code>appendonly.aof</code>的文件。</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-cb937b6b6c1aa4e98083c6dfd3fd7a29_720w.jpg" alt="img"></p>
<p>打开该文件，可以看到上面执行的3个写命令都存储在该文件中：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-19c21104282b30f01baf0bcd47c167a7_720w.jpg" alt="img"></p>
<h3 id="3-1-AOF持久化的实现"><a href="#3-1-AOF持久化的实现" class="headerlink" title="3.1 AOF持久化的实现"></a>3.1 AOF持久化的实现</h3><p>当开启了AOF持久化功能，Redis服务器在执行完一个写命令后，会以协议格式（如上面截图中AOF文件里保存写命令的格式）将被执行的写命令追加到服务器状态的AOF缓冲区的末尾。Redis服务器根据配置文件中<code>appendfsync</code>选项决定何时将AOF缓冲区中的内容写入和同步到AOF文件里。</p>
<p>appendfsync选项有以下3个值：</p>
<ol>
<li><p>always：</p>
<ul>
<li><p>安全性：最安全（丢失数据最少）。即使出现故障停机，数据库只会丢失一个事件循环中所产生的命令数据。</p>
</li>
<li><p>效率：效率最慢。服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并同步AOF文件。</p>
</li>
</ul>
</li>
<li><p>everysec：</p>
<ul>
<li><p>安全性：即使出现故障停机，数据库只会丢失一秒钟的命令数据。</p>
</li>
<li><p>效率：快，因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行同步。</p>
</li>
</ul>
</li>
<li><p>no：</p>
<ul>
<li><p>安全性：如果出现故障停机，数据库会丢失上次同步AOF文件之后的所有写命令数据，具有不确定性。因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。</p>
</li>
<li><p>效率：everysec模式的效率差不多。</p>
</li>
</ul>
</li>
</ol>
<p>appendfsync选项的默认值是everysec，保证了效率和安全性。</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-c16dbb5154ad5a9daf8913171be4630a_720w.jpg" alt="img"></p>
<h3 id="3-2-载入AOF文件"><a href="#3-2-载入AOF文件" class="headerlink" title="3.2 载入AOF文件"></a>3.2 载入AOF文件</h3><p>AOF文件包含了重建数据库所需的所有写命令，所以Redis服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就能还原Redis服务器关闭之前的数据。</p>
<p>Redis读取AOF文件并还原数据库的详细步骤如下：</p>
<ol>
<li><p>创建一个不带网络连接的伪客户端：<br>Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令。<br>伪客户端执行命令的效果等同于带网络连接的客户端。</p>
</li>
<li><p>从AOF文件中分析并读取出一条写命令。</p>
</li>
<li><p>使用伪客户端执行被读取出的写命令。</p>
</li>
<li><p>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被执行完毕。</p>
</li>
</ol>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-499981ec15682b4316a2d1bc3a944d34_720w.jpg" alt="img"></p>
<p>如果开启了AOF持久化功能，那么Redis服务器在启动时会载入AOF文件：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-8e7f6c21345e673bb7f1914b6fc1cbac_720w.jpg" alt="img"></p>
<h3 id="3-3-AOF重写"><a href="#3-3-AOF重写" class="headerlink" title="3.3 AOF重写"></a>3.3 AOF重写</h3><p>AOF持久化是通过保存被执行的写命令来记录数据库数据的，随着Redis服务器运行时间的增加，AOF文件中的内容会越来越多，文件的体积会越来越大。如果不做控制，会有以下坏处：</p>
<ol>
<li><p>过多的占用服务器磁盘空间，对Redis服务器造成影响。</p>
</li>
<li><p>AOF文件的体积越大，使用AOF文件来还原数据库所需的时间就越多。</p>
</li>
</ol>
<p>举个例子，在客户端执行如下命令：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-84b8800abe3224d21f4cd8fcf9229561_720w.jpg" alt="img"></p>
<p>为了记录这个list的状态，AOF文件要保存上面执行的6条命令。</p>
<p>为了解决AOF文件体积变大的问题，Redis提供了AOF文件重写功能：Redis服务器会创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库数据相同，但新AOF文件不包含任何浪费空间的冗余命令，所以新AOF文件的体积比旧AOF文件的体积小很多。</p>
<h3 id="3-3-1-AOF重写的实现原理"><a href="#3-3-1-AOF重写的实现原理" class="headerlink" title="3.3.1 AOF重写的实现原理"></a>3.3.1 AOF重写的实现原理</h3><p>AOF文件重写无需对现有的AOF文件进行任何读取、分析或写入操作，而是通过读取服务器当前的数据库数据来实现的。</p>
<p>以上面的list为例，旧的AOF文件保存了6条命令来记录list的状态。但list的结果是“C” “D” “E” “F” “G”这样的数据，所以AOF文件重写时，用一条<code>RPUSH list “C” &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot;</code>命令代替之前的六条命令，将保存list所需的命令从六条减少为一条。</p>
<p>如果Redis服务器存储的键值对足够多，AOF文件重写生成的新AOF文件会减少很多的冗余命令，大大减小了AOF文件的体积。</p>
<p><strong>AOF文件重写功能的实现原理：首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。</strong></p>
<h3 id="3-3-2-AOF后台重写"><a href="#3-3-2-AOF后台重写" class="headerlink" title="3.3.2 AOF后台重写"></a>3.3.2 AOF后台重写</h3><p>因为AOF文件重写会进行大量的文件写入操作，所以执行这个操作的线程将被长时间阻塞。</p>
<p>Redis服务器使用单线程处理命令请求，如果由服务器进程直接执行该操作，那么在重写AOF文件期间，服务器将无法处理客户端发送过来的命令请求。</p>
<p>为了避免上述问题，Redis将AOF文件重写功能放到子进程里执行，这样做有以下2个好处：</p>
<ol>
<li><p>子进程进行AOF文件重写期间，服务器进程（父进程）可以继续处理命令请求。</p>
</li>
<li><p>子进程带有服务器进程的数据副本，使用子进程而不是线程。在避免使用锁的情况下，保证数据的安全性。</p>
</li>
</ol>
<p>AOF后台重写的步骤如下所示：</p>
<ol>
<li><p>服务器进程创建子进程，子进程开始AOF文件重写</p>
</li>
<li><p>从创建子进程开始，服务器进程执行的所有写命令不仅要写入AOF缓冲区，还要写入AOF重写缓冲区。</p>
<p>写入AOF缓冲区的目的是为了同步到原有的AOF文件。</p>
<p>写入AOF重写缓冲区的目的是因为子进程在进行AOF文件重写期间，服务器进程还在继续处理命令请求，<br>而新的命令可能会对现有的数据库进行修改，从而使得服务器当前的数据库数据和重写后的AOF文件所保存的数据库数据不一致。</p>
</li>
<li><p>子进程完成AOF重写工作，向父进程发送信号，父进程接收该信号后，会执行以下操作：</p>
<ol>
<li><p>将AOF重写缓冲区中的所有内容写入新AOF文件中，保证了新AOF文件保存的数据和服务器数据库当前的数据一致。</p>
</li>
<li><p>将新的AOF文件覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p>
</li>
</ol>
</li>
</ol>
<p>Redis提供了<code>BGREWRITEAOF</code>命令来执行以上步骤：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-991242e17d16e01e97b8be28a9b55ae4_720w.png" alt="img"></p>
<p>执行完成后，打开appendonly.aof文件，发现保存list的命令从六条变为了一条：</p>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-533dd929ac693841cc5a638145e763ee_720w.jpg" alt="img"></p>
<p>除了手动执行<code>BGREWRITEAOF</code>命令外，Redis还提供了2个配置项用来自动执行<code>BGREWRITEAOF</code>命令：</p>
<blockquote>
<p>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb</p>
</blockquote>
<p><img src="/D:/%E5%8D%9A%E5%AE%A2%E7%B4%A0%E6%9D%90/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/v2-b258c3322723f2d407793b05472d4f4e_720w.jpg" alt="img"></p>
<p>该配置表示，当AOF文件的体积大于64MB，并且AOF文件的体积比上一次重写之后的体积大了至少一倍（100%），Redis将自动执行<code>BGREWRITEAOF</code>命令。</p>
<h2 id="4-RDB持久化、AOF持久化的区别"><a href="#4-RDB持久化、AOF持久化的区别" class="headerlink" title="4. RDB持久化、AOF持久化的区别"></a>4. RDB持久化、AOF持久化的区别</h2><p>Redis提供的2种持久化方法的区别可以总结为以下4点：</p>
<h3 id="4-1-实现方式"><a href="#4-1-实现方式" class="headerlink" title="4.1 实现方式"></a>4.1 实现方式</h3><p>RDB持久化是通过将某个时间点Redis服务器存储的数据保存到RDB文件中来实现持久化的。</p>
<p>AOF持久化是通过将Redis服务器执行的所有写命令保存到AOF文件中来实现持久化的。</p>
<h3 id="4-2-文件体积"><a href="#4-2-文件体积" class="headerlink" title="4.2 文件体积"></a>4.2 文件体积</h3><p>RDB记录结果，AOF记录过程。AOF持久化生成的AOF文件会有体积越来越大的问题，Redis提供了AOF重写功能来减小AOF文件体积。</p>
<h3 id="4-3-安全性"><a href="#4-3-安全性" class="headerlink" title="4.3 安全性"></a>4.3 安全性</h3><p>AOF持久化的安全性要比RDB持久化的安全性高。如果机器故障，AOF持久化比RDB持久化丢失的数据少。</p>
<p>因为RDB持久化会丢失上次RDB持久化后写入的数据，而AOF持久化最多丢失1s之内写入的数据（使用默认everysec配置的话）。</p>
<h3 id="4-4-优先级"><a href="#4-4-优先级" class="headerlink" title="4.4 优先级"></a>4.4 优先级</h3><p>如果开启了AOF持久化功能，Redis服务器在启动时会使用AOF文件来还原数据，如果未开启AOF持久化功能，Redis服务器在启动时会使用RDB文件还原数据，所以AOF文件的优先级更高。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言关于interface的问题</title>
    <url>/2020/12/01/Go%E8%AF%AD%E8%A8%80%E5%85%B3%E4%BA%8Einterface%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/63649977" target="_blank" rel="noopener">Stefno：深度解密Go语言之关于 interface 的10个问题</a></p>
<h4 id="1-Go-语言与鸭子类型的关系"><a href="#1-Go-语言与鸭子类型的关系" class="headerlink" title="1. Go 语言与鸭子类型的关系"></a>1. Go 语言与鸭子类型的关系</h4><blockquote>
<p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p>
</blockquote>
<p><code>Duck Typing</code>，鸭子类型，是动态语言的一种对象推断策略。它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过接口的方式完美支持鸭子类型。</p>
<p>在python 中定义一个这样的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(coder)</span>:</span></span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure>
<p>当调用此函数时，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。若未实现，运行过程中则报错。</p>
<p>在静态语言如 Java, C++ 中，必须要显示地声明实现了哪个接口，之后才能用在任何需要该接口的地方。如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。</p>
<p>静态语言在编译期间就能发现类型不匹配的错误，而动态语言必须要运行到那一行代码才会报错。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型。在某种程度上加大了工作量，也加长了代码量。动态语言则没有这些要求，让人更专注在业务上，代码更短，写得更快。</p>
<p>Go 语言它引入了动态语言的便利，同时又会进行静态语言的类型检查。Go 采用了折中的做法：<strong>不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</strong></p>
<p>举个例子：</p>
<p>先定义一个接口，和使用此接口作为参数的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IGreeting <span class="keyword">interface</span> &#123;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(i IGreeting)</span></span> &#123;</span><br><span class="line">    i.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义两个结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Go <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Go)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hi, I am GO!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PHP <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHP)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hi, I am PHP!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在 main 函数里调用 sayHello() 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    golang := Go&#123;&#125;</span><br><span class="line">    php := PHP&#123;&#125;</span><br><span class="line"></span><br><span class="line">    sayHello(golang)</span><br><span class="line">    sayHello(php)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi, I am GO!</span><br><span class="line">Hi, I am PHP!</span><br></pre></td></tr></table></figure>
<p>在 main 函数中，调用 sayHello() 函数时，传入了 <code>golang, php</code> 对象，它们没有显式地声明实现了 IGreeting 类型，只实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</p>
<p>动态语言的特点：</p>
<blockquote>
<p>变量绑定的类型是不确定的，在运行期间才能确定函数和方法可以接收任何类型的参数，且调用时不检查参数类型,不需要实现接口</p>
</blockquote>
<p>鸭子类型是动态语言的风格，在该风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了鸭子类型，实际上是 Go 的编译器作了隐匿的转换工作。</p>
<h4 id="2-值接收者和指针接收者的区别"><a href="#2-值接收者和指针接收者的区别" class="headerlink" title="2. 值接收者和指针接收者的区别"></a>2. 值接收者和指针接收者的区别</h4><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p><strong>方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，添加了接收者的函数就变成了方法。接收者可以是值接收者或指针接收者。</strong></p>
<p><strong>在调用方法时，值类型既能调用<code>值接收者</code>的方法，也能调用<code>指针接收者</code>的方法；指针类型既能调用<code>指针接收者</code>的方法，也能<code>调用值接收者</code>的方法。也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</strong></p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">howOld</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// qcrao 是值类型</span></span><br><span class="line">    qcrao := Person&#123;age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值类型 调用接收者也是值类型的方法</span></span><br><span class="line">    fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值类型 调用接收者是指针类型的方法</span></span><br><span class="line">    qcrao.growUp()</span><br><span class="line">    fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// stefno 是指针类型</span></span><br><span class="line">    stefno := &amp;Person&#123;age: <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针类型 调用接收者是值类型的方法</span></span><br><span class="line">    fmt.Println(stefno.howOld())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针类型 调用接收者也是指针类型的方法</span></span><br><span class="line">    stefno.growUp()</span><br><span class="line">    fmt.Println(stefno.howOld())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br><span class="line">19</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td></tr></table></figure>
<p>调用了 <code>growUp</code> 函数后，不管调用者是值类型还是指针类型，它的 <code>Age</code> 值都改变了。</p>
<p>实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：</p>
<p><img src="https://pic4.zhimg.com/80/v2-f4033f68d3268ef5ff56fce81458e2ef_720w.jpg" alt="img"></p>
<h5 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h5><p>不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这实际上是通过语法糖起作用的。</p>
<p>先说结论：</p>
<ul>
<li><p>实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法</p>
</li>
<li><p>实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</p>
</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">    code()</span><br><span class="line">    debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">    language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"I am coding %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"I am debuging %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c coder = &amp;Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">    c.code()</span><br><span class="line">    c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个接口 coder，接口定义了两个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code()</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>
<p>定义了一个结构体 <code>Gopher</code>，它实现了两个方法：值接收者 <code>code()</code>，指针接收者 <code>debug()</code>。</p>
<p>在 main 函数里通过接口类型的变量调用了定义的两个函数。</p>
<p>运行一下，结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am coding Go language</span><br><span class="line">I am debuging Go language</span><br></pre></td></tr></table></figure>
<p>但是如果我们把 main 函数的第一条语句换一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c coder = Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">    c.code()</span><br><span class="line">    c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;main.go:23:6: cannot use Gopher literal (type Gopher) as type coder in assignment:</span><br><span class="line">    Programmer does not implement coder (debug method has pointer receive</span><br></pre></td></tr></table></figure>
<p>两处代码的区别是第一次将 <code>&amp;Gopher</code> 赋给了 <code>coder</code>；第二次将 <code>Gopher</code> 赋给了 <code>coder</code>。</p>
<p>第二次报错是说，<code>Gopher</code> 没有实现 <code>coder</code>。因为 <code>Gopher</code> 类型没有实现 <code>debug</code> 方法；表面上看， <code>*Gopher</code> 类型也没有实现 <code>code</code> 方法，但是因为 <code>Gopher</code> 类型实现了 <code>code</code> 方法，所以让 <code>*Gopher</code> 类型自动拥有了 <code>code</code> 方法。</p>
<p>上面的说法有一个简单的解释：</p>
<ul>
<li><p>接收者是指针类型的方法，很可能在方法中对接收者的属性产生更改，从而影响接收者</p>
</li>
<li><p>接收者是值类型的方法，在方法中不会对接收者本身产生影响</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li><p>当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都是值类型的方法，不影响接收者。</p>
</li>
<li><p>当实现了一个接收者是指针类型的方法，如果也自动生成一个接收者是值类型的方法，原本希望对接收者的改变（通过指针实现）则无法实现。因为值类型会产生一个拷贝，不会真正影响调用者。</p>
</li>
<li><p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</p>
</li>
</ul>
<h5 id="两者分别在何时使用"><a href="#两者分别在何时使用" class="headerlink" title="两者分别在何时使用"></a>两者分别在何时使用</h5><ul>
<li><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者</p>
</li>
<li><p>如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p>
</li>
</ul>
<p>使用指针作为方法的接收者的理由：</p>
<ul>
<li><p>方法能够修改接收者指向的值</p>
</li>
<li><p>避免在每次调用方法时复制该值。如果值的类型是大型结构体，这样会更高效</p>
</li>
</ul>
<p>是使用值接收者还是指针接收者，不是由该方法是否修改了接收者来决定，而应该基于该类型的<code>本质</code>。</p>
<p>如果类型具备“原始的本质”，该类型的成员都是 Go 的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像引用类型如 slice，map，interface，channel，声明这些类型时，实际上创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。</p>
<p>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。(去看《Go 语言实战》5.3 那一节。)</p>
<h4 id="3-iface-和-eface-的区别"><a href="#3-iface-和-eface-的区别" class="headerlink" title="3. iface 和 eface 的区别"></a>3. iface 和 eface 的区别</h4><p>iface 和 eface 是 Go 中描述接口的底层结构体：</p>
<ul>
<li><p>iface 描述的接口包含方法</p>
</li>
<li><p>eface 是不包含任何方法的空接口：<code>interface{}</code></p>
</li>
</ul>
<p>源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter  *interfacetype</span><br><span class="line">    _type  *_type</span><br><span class="line">    link   *itab</span><br><span class="line">    hash   <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">    bad    <span class="keyword">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">    inhash <span class="keyword">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">    unused [<span class="number">2</span>]<span class="keyword">byte</span></span><br><span class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iface 内部维护两个指针：</p>
<ul>
<li><p>tab 指向一个 itab 实体，它表示接口的类型以及赋给这个接口的实体类型</p>
</li>
<li><p>data 指向接口具体的值，一般而言是一个指向堆内存的指针</p>
</li>
</ul>
<p>itab 结构体中，<code>_type</code> 字段描述了实体的类型，包括内存对齐方式，大小等；inter 字段则描述了接口的类型。fun 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</p>
<p>为什么 fun 数组的大小为 1，要是接口定义了多个方法怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。这些方法是按照函数名称的字典序进行排列的。</p>
<p>再看一下 interfacetype 类型，它描述的是接口的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ     _type</span><br><span class="line">    pkgpath name</span><br><span class="line">    mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_type 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 mhdr 字段，表示接口所定义的函数列表， pkgpath 记录定义了接口的包名。</p>
<p>这里通过一张图来看下 iface 结构体的全貌：<br><img src="https://pic4.zhimg.com/80/v2-bc0aa5b14afe88a8e689eb6d84647e1f_720w.jpg" alt="img"></p>
<p>eface 的源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比 iface，eface 就很简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值。</p>
<p><img src="https://pic2.zhimg.com/80/v2-5a60802192a5be81a5ba1f83aad34dfd_720w.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程（新）</title>
    <url>/2020/10/13/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%88%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/158965214" target="_blank" rel="noopener">小林coding：进程、线程基础知识全家桶，30 张图一套带走</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-173719595a7e633939679ec099470920_720w.jpg" alt="img"></p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>代码是一个存储在硬盘的静态文件，编译代码会生成二进制可执行文件。当可执行文件运行后，它被装载到内存中，CPU 执行程序中的每一条指令。这个运行中的程序就是进程。</p>
<p>假设有一个读取硬盘文件数据的程序被执行了，当运行到读取文件的指令时，会去从硬盘读取数据。但硬盘的读写速度非常慢，如果此时 CPU 傻傻地等硬盘返回数据的话，那 CPU 的利用率极低。</p>
<p>当进程从硬盘读取数据时，CPU 不需要阻塞等待数据的返回，而是去执行别的进程。当硬盘数据返回时，CPU 收到中断，再继续运行这个进程。</p>
<p><img src="https://pic1.zhimg.com/80/v2-0e15e9b8bd206b6ac79749661fd005dc_720w.jpg" alt="img"></p>
<p>这种<strong>多个程序、交替执行</strong>的思想，就是 CPU 管理多个进程的初步想法。</p>
<p>一个支持多进程的系统，CPU 会从当前进程快速切换至新进程，每个进程各运行几十或几百毫秒。</p>
<p>单核的 CPU 在某一瞬间只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生并行的错觉，实际上这是并发。</p>
<h5 id="并发和并行有什么区别？"><a href="#并发和并行有什么区别？" class="headerlink" title="并发和并行有什么区别？"></a>并发和并行有什么区别？</h5><p><img src="https://pic2.zhimg.com/80/v2-22ab0d940d620da72daea688a298475d_720w.jpg" alt="img"></p>
<h5 id="进程与程序的关系的类比"><a href="#进程与程序的关系的类比" class="headerlink" title="进程与程序的关系的类比"></a>进程与程序的关系的类比</h5><p>晚饭时间，一对情侣饿了。男生在网上找了菜谱，买了鸡肉、辣椒、香料等材料，然后边看菜谱边学边做菜。</p>
<p><img src="https://pic1.zhimg.com/80/v2-a7b1f905d6ad3a2c3b1cd5de042a54c4_720w.jpg" alt="img"></p>
<p>突然，女生说想喝可乐，男生只好暂停做菜，并在菜谱上标记做到哪一步骤，记录状态信息。</p>
<p>然后男生听从女生的指令买了一瓶可乐，回到厨房继续做菜。</p>
<p><strong>CPU 从当前进程（做菜）切换到新进程（买可乐），在切换前必须要记录当前进程中运行的状态信息，以备下次切换回来的时候能恢复执行。</strong></p>
<p>所以进程有着<strong>运行 - 暂停 - 运行</strong>的活动规律。</p>
<h5 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h5><p>进程有着<strong>运行 - 暂停 - 运行</strong>的活动规律。<strong>一个进程不是自始至终连续不停地运行，它与并发执行中的其他进程的执行相互制约。</strong></p>
<p>它有时处于运行状态；有时由于某种原因暂停运行处于等待状态；当使它暂停的原因消失后，它又进入准备运行状态。</p>
<p>所以，<strong>进程至少具备三种基本状态：运行状态、就绪状态、阻塞状态</strong>。</p>
<p><img src="https://pic4.zhimg.com/80/v2-6e581c27d56c5df1f98bec8521d2b14b_720w.jpg" alt="img"></p>
<ul>
<li>运行状态（Runing）：该时刻进程占用 CPU</li>
<li>就绪状态（Ready）：有运行的条件，但因为其他进程正在运行而暂时耽搁运行</li>
<li>阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行。此时即使给它 CPU 控制权，它也无法运行</li>
</ul>
<p>进程另外两个基本状态：</p>
<ul>
<li>创建状态（new）：进程正在被创建时的状态</li>
<li>结束状态（Exit）：进程正在从系统中消失时的状态</li>
</ul>
<p>一个完整的进程状态的变迁：</p>
<p><img src="https://pic4.zhimg.com/80/v2-18c3b8aa5a26209dea6abcfebc27198b_720w.jpg" alt="img"></p>
<ul>
<li><p>NULL -&gt; 创建状态：新进程被创建时的第一个状态</p>
</li>
<li><p>创建状态 -&gt; 就绪状态：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态</p>
</li>
<li><p>就绪状态 -&gt; 运行状态：处于就绪状态的进程被操作系统的进程调度器选中后，分配给 CPU 并运行该进程</p>
</li>
<li><p>运行状态 -&gt; 结束状态：当进程已经运行完成或出错时，会被操作系统作结束状态处理</p>
</li>
<li><p>运行状态 -&gt; 就绪状态：处于运行状态的进程在运行过程中，由于运行的时间片用完，操作系统把该进程变为就绪状态，并从就绪状态选一个新的进程运行</p>
</li>
<li><p>运行状态 -&gt; 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I/O 事件</p>
</li>
<li><p>阻塞状态 -&gt; 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态</p>
</li>
</ul>
<p>如果有大量处于阻塞状态的进程，进程会占用有限的物理内存空间，这是一种浪费物理内存的行为。所以，通常把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行时，再从硬盘换入到物理内存。</p>
<p><img src="https://pic3.zhimg.com/80/v2-4e60d744e3f29eb62a3c42682d4c1b86_720w.jpg" alt="img"></p>
<p>这样就需要一个新的状态，来<strong>描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。</strong></p>
<p>另外，挂起状态可以分为两种：</p>
<ul>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</li>
</ul>
<p>这两种挂起状态加上前面的五种状态，就变成了七种状态变迁：</p>
<p><img src="https://pic4.zhimg.com/80/v2-5d20327a5305f347bb76a3c571f43b33_720w.jpg" alt="img"></p>
<p>导致进程挂起的原因不只是因为进程使用的内存空间不在物理内存，还包括：</p>
<ul>
<li>通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。</li>
<li>用户希望挂起一个程序的执行，比如在 Linux 中用 Ctrl+Z 挂起进程。</li>
</ul>
<h5 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h5><p>进程控制块（process control block，PCB）是用来描述进程的。<strong>PCB 是进程存在的唯一标识。一个进程的存在，必然会有一个 PCB，如果进程消失那么 PCB 也会随之消失</strong>。</p>
<h5 id="PCB-包含什么信息呢？"><a href="#PCB-包含什么信息呢？" class="headerlink" title="PCB 包含什么信息呢？"></a>PCB 包含什么信息呢？</h5><h6 id="进程描述信息："><a href="#进程描述信息：" class="headerlink" title="进程描述信息："></a>进程描述信息：</h6><ul>
<li>进程标识符：标识各个进程，每个进程有且只有一个唯一的标识符</li>
<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务</li>
</ul>
<h6 id="进程控制和管理信息："><a href="#进程控制和管理信息：" class="headerlink" title="进程控制和管理信息："></a>进程控制和管理信息：</h6><ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等</li>
<li>进程优先级：进程抢占 CPU 时的优先级</li>
</ul>
<h6 id="资源分配清单："><a href="#资源分配清单：" class="headerlink" title="资源分配清单："></a>资源分配清单：</h6><ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</li>
</ul>
<h6 id="CPU-相关信息："><a href="#CPU-相关信息：" class="headerlink" title="CPU 相关信息："></a>CPU 相关信息：</h6><ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li>
</ul>
<h5 id="各个-PCB-是如何组织的呢？"><a href="#各个-PCB-是如何组织的呢？" class="headerlink" title="各个 PCB 是如何组织的呢？"></a>各个 PCB 是如何组织的呢？</h5><p>各个 PCB 通常通过链表组织，把具有相同状态的进程链在一起，组成各种队列。比如：</p>
<ul>
<li>将所有处于就绪状态的进程链在一起，称为就绪队列。</li>
<li>把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列。</li>
</ul>
<p>对于运行队列在单核 CPU 系统中只有一个运行指针，因为单核 CPU 在某个时间，只能运行一个程序。</p>
<p>那么，就绪队列和阻塞队列链表的组织形式如下图：</p>
<p><img src="https://pic3.zhimg.com/80/v2-52bef604640dac2e7975a4ff0efe4d5a_720w.jpg" alt="img"></p>
<p>除了链表的组织方式，还有索引方式：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。</p>
<p>一般会选择链表，因为进程创建，销毁等调度会导致进程状态发生变化，链表能够更加灵活地插入和删除。</p>
<h5 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h5><p>熟知了进程的状态变迁和进程的 PCB 后，再来看看进程的创建、终止、阻塞、唤醒的过程，也就是进程的控制。</p>
<h6 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h6><p>操作系统允许进程创建子进程，允许子进程继承父进程所拥有的资源。当子进程被终止时，其在父进程继承的资源应当还给父进程。终止父进程的同时也会终止其所有的子进程。</p>
<p>创建进程的过程如下：</p>
<ul>
<li>为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB。PCB 是有限的，若申请失败则创建失败</li>
<li>为进程分配资源，此时如果资源不足，进程进入等待状态，以等待资源</li>
<li>初始化 PCB</li>
<li>如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行</li>
</ul>
<h6 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h6><p>进程有 3 种终止方式：正常结束、异常结束以及外界干预（信号 kill 掉）。</p>
<p>终止进程的过程如下：</p>
<ul>
<li>查找需要终止的进程的 PCB</li>
<li>如果处于运行状态，则立即终止该进程的运行，并将 CPU 分配给其他进程</li>
<li>如果其还有子进程，将其所有子进程终止</li>
<li>将该进程所拥有的全部资源都归还给父进程或操作系统</li>
<li>将其从 PCB 所在队列中删除</li>
</ul>
<h6 id="阻塞进程"><a href="#阻塞进程" class="headerlink" title="阻塞进程"></a>阻塞进程</h6><p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。</p>
<p>阻塞进程的过程如下：</p>
<ul>
<li>查找需要被阻塞进程标识号对应的 PCB</li>
<li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行</li>
<li>将该 PCB 插入的阻塞队列中去</li>
</ul>
<h6 id="唤醒进程"><a href="#唤醒进程" class="headerlink" title="唤醒进程"></a>唤醒进程</h6><p>进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。</p>
<p>如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。</p>
<p>唤醒进程的过程如下：</p>
<ul>
<li>在该事件的阻塞队列中找到相应进程的 PCB</li>
<li>将其从阻塞队列中移出，并置其状态为就绪状态</li>
<li>把该 PCB 插入到就绪队列中，等待调度程序调度</li>
</ul>
<p>进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。</p>
<h5 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h5><p>各个进程之间是共享 CPU 资源，进程之间需要切换，让不同的进程在 CPU 执行。当前进程切换到新进程运行，称为进程的上下文切换。</p>
<h6 id="CPU-上下文切换"><a href="#CPU-上下文切换" class="headerlink" title="CPU 上下文切换"></a>CPU 上下文切换</h6><p>大多数操作系统都是多任务，通常支持大于 CPU 数量的任务同时运行。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在 CPU 运行，造成了同时运行的错觉。</p>
<p>任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。</p>
<p>所以，操作系统需要帮 CPU 设置好 <strong>CPU 寄存器和程序计数器</strong>。</p>
<p>CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）。程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。</p>
<p>所以说，CPU 寄存器和程序计数器是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。</p>
<p>CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
<p>系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p>
<p>上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。</p>
<p>进程的上下文切换到底是切换什么呢？<br>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p>
<p>所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p>
<p>通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9cbca9f3c903c3bbfdaf330e95bf2835_720w.jpg" alt="img"></p>
<p>大家需要注意，进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。</p>
<p>发生进程上下文切换有哪些场景？</p>
<ul>
<li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li>
<li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；</li>
<li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；<br>以上，就是发生进程上下文切换的常见场景了。</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的三大调度机制</title>
    <url>/2020/10/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%89%E5%A4%A7%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/225162322" target="_blank" rel="noopener">小林coding：大厂面试爱问的「调度算法」，20 张图一举拿下</a></p>
<p>操作系统的三大调度机制：</p>
<ul>
<li>进程调度算法</li>
<li>页面置换算法</li>
<li>磁盘调度算法</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-71def7ed00e38e93b6508fa38d73f427_720w.jpg" alt="img"></p>
<h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><p>进程调度算法也称 CPU 调度算法，因为 CPU 调度进程。</p>
<p>当 CPU 空闲时，操作系统就选择内存中的某个就绪状态的进程，分配给 CPU。</p>
<h5 id="何时发生-CPU-调度呢？"><a href="#何时发生-CPU-调度呢？" class="headerlink" title="何时发生 CPU 调度呢？"></a>何时发生 CPU 调度呢？</h5><ol>
<li>进程从运行状态 -&gt; 等待状态 「非抢占式调度」</li>
<li>进程从运行状态 -&gt; 就绪状态 「抢占式调度」</li>
<li>进程从等待状态 -&gt; 就绪状态 「抢占式调度」</li>
<li>进程从运行状态 -&gt; 终止状态 「非抢占式调度」</li>
</ol>
<p><strong>非抢占式调度：当进程正在运行时，它会一直运行，直到该进程完成或发生某个事件而被阻塞时，进程进入等待或终止状态，把 CPU 让给其他进程。</strong></p>
<p><strong>抢占式调度：当进程正在运行时，可以被打断，进程进入就绪状态，把 CPU 让给其他进程。</strong></p>
<p>抢占的原则有三种：时间片原则、优先权原则、短作业优先原则。</p>
<h5 id="为什么第-3-种情况会发生-CPU-调度呢？"><a href="#为什么第-3-种情况会发生-CPU-调度呢？" class="headerlink" title="为什么第 3 种情况会发生 CPU 调度呢？"></a>为什么第 3 种情况会发生 CPU 调度呢？</h5><p>假设有一个进程处于等待状态，它的优先级较高。如果该进程等待的事件发生了，它会转到就绪状态，如果调度算法是以优先级进行的，那么该进程会立刻抢占正在运行的进程，发生了 CPU 调度。</p>
<p>第 2 种状态通常是时间片到的情况，因为时间片到了会发生中断，就绪进程会抢占正在运行的进程，占用 CPU。</p>
<p>调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不影响进程使用 CPU 的时间和 I/O 时间。</p>
<p>常见的调度算法：</p>
<ul>
<li>先来先服务调度算法</li>
<li>最短作业优先调度算法</li>
<li>高响应比优先调度算法</li>
<li>时间片轮转调度算法</li>
<li>最高优先级调度算法</li>
<li>多级反馈队列调度算法</li>
</ul>
<h5 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h5><p>最简单的调度算法：<strong>非抢占式的先来先服务（First Come First Severd, FCFS）算法</strong>。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7a0a41db8d07c20ada29e37c15e412e6_720w.jpg" alt="img"></p>
<p>先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</p>
<p>但如果一个长作业先运行，那么后面的短作业等待的时间就会很长，不利于短作业。因此FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，不适用于 I/O 繁忙型作业的系统。</p>
<h5 id="最短作业优先调度算法"><a href="#最短作业优先调度算法" class="headerlink" title="最短作业优先调度算法"></a>最短作业优先调度算法</h5><p>最短作业优先（Shortest Job First, SJF）：<strong>优先选择运行时间最短的进程运行，有助于提高系统的吞吐量</strong>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-aade0ab1b10cbdbc5722e7964fee9a29_720w.jpg" alt="img"></p>
<p>这显然对长作业不利，容易造成一种极端现象：一个长作业在就绪队列等待运行，但就绪队列有非常多的短作业，会使得长作业不断地往后推，等待时间变长，长作业长期不会被运行。</p>
<h5 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h5><p>「先来先服务调度算法」和「最短作业优先调度算法」都没有很好地权衡短作业和长作业。高响应比优先 （Highest Response Ratio Next, HRRN）调度算法权衡了短作业和长作业。</p>
<p>每次进行进程调度时，先计算「响应比优先级」，再把「响应比优先级」最高的进程投入运行，「响应比优先级」的计算公式：</p>
<p><img src="https://pic1.zhimg.com/80/v2-34f27ca9e98f60450061d689f11dabc0_720w.jpg" alt="img"></p>
<p>从上面的公式可知：</p>
<ul>
<li>如果两个进程的「等待时间」相同时，「要求服务时间」越短，「响应比」就越高，这样短作业进程容易被选中运行。</li>
<li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这兼顾了长作业进程。进程的响应比随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会。</li>
</ul>
<h5 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h5><p>最古老、最简单、最公平且使用最广的算法：时间片轮转（Round Robin, RR）调度算法。</p>
<p><img src="https://pic2.zhimg.com/80/v2-05b95be53f47428ca6f5f8ab0b313b49_720w.jpg" alt="img"></p>
<p><strong>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。</strong></p>
<ul>
<li>如果时间片用完，进程还在运行，当前进程从 CPU 释放出来，CPU 分配给新进程。</li>
<li>如果当前进程在时间片结束前阻塞或结束，CPU 立即切换新进程。</li>
</ul>
<p>时间片的长度很关键：</p>
<ul>
<li>时间片太短会导致过多的进程上下文切换，降低 CPU 效率。</li>
<li>时间片太长会引起短作业进程的响应时间变长。通常时间片设为 20ms~50ms 这是一个比较合理的折中值。</li>
</ul>
<h5 id="最高优先级调度算法"><a href="#最高优先级调度算法" class="headerlink" title="最高优先级调度算法"></a>最高优先级调度算法</h5><p>时间片轮转算法假设所有的进程同等重要，各个进程运行的时间都一样。</p>
<p>但是，多用户计算机系统希望调度是有优先级的，即调度程序能<strong>从就绪队列中选择最高优先级的进程来运行，称为最高优先级（Highest Priority First，HPF）调度算法</strong>。</p>
<p>进程的优先级分为静态优先级和动态优先级：</p>
<ul>
<li>静态优先级：创建进程时就已经确定了优先级，整个运行时间优先级都不变。</li>
<li>动态优先级：根据进程的动态变化调整优先级。比如进程运行时间增加，则降低其优先级；进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。</li>
</ul>
<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
<p>但缺点是可能导致低优先级的进程永远不会运行。</p>
<h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>多级反馈队列（Multilevel Feedback Queue）调度算法是时间片轮转算法和最高优先级算法的综合和发展。</p>
<p>顾名思义：</p>
<ul>
<li>「多级」表示有多个队列，每个队列优先级从高到低、优先级越高时间片越短。</li>
<li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-5ea155d8d6eb0f1d48afd347b5c7cc2f_720w.jpg" alt="img"></p>
<p>通过上图可知：</p>
<ul>
<li>设置了多个队列，每个队列有不同的优先级，每个队列优先级从高到低，优先级越高时间片越短。</li>
<li>新进程被放入第一级队列的末尾，按先来先服务的原则排队等待调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成。</li>
<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行。</li>
</ul>
<p>可以发现，短作业可能在第一级队列被处理完。对于长作业，如果在第一级队列处理不完，就移入下一级队列等待被执行，虽然等待的时间变长了，但是运行时间（时间片）也更长了，该算法很好地兼顾了长短作业，同时有较好的响应时间。</p>
<h4 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h4><p>在了解内存页面置换算法前，先了解一下<strong>缺页异常（缺页中断）</strong>。</p>
<p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。</p>
<p>缺页中断与一般中断的区别：</p>
<ul>
<li>缺页中断在指令执行「期间」产生和处理中断信号；一般中断在一条指令执行「完成」后检查和处理中断信号。</li>
<li>缺页中断返回到该指令的开始重新执行「该指令」；一般中断返回到该指令的「下一个指令」执行。</li>
</ul>
<p>缺页中断的处理流程：</p>
<p><img src="https://pic2.zhimg.com/80/v2-91fbe24a235aeb687d4cc4f119909c39_720w.jpg" alt="img"></p>
<p>1.CPU 访问一条 Load M 指令，然后 CPU 去找 M 对应的页表项。<br>2.如果该页表项的状态位是「有效的」，CPU 就直接访问物理内存。如果状态位是「无效的」，CPU 会发送缺页中断请求。<br>3.操作系统收到了缺页中断，执行缺页中断处理函数，去查找该页面在磁盘中的位置。<br>4.找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但在换入前需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。<br>5.页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。<br>6.最后，CPU 重新执行导致缺页异常的指令。</p>
<p>上面过程的第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？</p>
<p>找不到空闲页的话，就说明此时内存已满。需要页面置换算法选择一个物理页，如果该物理页被修改过（<a href="https://baike.baidu.com/item/%E8%84%8F%E9%A1%B5" target="_blank" rel="noopener">脏页</a>），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到该物理页中。</p>
<p>页表项通常有如下字段：</p>
<p><img src="https://pic3.zhimg.com/80/v2-2e3da8116c767b7c758d51ff4c51b75e_720w.png" alt="img"></p>
<ul>
<li>状态位：表示该页是否有效，是否在物理内存中，供程序访问时参考。</li>
<li>访问字段：记录该页在一段时间内被访问的次数，供页面置换算法选择出页面时参考。</li>
<li><strong>修改位：表示该页在调入内存后是否被修改过，由于内存中的每一页都在磁盘上保留一份副本。未被修改的话在置换该页时就无需将该页写回到磁盘上，以减少系统的开销；被修改的话则将该页重写到磁盘上，保证磁盘中保留的始终是最新的副本。</strong></li>
<li>硬盘地址：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。</li>
</ul>
<p>虚拟内存的管理流程：</p>
<p><img src="https://pic4.zhimg.com/80/v2-e5642bb6598acdfbf480271bcefab293_720w.jpg" alt="img"></p>
<p><strong>页面置换算法的功能是当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面。也就是说选择一个物理页面换出到磁盘，再把需要访问的页面换入到物理页。</strong></p>
<p>其算法目标是尽可能减少页面的换入换出的次数，常见的页面置换算法有：</p>
<ul>
<li>最佳页面置换算法（OPT）</li>
<li>先进先出置换算法（FIFO）</li>
<li>最近最久未使用的置换算法（LRU）</li>
<li>时钟页面置换算法（Lock）</li>
<li>最不常用置换算法（LFU）</li>
</ul>
<h5 id="最佳页面置换算法"><a href="#最佳页面置换算法" class="headerlink" title="最佳页面置换算法"></a>最佳页面置换算法</h5><p>最佳页面置换算法基本思路是<strong>置换在「未来」最长时间不访问的页面</strong>。</p>
<p>该算法计算内存中每个逻辑页面的「下一次」访问时间，然后比较选择未来最长时间不访问的页面。</p>
<p>假如一开始有 3 个空闲的物理页，然后有请求的页面序列，那它的置换过程如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-258a887fb00a2fa2fc51b86198ad8497_720w.jpg" alt="img"></p>
<p>在这个请求的页面序列中，缺页共发生了 7 次（空闲页换入 3 次 + 最优页面置换 4 次），页面置换共发生了 4 次。</p>
<p>这很理想，但实际上无法实现，因为程序访问页面是动态的，我们无法预知每个页面在「下一次」访问前的等待时间。</p>
<p>所以，<strong>最佳页面置换算法作用是为了衡量某算法的效率，某算法效率越接近该算法的效率，就说明某算法高效。</strong></p>
<h5 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h5><p>既然我们无法预知页面在下一次访问前所需的等待时间，那就可以<strong>选择在内存驻留时间很长的页面进行置换</strong>，这就是先进先出置换的思想。</p>
<p>还是以前面的请求的页面序列为例，假设使用先进先出置换算法，过程如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-d86110332f4ba13790b294071b76d83a_720w.jpg" alt="img"></p>
<p>在这个请求的页面序列中，缺页共发生了 10 次，页面置换共发生了 7 次，比最佳页面置换算法性能差了很多。</p>
<h5 id="最近最久未使用的置换算法"><a href="#最近最久未使用的置换算法" class="headerlink" title="最近最久未使用的置换算法"></a>最近最久未使用的置换算法</h5><p>最近最久未使用（LRU）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间未被访问的页面进行置换</strong>。该算法假设已经很久未使用的页面很有可能在未来较长的一段时间内仍未被使用。</p>
<p>该算法近似最优置换算法：</p>
<ul>
<li>最优置换算法是通过「未来」的使用情况推测要淘汰的页面</li>
<li>LRU 则是通过「历史」的使用情况推测要淘汰的页面</li>
</ul>
<p>还是以前面的请求的页面序列为例，假设使用最近最久未使用的置换算法，过程如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-c06e25b31d6398bf29fa7ae2674c1904_720w.jpg" alt="img"></p>
<p>在这个请求的页面序列中，缺页共发生了 9 次，页面置换共发生了 6 次，跟先进先出置换算法比较起来，性能提高了一些。</p>
<p>LRU 在理论上可以实现，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。</p>
<p>困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</p>
<p>LRU 看上去不错，但由于开销较大，实际应用中较少使用。</p>
<h5 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h5><p>有没有一种即能优化置换的次数，也能方便实现的算法呢？</p>
<p>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</p>
<p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>
<p>当发生缺页中断时，算法首先检查表针指向的页面：</p>
<p>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；<br>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；<br>我画了一副时钟页面置换算法的工作流程图，你可以在下方看到：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4e6860bff8332933b7b622cf66732858_720w.jpg" alt="img"></p>
<h5 id="最不常用算法（LFU）"><a href="#最不常用算法（LFU）" class="headerlink" title="最不常用算法（LFU）"></a>最不常用算法（LFU）</h5><p><strong>当发生缺页中断时，选择「访问次数」最少的那个页面，将其淘汰。</strong></p>
<p>该算法对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</p>
<p>看似简单，每个页面加一个计数器就能实现，但我们需要考虑效率和硬件成本。</p>
<p>增加一个计数器的硬件成本较高，另外通过计数器查找哪个页面访问次数最小，就要查找链表。如果链表很长，查找非常耗时，效率不高。</p>
<p>LFU 算法只考虑了频率问题，没考虑时间问题。有些页面在很久之前访问频率很高，但最近已经没有访问了；而当前频繁访问的页面由于没有那些页面访问的次数高，在发生缺页中断时，就有可能误伤当前刚开始频繁访问，但访问次数还不高的页面。</p>
<p>该问题的解决办法是定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2。也就是说随着时间的流失，以前访问次数高的页面会慢慢减少，加大了被置换的概率。</p>
<h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p>磁盘调度算法为了提高磁盘的访问性能，一般通过优化磁盘的访问请求顺序来做到的。</p>
<p>寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化得当，可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p>
<p>假设有下面一个请求序列，每个数字代表磁道的位置：</p>
<p>98，183，37，122，14，124，65，67</p>
<p>初始磁头当前的位置是在第 53 磁道。</p>
<p>接下来分别对以上序列，举每个调度算法的例子，常见的磁盘调度算法有：</p>
<ul>
<li>先来先服务算法</li>
<li>最短寻道时间优先算法</li>
<li>扫描算法算法</li>
<li>循环扫描算法</li>
<li>LOOK 与 C-LOOK 算法</li>
</ul>
<h5 id="先来先服务（First-Come，First-Served，FCFS）"><a href="#先来先服务（First-Come，First-Served，FCFS）" class="headerlink" title="先来先服务（First-Come，First-Served，FCFS）"></a>先来先服务（First-Come，First-Served，FCFS）</h5><p>磁盘的写入顺序是从左到右，如下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d92b24929b94f84efa7df372f5be6773_720w.jpg" alt="img"></p>
<p>先来先服务算法总共移动了 640 个磁道的距离。该算法简单粗暴，但如果有大量进程竞争使用磁盘，请求访问的磁道会很分散，因此该算法在性能上很差，因为寻道时间过长。</p>
<h5 id="最短寻道时间优先（Shortest-Seek-First，SSF）"><a href="#最短寻道时间优先（Shortest-Seek-First，SSF）" class="headerlink" title="最短寻道时间优先（Shortest Seek First，SSF）"></a>最短寻道时间优先（Shortest Seek First，SSF）</h5><p>该算法的工作方式是优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：</p>
<p>98，183，37，122，14，124，65，67</p>
<p>根据距离磁头（53 位置）最近的请求的算法，具体的请求会是下列从左到右的顺序：</p>
<p>65，67，37，14，98，122，124，183</p>
<p><img src="https://pic4.zhimg.com/80/v2-50aa5594db8476fbbed4fe25ae7bd2f3_720w.jpg" alt="img"></p>
<p>磁头移动的总距离是 236 磁道，相比先来先服务性能提高了不少。</p>
<p>但该算法可能存在某些请求的饥饿，因为本次例子是静态的序列，看不出问题。假设是一个动态的请求，如果后续的请求都是小于 183<br>磁道的，那么 183 磁道可能永远不会被响应，产生了饥饿现象。产生饥饿的原因是磁头在一小块区域来回移动。</p>
<h5 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h5><p>最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回得移动。</p>
<p>为了防止这个问题，可以规定：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（Scan）算法。</p>
<p>这种算法也叫做电梯算法，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p>
<p>还是以这个序列为例子，磁头的初始位置是 53：</p>
<p>98，183，37，122，14，124，65，67</p>
<p>那么，假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：</p>
<p>37，14，0，65，67，98，122，124，183</p>
<p><img src="https://pic4.zhimg.com/80/v2-9dd22790bd0160466562ee50a0e3d853_720w.jpg" alt="img"></p>
<p>磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。</p>
<p>扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题，中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。</p>
<h5 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h5><p>扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。</p>
<p>循环扫描（Circular Scan, CSCAN ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应一个方向上的请求。</p>
<p>还是以这个序列为例子，磁头的初始位置是 53：</p>
<p>98，183，37，122，14，124，65，67</p>
<p>那么，假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：</p>
<p>65，67，98，122，124，183，199，0，14，37</p>
<p><img src="https://pic3.zhimg.com/80/v2-3d438d8a18c81a75ee4ace4786c49472_720w.jpg" alt="img"></p>
<p>磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。</p>
<p>循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。</p>
<h5 id="LOOK-与-C-LOOK算法"><a href="#LOOK-与-C-LOOK算法" class="headerlink" title="LOOK 与 C-LOOK算法"></a>LOOK 与 C-LOOK算法</h5><p>我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。</p>
<p>那这其实是可以优化的，优化的思路就是磁头在移动到「最远的请求」位置，然后立即反向移动。</p>
<p>那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，反向移动的途中会响应请求。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a920d723af7f8028ffb5e116346a0c39_720w.jpg" alt="img"></p>
<p>而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，反向移动的途中不会响应请求。</p>
<p><img src="https://pic1.zhimg.com/80/v2-fea446b2b43b51275522d6618438c450_720w.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2020/10/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/152119007" target="_blank" rel="noopener">小林coding：20 张图揭开「内存管理」的迷雾，瞬间豁然开朗</a><br><img src="https://pic3.zhimg.com/80/v2-17857eed4afe8203d471208c54d18da2_720w.jpg" alt="img"></p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>单片机没有操作系统。写完代码后需要借助工具把程序烧录进去，这样程序才能运行。<strong>单片机的 CPU 直接操作内存的物理地址。</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-99f53df4663bd8130e9c529da2a7fadb_720w.png" alt="img"></p>
<p>在这种情况下，不可能同时在内存中运行两个程序：如果第一个程序在 2000 的位置写一个新值，将会擦掉第二个程序存放在相同位置上的内容。所以同时运行两个程序是不行的，两个程序会立刻崩溃。</p>
<blockquote>
<p>操作系统如何解决这个问题呢？</p>
</blockquote>
<p>问题的关键是这两个程序都<strong>直接使用了物理地址</strong>，这是需要避免的。</p>
<p>我们可以把进程使用的地址隔离开，让操作系统为每个进程分配独立的<strong>虚拟地址</strong>，进程之间互不干涉。每个进程都不能直接访问物理地址，至于虚拟地址如何映射到物理地址，对进程来说是透明的，操作系统已经把这些都安排地明明白白了。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a6853c9afcc3d551c8bf43913c9f1485_720w.png" alt="img"></p>
<p><strong>操作系统提供一种机制，将不同进程的虚拟地址映射到对应内存的物理地址。</strong></p>
<p>程序访问虚拟地址时，由操作系统转换成对应的物理地址。这样不同的进程运行时，写入的是不同的物理地址，这样就不会冲突了。</p>
<p>地址的概念：</p>
<ul>
<li>程序使用的内存地址：<strong>虚拟内存地址</strong>（Virtual Memory Address）</li>
<li>实际存在硬件里的空间地址：<strong>物理内存地址</strong>（Physical Memory Address）。</li>
</ul>
<p><strong>操作系统引入了虚拟内存地址，进程持有的虚拟内存地址通过 CPU 芯片中的内存管理单元（MMU）的映射关系，转换成物理内存地址，再通过物理内存地址访问内存</strong>：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0204ff048148735a260fa5f94f475f14_720w.jpg" alt="img"></p>
<blockquote>
<p>操作系统如何管理虚拟地址与物理地址之间的关系呢？</p>
</blockquote>
<p>主要有两种方式：<strong>内存分段和内存分页</strong>。</p>
<h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><p>程序是由若干个逻辑分段组成的，比如代码分段、数据分段、栈段、堆段等。<strong>不同的段有不同的属性，用分段（Segmentation）的形式把这些段分离出来。</strong></p>
<h5 id="分段机制下，虚拟地址和物理地址是如何映射的呢？"><a href="#分段机制下，虚拟地址和物理地址是如何映射的呢？" class="headerlink" title="分段机制下，虚拟地址和物理地址是如何映射的呢？"></a>分段机制下，虚拟地址和物理地址是如何映射的呢？</h5><p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子和段内偏移量</strong>。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.jpg" alt="img"></p>
<ul>
<li><strong>段选择因子</strong> 保存在段寄存器里面。段选择因子内最重要的是<strong>段号</strong>，段号是段表的索引。段表保存的是<strong>段基地址、段界限和特权级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p><strong>虚拟地址是通过段表映射到物理地址的</strong>。分段机制把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段基地址，再加上偏移量，就能找到物理内存中的地址：</p>
<p><img src="https://pic2.zhimg.com/80/v2-5b9da31991bbd5cc4de28843eea611e5_720w.jpg" alt="img"></p>
<p>如果要访问段 3 中偏移量 500 的虚拟地址，可以计算出物理地址为段 3 基地址 7000 + 偏移量 500 = 7500。</p>
<p>分段使得程序本身无需关心具体的物理内存地址，但它也有两点不足：<strong>内存碎片和内存交换的效率低</strong>。</p>
<h5 id="分段为什么会产生内存碎片？"><a href="#分段为什么会产生内存碎片？" class="headerlink" title="分段为什么会产生内存碎片？"></a>分段为什么会产生内存碎片？</h5><p>假设有 1G 的物理内存，用户执行了多个程序，其中：</p>
<ul>
<li>游戏占用了 512MB 内存</li>
<li>浏览器占用了 128MB 内存</li>
<li>音乐占用了 256 MB 内存。</li>
</ul>
<p>如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。</p>
<p>如果这个 256MB 内存不是连续的，被分成了两段 128 MB 内存，这会导致没有空间再打开一个 200MB 的程序。</p>
<p><img src="https://pic3.zhimg.com/80/v2-1d41ca6712224fc7ee0226875c59336a_720w.jpg" alt="img"></p>
<p>这里的内存碎片分成了两点：</p>
<ul>
<li>外部内存碎片：产生了多个不连续的小的物理内存，导致新的程序无法被装载。</li>
<li>内部内存碎片：<strong>程序所有的内存都被装载到了物理内存，但是程序有的部分的内存可能不经常使用，会导致内存浪费。</strong></li>
</ul>
<p>针对上面两种内存碎片的问题，解决的方式有所不同。</p>
<p>解决外部内存碎片的问题就是<strong>内存交换</strong>。</p>
<p>把音乐程序占用的 256MB 内存写到硬盘上，再从硬盘上读回到内存里。读回时不再装载回原来的位置，而是紧跟着那已经被占用的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以被装载进来。</p>
<p><strong>内存交换空间在 Linux 系统里就是 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</strong></p>
<h5 id="分段为什么会导致内存交换效率低？"><a href="#分段为什么会导致内存交换效率低？" class="headerlink" title="分段为什么会导致内存交换效率低？"></a>分段为什么会导致内存交换效率低？</h5><p><strong>分段容易产生内存碎片。产生了内存碎片就得进行内存交换，在这个过程中会导致性能瓶颈。因为硬盘的访问速度比内存慢，每一次内存交换都需要把一大段连续的内存数据写到硬盘上。如果内存交换的是一个占很大内存空间的程序，机器会显得卡顿。</strong></p>
<p>为了解决内存分段的内存碎片和内存交换效率低的问题，出现了内存分页。</p>
<h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p><strong>分段能产生连续的内存空间，但也会出现内存碎片和内存交换的空间太大导致性能低下。</strong></p>
<p>要解决这些问题，就要想出能少出现内存碎片的办法。并且当进行内存交换时，让需要交换写入或从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法就是<strong>内存分页</strong>（Paging）。</p>
<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间叫<strong>页</strong>（Page）。Linux 下的每一页大小为 4KB。</p>
<p>虚拟地址通过页表映射到物理地址：</p>
<p><img src="https://pic3.zhimg.com/80/v2-e63c20d1bace757600fccb051a29eaf6_720w.jpg" alt="img"></p>
<p><strong>页表存储在 CPU 的内存管理单元 （MMU） 中，CPU 直接通过 MMU 找出物理内存地址。</strong></p>
<p>当进程访问的虚拟地址在页表中查不到时，系统会产生<strong>缺页异常</strong>并进入系统内核空间分配物理内存、更新进程的页表，最后返回用户空间，恢复进程的运行。</p>
<h5 id="分页是怎么解决分段的内存碎片、内存交换效率低的问题？"><a href="#分页是怎么解决分段的内存碎片、内存交换效率低的问题？" class="headerlink" title="分页是怎么解决分段的内存碎片、内存交换效率低的问题？"></a>分页是怎么解决分段的内存碎片、内存交换效率低的问题？</h5><p>由于内存空间是预先划分好的，不像分段那样产生间隙非常小的内存，这正是分段产生内存碎片的原因。而<strong>采用了分页，释放的内存是以页为单位的，不产生无法给进程使用的小内存。</strong></p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的<strong>最近没被使用</strong>的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要时再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或几个页，不会花太多时间，内存交换效率较高。</p>
<p><img src="https://pic2.zhimg.com/80/v2-23f19a580a47fa6c731b32d7df6b6735_720w.jpg" alt="img"></p>
<p>分页使得操作系统在加载程序时，无需一次性地把全部程序加载到物理内存中。完全可以在虚拟内存映射物理内存后，<strong>在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<h5 id="分页机制下，虚拟地址和物理地址是如何映射的？"><a href="#分页机制下，虚拟地址和物理地址是如何映射的？" class="headerlink" title="分页机制下，虚拟地址和物理地址是如何映射的？"></a>分页机制下，虚拟地址和物理地址是如何映射的？</h5><p><strong>在分页机制下，虚拟地址分为两部分：页号和页内偏移</strong>。页号是页表的索引，页表包含物理页每页所在物理内存的基地址。基地址与页内偏移的组合形成了物理内存地址：</p>
<p><img src="https://pic1.zhimg.com/80/v2-f81afcda08a62df36ae13be04b0ea020_720w.jpg" alt="img"></p>
<p>分页下的内存地址转换：</p>
<ul>
<li>把虚拟内存地址切分成页号和偏移量</li>
<li>通过页号在页表里查询对应的物理页号</li>
<li>物理页号 + 偏移量 = 物理内存地址</li>
</ul>
<p>虚拟内存中的页通过页表映射到了物理内存中的页：</p>
<p><img src="https://pic4.zhimg.com/80/v2-5754bb50732be0b04b934e57325f321f_720w.jpg" alt="img"></p>
<p>但在实际的操作系统，这种简单的分页是有问题的。</p>
<h5 id="简单的分页有什么缺陷吗？"><a href="#简单的分页有什么缺陷吗？" class="headerlink" title="简单的分页有什么缺陷吗？"></a>简单的分页有什么缺陷吗？</h5><p>简单的分页有空间上的缺陷。因为操作系统能同时运行很多进程，意味着页表会非常的庞大。</p>
<p>在 32 位环境下，虚拟地址空间有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个页表项占用4 字节，那么整个 4GB 空间的映射就需要 4MB 的内存存储页表。</p>
<p>4MB 的页表看起来不是很大。但每个进程都有自己的虚拟地址空间，也就说都有自己的页表。那么100 个进程就需要 400MB 的内存来存储页表，这是非常大的内存了。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>要解决上面的问题，就需要采用<strong>多级页表</strong>（Multi-Level Page Table）。</p>
<p>对于单页表，在 32 位系统和页大小 4KB 的环境下，一个进程的页表要装下 100 多万个页表项，并且每个页表项占用 4 字节，页表需占用 4MB 的空间。</p>
<p>我们把这 100 多万个页表项的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。如下所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d93943bf4f4fbed708f751c5303f8d6f_720w.jpg" alt="img"></p>
<h5 id="分了二级表，映射-4GB-地址空间就需要-4KB（一级页表）-4MB（二级页表）的内存，这样占用空间不是更大了吗？"><a href="#分了二级表，映射-4GB-地址空间就需要-4KB（一级页表）-4MB（二级页表）的内存，这样占用空间不是更大了吗？" class="headerlink" title="分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？"></a>分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？</h5><p>当然如果 4GB 的虚拟地址全都映射到了物理内存上的话，二级分页占用空间确实是更大了，但一个进程不会分配那么多的内存。</p>
<p>每个进程都有 4GB 的虚拟地址空间，大多数程序使用到的空间远未达到 4GB，因此存在部分对应的页表项是空的，根本没有分配。对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，不会占用物理内存。</p>
<p>如果使用了二级分页，一级页表可以覆盖整个 4GB 虚拟地址空间，<strong>如果某个一级页表的页表项未被用到，就无需创建该页表项对应的二级页表了，即在需要时才创建二级页表</strong>。</p>
<p>假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，相比单级页表的 4MB 节省大量内存空间。</p>
<p>为什么不分级的单页表浪费内存呢？从页表的性质来看，保存在内存中的页表的作用是将虚拟地址映射成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作。所以页表一定要覆盖全部虚拟地址空间，不分级的页表需要 100 多万个页表项来映射，而多级页表的一级页表（1024个页表项）就覆盖到了全部虚拟地址空间，二级页表在需要时创建。</p>
<p>我们把二级分页再推广到多级页表，会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。</p>
<p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录：</p>
<ul>
<li>全局页目录项 PGD（Page Global Directory）</li>
<li>上层页目录项 PUD（Page Upper Directory）</li>
<li>中间页目录项 PMD（Page Middle Directory）</li>
<li>页表项 PTE（Page Table Entry）</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-efcd8bc82e0bd3f7528d6bdeee665cf7_720w.jpg" alt="img"></p>
<h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，降低了地址映射的速度，带来了时间上的开销。</p>
<p>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p>
<p><img src="https://pic2.zhimg.com/80/v2-243cbcc3ce0c1658529e0179e48601a9_720w.jpg" alt="img"></p>
<p>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是 CPU 加入了一个专门存放程序最常访问的页表项的 Cache：TLB（Translation Lookaside Buffer） ，称为页表缓存、转址旁路缓存、快表等。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e01b9f0b2d128f23e6ad9e0f612710a5_720w.jpg" alt="img"></p>
<p>CPU 封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。</p>
<p>有了 TLB 后，CPU 在寻址时会先查 TLB，如果没找到才会继续查常规的页表。</p>
<p>TLB 的命中率很高，因为程序最常访问的页就那么几个。</p>
<h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><p>内存分段和内存分页通常在系统中组合使用，称为<strong>段页式内存管理</strong>。</p>
<p><img src="https://pic4.zhimg.com/80/v2-1940088ec468b81069bcd6d94046366b_720w.jpg" alt="img"></p>
<p>段页式内存管理实现的方式：</p>
<ul>
<li>先将程序划分为多个有逻辑意义的段（分段机制）</li>
<li>再把每个段划分为多个页，对分段划分出来的连续空间，再划分固定大小的页</li>
</ul>
<p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p>
<p>段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，页表中的地址是某页的物理页号：</p>
<p><img src="https://pic1.zhimg.com/80/v2-975920d028e58f620ca84125c1b211f4_720w.jpg" alt="img"></p>
<p>段页式地址变换中要得到物理地址须经过三次内存访问：</p>
<ul>
<li>第一次访问段表，得到页表起始地址；</li>
<li>第二次访问页表，得到物理页号；</li>
<li>第三次将物理页号与页内位移组合，得到物理地址。</li>
</ul>
<h4 id="Linux-内存管理"><a href="#Linux-内存管理" class="headerlink" title="Linux 内存管理"></a>Linux 内存管理</h4><h5 id="Linux-采用了哪种方式来管理内存呢？"><a href="#Linux-采用了哪种方式来管理内存呢？" class="headerlink" title="Linux 采用了哪种方式来管理内存呢？"></a>Linux 采用了哪种方式来管理内存呢？</h5><p>早期 Intel 的处理器从 80286 开始使用的是段式内存管理。但很快发现只有段式内存管理是不够的。因此在之后的 80386 中就实现了页式内存管理。</p>
<p>但 80386 的页式内存管理设计是建立在段式内存管理的基础上，这就意味着，页式内存管理的作用是在由段式内存管理所映射而成的地址上再加上一层地址映射。</p>
<p>此时由段式内存管理映射的地址不是物理地址了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，再由页式内存管理将线性地址映射成物理地址。</p>
<p><img src="https://pic1.zhimg.com/80/v2-e1eb85934efd49edd9f17990b24ca6cc_720w.png" alt="img"></p>
<p>逻辑地址和线性地址：</p>
<ul>
<li>逻辑地址：程序使用的地址，未被段式内存管理映射的地址</li>
<li>线性地址：段式内存管理映射后的地址，也叫虚拟地址</li>
</ul>
<p>逻辑地址是段式内存管理转换前的地址，线性地址则是页式内存管理转换前的地址。</p>
<p><strong>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。</strong></p>
<p>这主要是 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。</p>
<p>事实上Linux 内核所采取的办法是使段式映射的过程实际上不起作用。Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），<strong>所有段的起始地址都一样</strong>。这意味着Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</p>
<h5 id="Linux-的虚拟地址空间是如何分布的？"><a href="#Linux-的虚拟地址空间是如何分布的？" class="headerlink" title="Linux 的虚拟地址空间是如何分布的？"></a>Linux 的虚拟地址空间是如何分布的？</h5><p>在 Linux 操作系统中，虚拟地址空间被分为内核空间和用户空间，不同位数的系统，地址空间的范围也不同：</p>
<p><img src="https://pic1.zhimg.com/80/v2-c9d252523365fc5584a9553a402816c4_720w.jpg" alt="img"></p>
<p>通过这里可以看出：</p>
<ul>
<li>32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间</li>
<li>64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</li>
</ul>
<h5 id="内核空间与用户空间的区别："><a href="#内核空间与用户空间的区别：" class="headerlink" title="内核空间与用户空间的区别："></a>内核空间与用户空间的区别：</h5><ul>
<li>进程在用户态时，只能访问用户空间内存</li>
<li>只有进入内核态后，才能访问内核空间的内存</li>
</ul>
<p>每个进程都各自有独立的虚拟内存，但每个虚拟内存中的内核地址关联的都是相同的物理内存。这样，进程切换到内核态后，就能很方便地访问内核空间内存。</p>
<p><img src="https://pic1.zhimg.com/80/v2-e36d096c3eed8dca3e82a6a9f73a454c_720w.jpg" alt="img"></p>
<p>看一下用户空间分布的情况，以 32 位系统为例：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a4c01da530e342cccd2d178d33f0e16a_720w.jpg" alt="img"></p>
<p>用户空间内存，从低到高分别是 7 种不同的内存段：</p>
<ul>
<li>程序文件段，包括二进制可执行代码</li>
<li>已初始化数据段，包括静态常量</li>
<li>未初始化数据段，包括未初始化的静态变量</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。系统也提供了参数，以便自定义大小</li>
</ul>
<p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>多进程环境下，各个进程间的内存地址相互隔离互不影响，操作系统为每个进程独立分配一套虚拟地址空间，每个程序只需关心自己的虚拟地址，实际上大家的虚拟地址都一样，但映射到不同的物理地址内存。程序无需关心物理地址的事情。</p>
<p>每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存会很紧张，于是操作系统通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要时再装载回物理内存（换入）。</p>
<p>虚拟地址与物理地址的映射关系，有分段和分页的方式，两者结合也可以。</p>
<p>内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但每个段的大小不等，会导致内存碎片和内存交换效率低的问题。</p>
<p>于是就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，在 Linux 系统中，每一页的大小为 4KB。分了页就不会产生细小的内存碎片。同时在内存交换时，写入硬盘也就一个页或几个页，大大提高了内存交换效率。</p>
<p>为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但会导致 CPU 在寻址过程中，有很多层表的参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。</p>
<p>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。</p>
<p>Linxu 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的通信方式</title>
    <url>/2020/10/09/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/165224175" target="_blank" rel="noopener">小林coding：张三同学没答好「进程间通信」，被面试官挂了….</a></p>
<p><img src="https://pic2.zhimg.com/80/v2-44491054270a8418b6049c1018d08605_720w.jpg" alt="img"></p>
<blockquote>
<p>每个进程的用户空间都是独立的，一般不能互相访问。<strong>但每个进程都共享内核空间，所以进程间通信必须要通过内核。</strong></p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-e36d096c3eed8dca3e82a6a9f73a454c_720w.jpg" alt="img"></p>
<p>Linux 内核提供了几种进程间通信的机制：</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>举例：<code>netstat -tulnp | grep 8080</code></p>
<p>“ | ”是管道，作用是把前一条命令的输出作为后一条命令的输入。<strong>管道传输数据是单向的</strong>，相互通信要创 建两个管道。</p>
<p>在这里就是把 <code>netstat -tulnp</code> 的输出结果作为 <code>grep 8080</code> 的输入。  </p>
<p>因为这条竖线没有名字，所以这种通信方式称为<strong>匿名管道</strong>，用完即销毁。</p>
<p>另一种管道是命名管道（FIFO），因为数据是先进先出的传输方式：</p>
<p>举例：<code>mkfifo  test</code>（创建了一个名为 <code>test</code> 的命名管道）</p>
<p>接下来用一个进程向该管道写数据，用另一个进程把里面的数据读出来：<br><code>echo &quot;this is a pipe&quot; &gt; test   // 写数据</code></p>
<p>如果管道的内容未被读出，那么<code>echo</code>命令会一直阻塞，只有当另一进程把管道的内容读出时<code>echo</code>命令才会结束：<br><code>cat test  // 读数据</code>  </p>
<p>读取线程的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost 桌面]# cat &lt; test</span><br><span class="line">this is a pipe</span><br></pre></td></tr></table></figure>
<p>写入线程的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost 桌面]# mkfifo test</span><br><span class="line">[root@localhost 桌面]# echo &quot;this is a pipe&quot; &gt; test</span><br><span class="line">[root@localhost 桌面]# mkfifo test</span><br></pre></td></tr></table></figure>

<p>可以看到，test管道内的数据被读取了。<code>echo</code>命令也结束了。</p>
<p>管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等待另一进程去拿，并且<strong>管道是单向传输的</strong>。</p>
<p><strong>这种通信方式效率低下：a 进程给 b 进程传输数据，a 进程只能等待 b 进程取完数据后才能返回。</strong>所以管道不适合频繁通信的进程。管道的优点是简单，能够保证数据已经真的被其他进程拿走。</p>
<h5 id="管道的创建"><a href="#管道的创建" class="headerlink" title="管道的创建"></a>管道的创建</h5><p>匿名管道的创建，需要通过右面这个系统调用：<code>int pipe(int fd[2])</code></p>
<p>这里表示创建一个匿名管道并返回了两个描述符：</p>
<ul>
<li>管道的读取端描述符 <code>fd[0]</code></li>
<li>管道的写入端描述符 <code>fd[1]</code></li>
</ul>
<p><strong>匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-453b44e8d2f88d29895c98fcf8d68059_720w.jpg" alt="img"></p>
<p><strong>管道就是内核里面的一串缓存。</strong>从管道的一段写入数据，实际上是缓存在内核中的；另一端的读取也是从内核中读取这段数据。管道传输的数据是无格式的流且大小受限。</p>
<p>这两个描述符都在一个进程里，没有起到进程间通信的作用，如何使管道在进程间通信呢？</p>
<p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件,实现跨进程通信了。</p>
<p><img src="https://pic4.zhimg.com/80/v2-f259e474c179d5d361cc1d31792bc913_720w.jpg" alt="img"></p>
<p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入或读出。为了避免这种情况，通常的做法是：</p>
<ul>
<li>父进程关闭读取的 <code>fd[0]</code>，只保留写入的 <code>fd[1]</code></li>
<li>子进程关闭写入的 <code>fd[1]</code>，只保留读取的 <code>fd[0]</code></li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-2b271b0a13d26af93cfb27c6dac96b3f_720w.jpg" alt="img"></p>
<p><strong>因此双向通信则需要创建两个管道。</strong></p>
<p>到这里，仅仅解析了使用管道进行父进程与子进程之间的通信，但在 shell 里并不是这样的。在 shell 里面执行 <code>A | B</code>命令时，A 进程和 B 进程都是 shell 创建出的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p>
<p><img src="https://pic3.zhimg.com/80/v2-48d26cbe54d6a7441e81c25648c63ec6_720w.jpg" alt="img"></p>
<p><strong>在 shell 里通过<code>「|」</code>匿名管道连接多个命令，实际上是创建了多个子进程。</strong></p>
<p>编写 shell 脚本时，尽量使用少的管道，这样可以减少创建子进程的系统开销。</p>
<p><strong>匿名管道的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 复制父进程 fd 文件描述符，达到通信的目的。</p>
<p>命名管道在不相关的进程间也能相互通信。因为命名管道提前创建了一个类型为管道的设备文件，在进程里只要使用该设备文件，就能相互通信。</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>管道的效率低，不适合进程间频繁地交换数据。</p>
<p>能不能把进程的数据放在某个内存之后就马上让进程返回，无需等待其他进程来取就返回呢？</p>
<p>消息队列这种通信模式可以解决上述问题。a 进程给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的消息队列里取出来。</p>
<p><strong>消息队列是保存在内核中的消息链表</strong>。发送数据时，会分成一个个独立的数据单元，也就是消息体（数据块）。消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>消息队列生命周期随内核，如果没有释放消息队列或没有关闭操作系统，消息队列会一直存在；匿名管道的生命周期随进程的创建而建立，随进程的结束而销毁。</p>
<h5 id="消息这种模型的两点不足："><a href="#消息这种模型的两点不足：" class="headerlink" title="消息这种模型的两点不足："></a>消息这种模型的两点不足：</h5><ol>
<li><p><strong>消息队列不适合较大数据的传输</strong>：在内核中每个消息体都有一个最大长度限制，同时所有队列所包含的全部消息体的总长度也有上限。Linux 内核中有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p>
</li>
<li><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p>
</li>
</ol>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>消息队列的读取和写入的过程，会发生用户态与内核态间的消息拷贝过程。共享内存能很好地解决了这一问题。</p>
<p>可能有人会问，每个进程有自己的独立内存，为什么两个进程可以共享一块内存呢？</p>
<p>现代操作系统，对于内存管理，采用的是虚拟内存技术：每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。即使进程 A 和 进程 B 的虚拟地址一样，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p>因为系统加载一个进程的时候，分配给进程的内存不是<strong>实际物理内存</strong>，而是<strong>虚拟内存空间</strong>。我们可以让<strong>两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中</strong>。这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
<p><img src="https://pic2.zhimg.com/80/v2-dd9c6b8f3837b01fe2d03733601b8bdd_720w.jpg" alt="img"></p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>共享内存的问题是如果多个进程同时修改同一个共享内存，很可能发生冲突。例如两个进程都同时写一个地址，那先写的进程写的内容就被后写的进程覆盖了。</p>
<p>为了防止多进程竞争共享资源，而造成数据错乱，所以需要保护机制，<strong>使得共享的资源在任意时刻只能被一个进程访问</strong>。信号量就实现了这一保护机制。</p>
<p><strong>信号量是一个整型的计数器，用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</strong></p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li><p>P 操作：把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</p>
</li>
<li><p>V 操作：把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程。</p>
</li>
</ul>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 1：</p>
<p><img src="https://pic4.zhimg.com/80/v2-497ef9aedd42917b72f26542177ff8ef_720w.jpg" alt="img"></p>
<p>具体的过程如下：</p>
<ul>
<li><p>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</p>
</li>
<li><p>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</p>
</li>
<li><p>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</p>
</li>
</ul>
<p>信号初始化为 1，就是<strong>互斥信号量</strong>，可以保证共享内存在任何时刻只有一个进程在访问。</p>
<p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p>
<p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</p>
<p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 0。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4e9de3837f1ed8b5576ee5140d89c34f_720w.jpg" alt="img"></p>
<p>具体过程：</p>
<ul>
<li><p>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</p>
</li>
<li><p>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</p>
</li>
<li><p>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</p>
</li>
</ul>
<p>信号初始化为 0，就是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就要用信号的方式来通知进程。</strong></p>
<p>信号跟信号量两者的用途完全不一样。Linux 为了响应各种事件，提供了几十种信号，分别代表不同的意义。 kill -l 命令可以查看所有的信号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如:</p>
<ul>
<li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程</li>
<li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束</li>
</ul>
<p>如果进程在后台运行，可以通过 kill 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li><code>kill -9 1050</code> ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，用来立即结束该进程。</li>
</ul>
<p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，就有下面这几种，用户进程对信号的处理方式：</p>
<ol>
<li><p><strong>执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如<code>SIGTERM</code>信号就是终止进程的意思。<code>Core</code>是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p>
</li>
<li><p><strong>捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
</li>
<li><p><strong>忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。</p>
</li>
</ol>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p><img src="https://pic2.zhimg.com/80/v2-421b5b49759b5821c84756b1a1956a3d_720w.jpg" alt="img"></p>
<ul>
<li>服务端和客户端初始化 socket，得到文件描述符；</li>
<li>服务端调用 bind，将绑定在 IP 地址和端口;</li>
<li>服务端调用 listen，进行监听；</li>
<li>服务端调用 accept，等待客户端连接；</li>
<li>客户端调用 connect，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 accept 返回用于传输的 socket 的文件描述符；</li>
<li>客户端调用 write 写入数据；服务端调用 read 读取数据；</li>
<li>客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。</li>
</ul>
<p>服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。所以监听的 socket 和真正用来传送数据的 socket是「两个」 socket，一个是监听 socket，一个是已完成连接 socket。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<blockquote>
<p>针对 UDP 协议通信的 socket 编程模型</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-ef63a6a123538470795de84049ed10d0_720w.jpg" alt="img"></p>
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>
<p>对于 UDP 来说，不需要维护连接，没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>
<p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于每个进程的用户空间都是独立的，不能相互访问，这就需要借助内核空间实现进程间通信，因为每个进程都共享一个内核空间。</p>
<p>其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p>
<p>匿名管道顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
<p>命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。</p>
<p>消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</p>
<p>共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</p>
<p>那么，就需要信号量来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。</p>
<p>与信号量名字很相似的叫信号，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中唯一的异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。</p>
<p>前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 Socket 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p>
<p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p>
<p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p>
<p>互斥的方式，可保证任意时刻只有一个线程访问共享资源；<br>同步的方式，可保证线程 A 应在线程 B 之前执行；</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Python队列</title>
    <url>/2020/10/07/Python%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列是一种只允许在一端进行插入操作，在另一端进行删除操作的线性表。</p>
<p>Python标准库中包含了四种队列，分别是:</p>
<ul>
<li>queue.Queue</li>
<li>asyncio.Queue</li>
<li>multiprocessing.Queue</li>
<li>collections.deque</li>
</ul>
<p>多个线程之间共享数据，多个线程数据交换时，不能保证数据的安全性和一致性。队列能完美解决线程间的数据交换，保证线程间数据的安全性和一致性（多线程通常要加锁，但很可能死锁；而queue自带锁，所以多线程结合queue会更好）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">my_queue = Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        num = randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">        print(<span class="string">"put: &#123;&#125;"</span>.format(num))</span><br><span class="line">        my_queue.put(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        num = my_queue.get()</span><br><span class="line">        print(<span class="string">"get: &#123;&#125;"</span>.format(num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=put)</span><br><span class="line">t2 = Thread(target=get)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">------------- output -------------</span><br><span class="line">put: <span class="number">1</span></span><br><span class="line">get: <span class="number">1</span></span><br><span class="line">put: <span class="number">1</span></span><br><span class="line">get: <span class="number">1</span></span><br><span class="line">put: <span class="number">10</span></span><br><span class="line">get: <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="FIFO-队列"><a href="#FIFO-队列" class="headerlink" title="FIFO 队列"></a>FIFO 队列</h4><p><strong>class queue.Queue(maxsize=0)</strong></p>
<p>FIFO（First in First Out）。Queue 提供了一个基本的 FIFO 容器，maxsize 指明队列中能存放的最多数据个数。一旦达到上限，插入会导致阻塞，直到队列中的数据被消费掉。如果 maxsize &lt;= 0 ，队列大小没有限制。</p>
<h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><p><code>Queue.qsize()</code>：返回队列大小</p>
<p><code>Queue.empty()</code>：判断队列是否为空</p>
<p><code>Queue.full()</code>：判断队列是否满了</p>
<p><code>Queue.get(block=True, timeout=None)</code>：从队列中移除并返回一个项目。如果可选参数 block 是 true 并且 timeout 是 None (默认值)，则在必要时阻塞至项目可得到。如果 timeout 是个正数，将最多阻塞 timeout 秒，如果在这段时间内项目不能得到，将引发 Empty 异常。反之 (block 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 Empty 异常 (这种情况下，timeout 将被忽略)。</p>
<p><code>Queue.get_nowait(item)</code>：相当于 <code>get(False)</code>。</p>
<p><code>Queue.task_done()</code>：表示前面排队的任务已经被完成。被队列的消费者线程使用。每个 get() 被用于获取一个任务， 后续调用 task_done() 告诉队列，该任务的处理已经完成。</p>
<p>如果 join() 当前正在阻塞，在所有条目都被处理后，将解除阻塞(意味着每个 put() 进队列的条目的 task_done() 都被收到)。</p>
<p>如果被调用的次数多于放入队列中的项目数量，将引发 ValueError 异常 。</p>
<p><code>Queue.put(item, block=True, timeout=None)</code>：将 item 放入队列。如果可选参数 block 是 true 并且 timeout 是 None (默认)，则在必要时阻塞至有空闲插槽可用。如果 timeout 是个正数，将最多阻塞 timeout 秒，如果在这段时间没有可用的空闲插槽，将引发 Full 异常。反之 (block 是 false)，如果空闲插槽立即可用，则把 item 放入队列，否则引发 Full 异常 ( 在这种情况下，timeout 将被忽略)。</p>
<p><code>Queue.put_nowait(item)</code>：相当于 <code>put(item, False)</code>。</p>
<p><code>Queue.join()</code>：阻塞至队列中所有的元素都被接收和处理完毕。<br>当条目添加到队列的时候，未完成任务的计数就会增加。每当消费者线程调用 task_done() 表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， join() 阻塞被解除。<br>监视所有item并阻塞主线程，直到所有item都调用了task_done之后主线程才继续向下执行。<br>假如一个线程开始处理最后一个任务，它从队列中拿走最后一个任务，此时队列为空但最后运行任务的线程还没处理完。当调用了join后，主线程不会因为队列为空而擅自结束，而是等待最后运行任务的线程处理完成再结束。</p>
<p><strong>如何等待排队的任务被完成的示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    print(q.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        print(<span class="string">f'Working on <span class="subst">&#123;item&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'Finished <span class="subst">&#123;item&#125;</span>'</span>)</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># turn-on the worker thread</span></span><br><span class="line">threading.Thread(target=worker, daemon=<span class="literal">True</span>).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># send thirty task requests to the worker</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    q.put(item)</span><br><span class="line">print(<span class="string">'All task requests sent\n'</span>, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># block until all tasks are done</span></span><br><span class="line">q.join()</span><br><span class="line">print(<span class="string">'All work completed'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------- output -------------</span><br><span class="line">All task requests sent</span><br><span class="line">Working on <span class="number">0</span></span><br><span class="line">Finished <span class="number">0</span></span><br><span class="line">Working on <span class="number">1</span></span><br><span class="line">Finished <span class="number">1</span></span><br><span class="line">Working on <span class="number">2</span></span><br><span class="line">Finished <span class="number">2</span></span><br><span class="line">Working on <span class="number">3</span></span><br><span class="line">Finished <span class="number">3</span></span><br><span class="line">Working on <span class="number">4</span></span><br><span class="line">Finished <span class="number">4</span></span><br><span class="line">Working on <span class="number">5</span></span><br><span class="line">Finished <span class="number">5</span></span><br><span class="line">Working on <span class="number">6</span></span><br><span class="line">Finished <span class="number">6</span></span><br><span class="line">Working on <span class="number">7</span></span><br><span class="line">Finished <span class="number">7</span></span><br><span class="line">Working on <span class="number">8</span></span><br><span class="line">Finished <span class="number">8</span></span><br><span class="line">Working on <span class="number">9</span></span><br><span class="line">Finished <span class="number">9</span></span><br><span class="line">All work completed</span><br></pre></td></tr></table></figure>
<h4 id="LIFO-队列"><a href="#LIFO-队列" class="headerlink" title="LIFO 队列"></a>LIFO 队列</h4><p><strong>class queue.LifoQueue(maxsize=0)</strong></p>
<p><strong>源码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifoQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    <span class="string">'''Variant of Queue that retrieves most recently added entries first.'''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init</span><span class="params">(self, maxsize)</span>:</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_qsize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.pop()</span><br></pre></td></tr></table></figure>

<p>LIFO （Last in First Out），与栈类似，用法同上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.LifoQueue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    print(q.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="优先队列-PriorityQueue"><a href="#优先队列-PriorityQueue" class="headerlink" title="优先队列 PriorityQueue"></a>优先队列 PriorityQueue</h4><p>存入数据时加入一个优先级，取数据的时候优先级最高的先取出。</p>
<p><strong>源码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    <span class="string">'''Variant of Queue that retrieves open entries in priority order (lowest first).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Entries are typically tuples of the form:  (priority number, data).</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init</span><span class="params">(self, maxsize)</span>:</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_qsize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        heappush(self.queue, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heappop(self.queue)</span><br></pre></td></tr></table></figure>
<p>PriorityQueue 在插入元素时已经对元素做了排序，把最小的元素放在队尾:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line">items = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">pq = PriorityQueue()</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> items:</span><br><span class="line">    pq.put(element)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> pq.empty():</span><br><span class="line">    print(pq.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>PriorityQueue 对tuple作比较时，按照元素的顺序，找到第一个可比较的元素进行比较。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line">customers = PriorityQueue()</span><br><span class="line">customers.put((<span class="number">2</span>, <span class="string">"Harry"</span>))</span><br><span class="line">customers.put((<span class="number">3</span>, <span class="string">"Charles"</span>))</span><br><span class="line">customers.put((<span class="number">1</span>, <span class="string">"Riya"</span>))</span><br><span class="line">customers.put((<span class="number">4</span>, <span class="string">"Stacy"</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> customers.empty():</span><br><span class="line">    print(customers.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="string">'Riya'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2</span>, <span class="string">'Harry'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">3</span>, <span class="string">'Charles'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">4</span>, <span class="string">'Stacy'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="queue-Queue-amp-asyncio-Queue"><a href="#queue-Queue-amp-asyncio-Queue" class="headerlink" title="queue.Queue &amp; asyncio.Queue"></a>queue.Queue &amp; asyncio.Queue</h4><p>queue.Queue和asyncio.Queue都是支持多生产者、多消费者的队列，基于collections.deque，他们都提供了Queue（FIFO队列）、PriorityQueue（优先级队列）、LifoQueue（LIFO队列），接口方面也相同。</p>
<p>区别在于queue.Queue适用于多线程的场景，asyncio.Queue适用于协程场景下的通信。由于asyncio的加成，queue.Queue下的阻塞接口在asyncio.Queue中是以返回协程对象的方式执行，具体差异如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-15de9fde6c4723e7e36d52c3b9d4ec04_720w.jpg" alt="img"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>collections.deque在数据结构层面实现了队列，但并没有应用场景方面的支持，是一个基础的数据结构。</p>
<p>queue：面向多生产线程、多消费线程的队列。</p>
<p>asyncio.queue：面向多生产协程、多消费协程的队列。</p>
<p>multiprocessing.queue：面向多成产进程、多消费进程的队列。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>详解collections工具库</title>
    <url>/2020/10/05/%E8%AF%A6%E8%A7%A3collections%E5%B7%A5%E5%85%B7%E5%BA%93/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/110476502" target="_blank" rel="noopener">承志：Python——详解collections工具库</a></p>
<h4 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h4><p>defaultdict 解决的是 dict 中最常见的问题：<strong>key 为空</strong>的情况。</p>
<p>通常在 dict 中获取元素时，都要考虑 key 为空的情况。如果不考虑这点，获取一个不存在的 key 会导致异常。我们可以在每次 get 之前写一个if判断，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> dict:</span><br><span class="line">    <span class="keyword">return</span> dict[key]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>当然，这是最笨的方法，dict 为我们提供了带默认值的 get 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> dict.get(key, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>这样，如果 key 不存在 dict 里，会自动返回设置好的默认值。省去了很多麻烦的判断，但仍然存在问题：比如当 key 存在重复，我们希望将 key 相同的 value 存进一个list当中，而不是只保留一个。这种情况下写成代码就会比较复杂：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">in</span> d:</span><br><span class="line">        d[k].append(v)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d[k] = [v]</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>: [<span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>: [<span class="number">1</span>, <span class="number">5</span>], <span class="number">3</span>: [<span class="number">7</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>由于 dict 的 value 是一个 list，所以仍要判断是否为空，不能直接使用默认值，间接操作当然可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    cur = d.get(k, [])</span><br><span class="line">    cur.append(v)</span><br><span class="line">    d[k] = cur</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>: [<span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>: [<span class="number">1</span>, <span class="number">5</span>], <span class="number">3</span>: [<span class="number">7</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>这和使用if区别不大，我们可以使用 collections 当中的<strong>defaultdict</strong>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    d[k].append(v)</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line">&gt;&gt;&gt; defaultdict(&lt;class 'list'&gt;, &#123;1: [3, 4], 2: [1, 5], 3: [7]&#125;)</span><br></pre></td></tr></table></figure>
<p>使用 defaultdict 后，如果key不存在，容器会自动返回预先设置的默认值。defaultdict传入的默认值可以是类型或方法。如果想传入int，那么默认值会被设置成int()的结果，也就是0，如果我们想要自定义或者修改，可以传入一个方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    d[k] += v</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; defaultdict(&lt;class 'int'&gt;, &#123;1: 7, 2: 6, 3: 7&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque是双端队列。对于queue来说，只允许在队尾插入元素，在队首弹出元素。而deque的队首和队尾都支持元素的插入和弹出。比普通的队列更加灵活。</p>
<p>在日常的使用中用到双端队列的算法不太多。大多数情况下使用deque主要有两个原因：</p>
<ol>
<li><p>deque受到GIL的管理，它是线程安全的。而list则没有GIL锁，因此线程不安全。在并发场景下，list可能会导致一致性问题，而deque不会。</p>
</li>
<li><p>deque支持固定长度，当长度满了之后，如果继续append，它会自动弹出最早插入的数据。</p>
</li>
</ol>
<p>当我们拥有海量的数据，但不知道数据的数量，如果想要保留最后出现的指定数量的数据时，就可以使用deque。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">dque = deque(maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 假设我们想要从文件当中获取最后10条数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f.read():</span><br><span class="line">    dque.append(i)</span><br></pre></td></tr></table></figure>
<h4 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h4><p>在常见的面向对象当中，通常都是定义类，再通过类的构造函数来创建实例。元编程指的是我们定义元类，元类创建出来的不是实例，而是类。如果用模具和成品来分别比喻类和实例的话，元类相当于是模具的模具。</p>
<p>namedtuple是一个元类，通过它可以非常方便地定义类。</p>
<p>如果定义一个学生类，有name、score、age这三个字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, score=None, age=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>
<p>使用namedtuple可以简化代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Student = namedtuple(<span class="string">'Student'</span>, [<span class="string">'name'</span>, <span class="string">'score'</span>, <span class="string">'age'</span>])</span><br><span class="line">student = Student(name=<span class="string">'xiaoming'</span>, score=<span class="number">99</span>, age=<span class="number">10</span>)</span><br><span class="line">print(student.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xiaoming</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解数据库行锁与表锁</title>
    <url>/2020/09/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%8C%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/52678870" target="_blank" rel="noopener">加耀：深入理解数据库行锁与表锁</a></p>
<p>数据库如何隔离事务呢？这就牵连到了锁。当插入数据时就锁定表的叫”锁表”；当更新数据时锁定行的叫”行锁”。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">行锁</th>
<th align="center">表锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MyISAM</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">InnoDB</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
</tbody></table>
<p><strong>表锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率高，并发度最低。<br><strong>行锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</p>
<p>当多个用户对数据库进行操作时，可能导致数据不一致。所以，锁用来<strong>在多用户情况下保证数据库数据完整性和一致性。</strong></p>
<p><img src="https://picb.zhimg.com/80/v2-eec522a8cf7d8a38eaea29192edbb2f5_720w.jpg" alt="img"></p>
<p><img src="https://picb.zhimg.com/80/v2-5cf8b96fdca1428e6f3cce863fdfa73e_720w.jpg" alt="img"></p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>行锁锁一行或多行记录，<strong>mysql的行锁是基于索引加载的</strong>，所以<strong>行锁要加在索引响应的行上，即命中索引</strong>。</p>
<p><img src="https://pic1.zhimg.com/80/v2-81420e5b7f1a256b86346781f0379bc6_720w.jpg" alt="img"></p>
<p>上表中有一个主键索引（id）和一个普通索引（email），sql语句基于索引查询命中两条记录。此时行锁锁定了两条记录，当其他事务访问该表时，被锁定的记录不能被访问，其它记录能被访问。</p>
<p>打开两个窗口 A 和 B，在 A 中根据 id 更新一条记录，再在 B 中也执行相同的SQL语句：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e7cb6996c72c83c495ee940ffd6964a2_720w.jpg" alt="img"></p>
<p>窗口 A 先修改了 id 为3的用户信息后，还未提交事务，窗口 B 再更新同一条记录，数据库提示 <code>Lock wait timeout exceeded; try restarting transaction</code>。由于窗口 A 未提交事务，导致锁一直未被释放，出现了锁冲突。窗口 B 一直等待锁的释放，所以出现了超过锁定超时的警告了。</p>
<p>此时如果更新 id 为3它旁边的记录会怎样呢？我们新打开一个窗口更新 id 为2的记录。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2b69c74a17cfe1ef6b0f29cca0ee130c_720w.jpg" alt="img"></p>
<p>在窗口B中更新 id 为3的记录报错，但在窗口 C 中可以更新 id 为2的记录，说明此时锁定了id为 3 的记录但未锁定其它记录。</p>
<p>在 InnoDB 中， 行锁是基于索引实现的。如果某个加锁操作未使用索引，那么该锁就会退化为表锁。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁锁一整张表。在表被锁定期间，其他事务不能操作该表，必须等该表的锁被释放后再操作。<strong>表锁响应的是非索引字段，即全表扫描</strong>，全表扫描时锁定整张表。</p>
<p><img src="https://pic3.zhimg.com/80/v2-54fde24a455d14e96d364f633f87b680_720w.jpg" alt="img"></p>
<p>表锁每次都锁整张表，所以表锁的锁冲突概率高，表锁不会出现死锁。</p>
<p>打开两个窗口 A 和 B，在 A 中更新一条记录，条件为<strong>非索引字段</strong>，不提交事务，再在 B 中任意再更新一条记录：</p>
<p><img src="https://picb.zhimg.com/80/v2-a3da10ada0e98184ca99dc31ee68c3a1_720w.jpg" alt="img"></p>
<p>因为更新数据时未触发索引，所以锁表。锁表后对表做的任何变更操作都会导致锁冲突，所以表锁的锁冲突概率高。</p>
<p>行锁又衍生了三种算法锁：记录锁、间隙锁、临键锁。</p>
<h4 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁 (Record Lock)"></a>记录锁 (Record Lock)</h4><p>行锁是命中索引，锁了表的一条或多条记录，记录锁是行锁衍生的锁。</p>
<p>记录锁锁的是表中的某<strong>一条</strong>记录，记录锁的出现条件<strong>必须是精准命中索引并且索引是唯一索引</strong>，如主键id。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e7cb6996c72c83c495ee940ffd6964a2_720w.jpg" alt="img"></p>
<p>图中 id 是唯一索引，此时锁的就是一条记录，命中索引为唯一索引，此时使用的锁就是记录锁。</p>
<p>通过<strong>主键索引或唯一索引</strong> UPDATE 数据时，也会对该行数据加记录锁：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">SET</span> age = <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<p>需要注意：</p>
<ul>
<li><p>记录锁必须使用主键索引或唯一索引，否则记录锁会退化成临键锁。</p>
</li>
<li><p>查询语句必须为精准匹配（<code>=</code>），不能为 <code>&gt;、&lt;、like</code>等，否则记录锁会退化成临键锁。</p>
</li>
</ul>
<h4 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 (Gap Lock)"></a>间隙锁 (Gap Lock)</h4><p>间隙锁每次都锁定一个区间，也属于行锁。间隙锁的触发条件也是命中索引，当我们查询数据用范围查询而非精准匹配（<code>=</code>）时，<strong>查询条件命中索引，但没有查询到符合条件的记录</strong>，此时就会将查询条件中的范围数据进行锁定（即使是范围中不存在的数据也会被锁定）。</p>
<p>打开两个窗口，在窗口 A 中根据id做一个范围更改操作，不提交事务，然后在窗口 B 中插入一条记录，该记录的id值位于窗口 A 中的条件范围内：</p>
<p><img src="https://pic1.zhimg.com/80/v2-32fd1eb4a26fa35610703d98f6b36a79_720w.jpg" alt="img"></p>
<p>如上所示，程序报错：<code>Lock wait timeout exceeded; try restarting transaction</code>，这就是间隙锁的作用。<strong>间隙锁只出现在可重复读的事务隔离级别中，<code>mysql5.7</code>默认就是可重复读</strong>。间隙锁锁的是一个区间范围，查询命中索引但没有匹配到记录时，锁定的是查询的这个区间范围，上图锁定的区间就是 (1,3]这个左开右闭的区间。</p>
<p>如果将 mysql 数据库隔离级别修改为读已提交会是怎样的呢？验证一下间隙锁只会出现在可重复读的事务隔离级别中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置事务隔离级别为读已提交</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line"><span class="comment">-- 查看当前事务级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @@tx_isolation</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-018f7b3ebf9bdac04068b77714dc430c_720w.jpg" alt="img"></p>
<p>修改了数据库隔离级别后，再次测试间隙锁，间隙锁没有生效。</p>
<p><strong>产生间隙锁的条件（Repeatable-Read事务隔离级别下）</strong>：</p>
<ul>
<li><p>在普通索引列上，不论何种查询，只要加锁，就产生间隙锁</p>
</li>
<li><p>使用多列唯一索引</p>
</li>
<li><p>使用唯一索引锁定多行记录</p>
</li>
</ul>
<p>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。</p>
<h4 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁 (Next-Key Lock)"></a>临键锁 (Next-Key Lock)</h4><p>mysql 的行锁默认就是临键锁，临键锁由记录锁和间隙锁共同实现。间隙锁的触发条件是命中索引，范围查询没有匹配的记录。而临键锁恰好相反，临键锁的触发条件也是<strong>查询条件命中索引，但临键锁匹配到了记录</strong>。</p>
<p><strong>间隙锁锁定了一个左开右闭的区间，而临键锁锁定了当前记录的区间和下一个记录的区间：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-0a82d8e24b998db426e0363e6140343f_720w.jpg" alt="img"></p>
<p><img src="https://picb.zhimg.com/80/v2-2693531707b096359a778852d943c12b_720w.jpg" alt="img"></p>
<p>数据库中只有三条数据1、5、7，当修改范围为<code>(1， 8]</code>时，间隙锁锁定的区间为<code>(1,+∞)</code>，锁定了查询的范围和查询范围的下一个范围区间。在数据库中是不存在id 为8的记录，如果查询条件是<code>&lt;=8</code>，也是锁定8到后面的区间。</p>
<p>如果查询的结尾是一个存在的值，又会怎样呢？现在数据库有三条数据id分别是1、5、7，将查询条件改为大于1小于7：</p>
<p><img src="https://pic1.zhimg.com/80/v2-44833c3c68bd57d7112967ab4797e07c_720w.jpg" alt="img"></p>
<p>7 在数据库中是已知记录，此时只锁定了<code>(1,7]</code>，7之后的数据未被锁定。我们可以正常插入id为8的数据和后面的数据。</p>
<p><strong>临键锁的锁定区间和查询范围的后匹配值有关</strong>。如果后匹配值存在，则只锁定当前的查询区间，否则锁定查询区间和后匹配值与它的下一个值的区间。</p>
<p>为什么临键锁后匹配值会这样呢？因为 mysql 的索引是基于B+树实现的，每个树节点上都有多个元素，即关键字数，当我们的索引树上只有1、5、7时，我们查询1~8，此时由于树节点关键字中并没有8，所以就把8到正无穷的区间范围都给锁定了。</p>
<p>如果数据库中id有1、5、7、10，此时模糊匹配id为 <code>(1， 8]</code> 的时候，由于关键字中并没有 8 ，所以找到了比 8 大的 10，根据左开右闭原则，此时区间为<code>(1， 10]</code>，10 也被锁定了，但<code>id=11</code>的记录仍可以正常插入。</p>
<p>锁是基于索引的，mysql 中索引的底层是B+树，了解了B+树的特性后，就更容易理解锁的问题了。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Mysql 索引底层原理</title>
    <url>/2020/08/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Mysql%20%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>整理自<a href="https://zhuanlan.zhihu.com/p/113917726" target="_blank" rel="noopener">腾讯技术工程：深入理解 Mysql 索引底层原理</a></p>
<p>Mysql底层的存储引擎和数据检索引擎的设计非常重要，尤其是 Mysql 数据的存储形式和索引的设计，决定了 Mysql 的数据检索性能。</p>
<p>索引的作用是做<strong>数据的快速检索</strong>，快速检索的本质是数据结构。不同的数据结构实现了不同的数据快速检索。</p>
<p>数据库中存储了大量数据，高效的索引能节省巨大的时间。如下图所示，如果 Mysql 没有索引，那么查找 id=7 这个数据，只能采取暴力顺序遍历查找，需要比较 7 次。如果表存储了 1000W 个数据，查找 id=1000W 这个数据要比较 1000W 次。</p>
<p><img src="https://pic1.zhimg.com/80/v2-5141ed6f1bddd61750763b51bdc9ecb4_720w.jpg" alt="img"></p>
<h4 id="一、Mysql-索引底层数据结构选型"><a href="#一、Mysql-索引底层数据结构选型" class="headerlink" title="一、Mysql 索引底层数据结构选型"></a>一、Mysql 索引底层数据结构选型</h4><h5 id="1-哈希表（Hash）"><a href="#1-哈希表（Hash）" class="headerlink" title="1.哈希表（Hash）"></a>1.哈希表（Hash）</h5><p>哈希算法（散列算法）：<strong>把任意值(key)通过哈希函数变换为固定长度的 key 地址，通过地址查找具体数据的数据结构。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-7805f7b4bab4c98adc045e3667046398_720w.jpg" alt="img"></p>
<p>考虑上面的数据库表 user，表中共有 7 个数据，如果检索 id=7 的数据，SQL 语法是：</p>
<p><code>select * from user where id=7;</code></p>
<p>哈希算法首先计算存储 id=7 这个数据的物理地址 addr=hash(7)=4231，4231 映射的物理地址是 0x77，0x77 就是 id=7 存储数据的物理地址，通过该物理地址能找到对应 user_name=’g’这个数据。这就是哈希算法快速检索数据的计算过程。</p>
<p><strong>哈希算法有数据碰撞的问题，哈希函数可能对不同的 key 计算出相同结果</strong>。hash(7)可能跟 hash(199)的结果一样，不同的 key 映射到同一结果，这就是碰撞问题。解决碰撞问题的一个常见方法就是<strong>链地址法</strong>，用链表把碰撞的数据连接。计算哈希值后，检查该哈希值是否存在碰撞数据链表，有则一直遍历到链表尾，直到找到真正的 key 对应的数据为止。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4deae667d7d5c9a1a166cb0e8bac9dd6_720w.jpg" alt="img"></p>
<p><img src="https://picb.zhimg.com/80/v2-df9820ea9f7146d09af8280040f185f5_720w.jpg" alt="img"></p>
<p>哈希算法时间复杂度为 O(1)，检索速度非常快。哈希索引只需计算一次就能得到数据。但 Mysql 没有采取哈希作为底层算法，因为数据检索经常<strong>范围查找</strong>，比如这个 SQL 语句：</p>
<p><code>select * from user where id &gt;3;</code></p>
<p>如果使用了哈希算法实现的索引，一个简单的思路就是一次性把所有数据加载到内存，在内存里筛选目标范围内的数据。这个方法笨重且没有效率。</p>
<p><strong>哈希算法实现的索引能做到快速检索数据，但不能高效地范围查找数据，因此哈希索引不适合作为 Mysql 的底层索引的数据结构。</strong></p>
<h5 id="2-二叉查找树-BST"><a href="#2-二叉查找树-BST" class="headerlink" title="2.二叉查找树(BST)"></a>2.二叉查找树(BST)</h5><p>二叉查找树是一种支持数据快速查找的数据结构。</p>
<p><img src="https://pic2.zhimg.com/80/v2-032790aff0ddf52b676413573acce776_720w.jpg" alt="img"></p>
<p>二叉查找树的时间复杂度是 O(lgn)，上面的二叉树结构只需要比较 3 次就能检索到 id=7 的数据。</p>
<p>二叉树能否解决哈希索引不能提供的范围查找功能呢？</p>
<p>能。观察上图，<strong>二叉树的叶子节点按序排列，从左到右依次升序，如果要找 id&gt;5 的数据，取出值为6 的节点以及其右子树就可以了。</strong></p>
<p>但普通的二叉查找树有个致命缺点：<strong>极端情况下会退化为线性链表，二分查找退化为遍历查找，时间复杂度退化为 O(n)，检索性能急剧下降</strong>。</p>
<p>如下图所示，二叉树极度不平衡，退化为链表，检索速度大大降低。此时检索 id=7 的数据需计算7次。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1cc416d59d4c44cf029e9e2103347bb8_720w.jpg" alt="img"></p>
<p>在数据库中，数据的自增很常见，比如一个表的主键是 id，主键一般默认自增，如果采取二叉树作为索引，那不平衡状态导致的线性查找的问题必然出现。<strong>简单的二叉查找树存在不平衡状态，会导致检索性能降低，不能直接用于 Mysql 底层索引</strong>。</p>
<h5 id="3-AVL-树和红黑树"><a href="#3-AVL-树和红黑树" class="headerlink" title="3.AVL 树和红黑树"></a>3.AVL 树和红黑树</h5><p>二叉查找树存在不平衡状态的问题，因此学者提出通过树节点的自动旋转和调整，让二叉树始终保持平衡状态，就能保持二叉查找树的查找性能了。基于这种思路的自调整平衡状态的二叉树有 AVL 树和红黑树。</p>
<p><strong>红黑树是一颗会自动调整树形态的树结构</strong>，比如当二叉树处于不平衡状态时，红黑树会自动左/右旋节点以及节点变色，调整树形态，使其保持平衡状态（时间复杂度为 O(logn)），保证了查找效率不会明显减低。</p>
<p>比如从 1 到 7 升序插入数据节点，普通的二叉查找树会退化成链表，但红黑树会不断调整树形态，使其保持平衡状态，如下图所示。这个红黑树查找 id=7 的数据要比较4次，保持了二叉树不错的查找效率。</p>
<p><img src="https://pic3.zhimg.com/80/v2-46e7e44e8ba85e606d68ea9644092d08_720w.jpg" alt="img"></p>
<p>红黑树平均查找效率较好，也没有极端的 O(n)情况，那红黑树作为 Mysql 底层索引实现是否可以呢？观察下面的例子。</p>
<p>红黑树顺序插入 1~7 个节点，查找 id=7 时需比较 4 次。</p>
<p><img src="https://pic3.zhimg.com/80/v2-46e7e44e8ba85e606d68ea9644092d08_720w.jpg" alt="img"></p>
<p>红黑树顺序插入 1~16 个节点，查找 id=16 需比较 6 次。观察这个树的形态：当数据顺序插入时，树的形态一直“右倾”。从根本上看，红黑树没有完全解决二叉查找树存在的问题。虽然红黑树的“右倾”趋势远没有二叉查找树退化为线性链表那么夸张，但数据库的主键基本都是自增的，主键一般都是成百上千万的，红黑树的这种问题对于查找性能而言也是巨大的消耗。</p>
<p><img src="https://pic3.zhimg.com/80/v2-60cea4af963b156ee5f40030977ab77c_720w.jpg" alt="img"></p>
<p>现在考虑另一种更为严格的自平衡二叉树 AVL 树。<strong>AVL 树是绝对平衡的二叉树，因此它在调整二叉树的形态上消耗更多的性能。</strong></p>
<p>AVL 树顺序插入 1~7 个节点，查找 id=7 要比较 3 次。</p>
<p><img src="https://pic3.zhimg.com/80/v2-4c39b8eacc6879d661ddb1ed4190aff2_720w.jpg" alt="img"></p>
<p>AVL 树顺序插入 1~16 个节点，查找 id=16 要比较 4 次。从查找效率而言，AVL 树查找速度（4次）高于红黑树（6次）。<strong>AVL 树不存在红黑树“右倾”问题，大量的顺序插入不会导致查询性能的降低，这从根本上解决了红黑树的问题。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-0dad51645707e973b152e44e4b7479c5_720w.jpg" alt="img"></p>
<p>AVL 树的优点：</p>
<ol>
<li><p>不错的查找性能（O(logn)），不存在极端的低效查找的情况。</p>
</li>
<li><p>可以实现范围查找、数据排序。</p>
</li>
</ol>
<p>AVL 树也不适合做 Mysql 数据库的索引数据结构，考虑这个问题：</p>
<p><strong>数据库查询数据的瓶颈在于磁盘 IO</strong>，如果使用了 AVL 树，每一个树节点只存储一个数据，一次磁盘 IO 只能取出一个节点上的数据加载到内存，比如查询 id=7 这个数据，要进行磁盘 IO 三次，消耗很多时间。<strong>所以设计数据库索引时首先考虑怎么尽可能减少磁盘 IO 的次数</strong>。</p>
<p>磁盘 IO 有个特点，<strong>从磁盘读取 1B 数据和 1KB 数据所消耗的时间基本一样</strong>，我们可以根据这个思路，<strong>在一个树节点上尽可能多地存储数据，一次磁盘 IO 加载了更多的数据到内存</strong>，这就是 B 树和B+树的设计原理。</p>
<h5 id="4-B树"><a href="#4-B树" class="headerlink" title="4.B树"></a>4.B树</h5><p>下面这个 B 树，每个节点限制最多存储两个 key，一个节点如果超过两个 key 就会自动分裂。比如下面这个存储了 7 个数据的 B 树，只需要查询两个节点就能知道 id=7 这个数据的具体位置，两次磁盘 IO 就能查询到指定数据，优于 AVL 树。</p>
<p><img src="https://picb.zhimg.com/80/v2-f508590121487b595c4ad4fa83d8aa15_720w.jpg" alt="img"></p>
<p>下面是一个存储了 16 个数据的 B 树，每个节点最多存储 2 个 key，查询 id=16 这个数据需要比较 4 个节点（4 次磁盘 IO）。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f335bdb3e922a5f334416f557df20848_720w.jpg" alt="img"></p>
<p>但考虑到<strong>磁盘 IO 读 1 个数据和读 100 个数据消耗的时间基本一致</strong>，那优化思路就可以改为：尽可能在一次磁盘 IO 中读更多的数据到内存。直接反映到树的结构就是，每个节点能存储的 key 可以适当增加。</p>
<p>当把单个节点限制的 key 个数设置为 6 之后，一个存储了 7 个数据的 B 树，查询 id=7 这个数据需要 2 次磁盘 IO 。</p>
<p><img src="https://pic4.zhimg.com/80/v2-0fdff8f9a516383548cd0e636f593e52_720w.jpg" alt="img"></p>
<p>一个存储了 16 个数据的 B 树，查询 id=7 这个数据只要 2 次磁盘 IO。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7d5e34c698b1e4192ad0ff93c2c897d0_720w.jpg" alt="img"></p>
<p>B 树用作数据库索引有以下优点：</p>
<ol>
<li><p>优秀检索速度，时间复杂度：B 树的查找性能等于 O（h*logn），其中 h 为树高，n 为每个节点关键词的个数</p>
</li>
<li><p>尽可能少的磁盘 IO，加快了检索速度</p>
</li>
<li><p>支持范围查找</p>
</li>
</ol>
<h5 id="5-B-树"><a href="#5-B-树" class="headerlink" title="5.B+树"></a>5.B+树</h5><h6 id="B-树和-B-树的区别："><a href="#B-树和-B-树的区别：" class="headerlink" title="B 树和 B+树的区别："></a>B 树和 B+树的区别：</h6><p><img src="https://images2015.cnblogs.com/blog/576154/201609/576154-20160907130956629-1833512478.png" alt="img"></p>
<p>第一，B+ 树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节点存不了很多数据，但 B+树一个节点能存很多索引，B+树的叶子节点存所有数据。</p>
<p>第二，B+ 树中所有叶子节点通过指针连接，便于范围查找；而B树不会。</p>
<h6 id="B-树的优点："><a href="#B-树的优点：" class="headerlink" title="B+树的优点："></a>B+树的优点：</h6><ol>
<li><p>非叶子节点不会带上ROWID，因此一个块中能容纳更多的索引项。可以降低树的高度，并且一个内部节点可以定位更多的叶子节点。</p>
</li>
<li><p>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</p>
</li>
</ol>
<h6 id="B树的优点："><a href="#B树的优点：" class="headerlink" title="B树的优点："></a>B树的优点：</h6><p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p>
<p><img src="https://pic3.zhimg.com/80/v2-bda6661499c51dcff63eb12fd4b3795d_720w.png" alt="img"></p>
<p><strong>B+树节点存储的是索引，在单个节点存储容量有限的情况下，单节点也能存储大量索引，使得整个 B+树高度降低，减少了磁盘 IO。其次，B+树的叶子节点是真正数据存储的地方，叶子节点用链表连接，链表本身就有序，在数据范围查找时效率更高。因此 Mysql 的索引用的就是 B+树，B+树在查找效率、范围查找中都有着非常不错的性能。</strong></p>
<h4 id="二、Innodb-引擎和-Myisam-引擎的实现"><a href="#二、Innodb-引擎和-Myisam-引擎的实现" class="headerlink" title="二、Innodb 引擎和 Myisam 引擎的实现"></a>二、Innodb 引擎和 Myisam 引擎的实现</h4><p>Mysql 底层数据引擎最常见的是 Innodb 引擎和 Myisam 引擎，B+树作为 Mysql 的索引的数据结构非常合适，但是数据和索引如何组织起来也需要一番设计，设计理念的不同也导致了 Innodb 和 Myisam 的出现。</p>
<p><strong>MyISAM 虽然数据查找性能极佳，但不支持事务处理。Innodb 支持了 ACID 兼容的事务功能，而且也支持行级锁</strong>。Mysql 建立表的时候就可以指定引擎，比如下面的例子，分别指定了 Innodb 和 Myisam 作为 user 表和 user2 表的数据引擎。</p>
<p><img src="https://pic4.zhimg.com/80/v2-0df18cce6c3871fa9e4ac99050bf1692_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-e4e24288dca3ef02735c41a2a3a69556_720w.jpg" alt="img"></p>
<p>执行这两个指令后，系统出现了以下的文件，说明这两个引擎数据和索引的组织方式是不一样的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8a065d6e21a2adbf06d2e6b5dd02e969_720w.jpg" alt="img"></p>
<p>Innodb 创建表后生成的文件有：</p>
<ul>
<li><p>frm:创建表的语句</p>
</li>
<li><p>idb:表里面的数据+索引文件</p>
</li>
</ul>
<p>Myisam 创建表后生成的文件有</p>
<ul>
<li><p>frm:创建表的语句</p>
</li>
<li><p>MYD:表里面的数据文件（myisam data）</p>
</li>
<li><p>MYI:表里面的索引文件（myisam index）</p>
</li>
</ul>
<p>MyISAM 引擎把数据和索引分开了，一人一个文件，这是<strong>非聚集索引方式</strong>；Innodb 引擎把数据和索引放在同一文件里，这是<strong>聚集索引方式</strong>。</p>
<p><strong>1.MyISAM 引擎的底层实现（非聚集索引方式）</strong></p>
<p>MyISAM 用的是非聚集索引方式，即数据和索引在两个文件上。MyISAM 在建表时以主键作为 KEY 来建立主索引 B+树，树的叶子节点存的是对应数据的物理地址。拿到物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录了。</p>
<p><img src="https://pic1.zhimg.com/80/v2-d9a03627e8e1319e46f42e6963c35e30_720w.jpg" alt="img"></p>
<p>当我们为某个字段添加索引时，同样会生成对应字段的索引树，该字段的索引树的叶子节点同样记录了对应数据的物理地址，也是拿着物理地址去数据文件里定位到具体的数据记录。</p>
<p><strong>2.Innodb 引擎的底层实现（聚集索引方式）</strong></p>
<p>InnoDB 是聚集索引方式，数据和索引存储在同一文件里。首先 InnoDB 会根据主键 ID 作为 KEY 建立索引 B+树，如左下图所示，而 B+树的叶子节点存储的是主键 ID 对应的数据，比如在执行 <code>select * from user_info where id=15</code> 时，InnoDB 会查询这颗主键 ID 索引 B+树，找到对应的 user_name=’Bob’。</p>
<p>建表的时候 InnoDB 就会自动建立好主键 ID 索引树，这也是为什么 Mysql 在建表时要求必须指定主键的原因。当我们为表里某个字段加索引时, InnoDB 会怎么建立索引树呢？比如我们要给 <code>user_name</code> 这个字段加索引，那么 InnoDB 就会建立 user_name 索引 B+树，节点里存的是 <code>user_name</code> 这个 KEY，叶子节点存储的数据的是主键 KEY。注意，<strong>叶子存储的是主键 KEY！拿到主键 KEY 后，InnoDB 才会去主键索引树里根据刚在 <code>user_name</code> 索引树找到的主键 KEY 查找到对应的数据。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-6e16b355e3d0f05ed8bfb0f7c71de8f1_720w.jpg" alt="img"></p>
<p>为什么 InnoDB 只在主键索引树的叶子节点存储具体数据，但其他的索引树不存具体数据呢？为什么要多此一举先找到主键，再在主键索引树找到对应的数据呢?</p>
<p>原因是 InnoDB 要节省存储空间。一个表里可能有很多个索引，InnoDB 都会给每个加了索引的字段生成索引树，如果每个字段的索引树都存储了具体数据，那么这个表的索引数据文件就变得非常巨大（数据极度冗余）。从节约磁盘空间的角度来说，没有必要每个字段索引树都存具体数据，这种看似“多此一举”的步骤，在牺牲较少查询的性能下节省了巨大的磁盘空间，是非常值得的。</p>
<p>MyISAM 查询性能更好，MyISAM 直接找到物理地址后就可以直接定位到数据记录；InnoDB 查询到叶子节点后，还需再查询一次主键索引树，才能定位到具体数据。MyISAM 一步就查到了数据，但是 InnoDB 要两步，当然 MyISAM 查询性能更高。</p>
<p>总结一下何时需要给表里的字段加索引：</p>
<ol>
<li><p>较频繁的作为查询条件的字段应该创建索引</p>
</li>
<li><p>唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件</p>
</li>
<li><p>更新非常频繁的字段不适合创建索引</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx动静分离实例一</title>
    <url>/2020/04/17/Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%AE%9E%E4%BE%8B%E4%B8%80/</url>
    <content><![CDATA[<p>首先创建一个文件夹data，文件夹目录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data</span><br><span class="line">|</span><br><span class="line">|---image</span><br><span class="line">|     |---final.jpg</span><br><span class="line">|</span><br><span class="line">|---www</span><br><span class="line">      |---test.html</span><br></pre></td></tr></table></figure>
<p>接下来需要在 nginx.conf 进行动静分离的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        # 监听192.168.1.165：9080 这个服务器端口</span><br><span class="line">        listen       9080;</span><br><span class="line">        server_name  192.168.1.165;</span><br><span class="line"></span><br><span class="line">        location &#x2F;www&#x2F; &#123;</span><br><span class="line">            # 文件夹存储路径</span><br><span class="line">            root   C:&#x2F;Users&#x2F;qiany&#x2F;Desktop&#x2F;data&#x2F;;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location &#x2F;image&#x2F; &#123;</span><br><span class="line">            root   C:&#x2F;Users&#x2F;qiany&#x2F;Desktop&#x2F;data&#x2F;;</span><br><span class="line">            autoindex  on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/04/18/JeVykj.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/18/JeV2pq.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/18/JeVR10.png" alt="avatar"></p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx负载均衡实例一</title>
    <url>/2020/04/17/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%E4%B8%80/</url>
    <content><![CDATA[<h5 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h5><p>实现效果：在浏览器地址栏输入地址 <a href="http://192.168.1.165:8088/edu/" target="_blank" rel="noopener">http://192.168.1.165:8088/edu/</a> ,实现负载均衡效果，平均在8080和8081两个端口中。</p>
<p>首先使用Django新建两个项目server1和server2，并且分别添加一个index.html，端口号分别是8080和8081，index的路由都是edu/</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZbr8I.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZbgr8.png" alt="avatar"></p>
<p>接下来需要在 nginx.conf 进行负载均衡的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">		server 192.168.1.165:8080;</span><br><span class="line">		server 192.168.1.165:8081;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8088;</span><br><span class="line">        server_name  192.168.1.165;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">			proxy_pass  http:&#x2F;&#x2F;myserver;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们试着在浏览器里输入<a href="http://192.168.1.165:8088/edu/" target="_blank" rel="noopener">http://192.168.1.165:8088/edu/</a> ，试着多刷新几次，会发现界面来回跳转，说明负载均衡在8080和8081两个服务器上成功实现。</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZbjIJ.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZqPsK.png" alt="avatar"></p>
<h5 id="几种不同的负载均衡的实现方式"><a href="#几种不同的负载均衡的实现方式" class="headerlink" title="几种不同的负载均衡的实现方式"></a>几种不同的负载均衡的实现方式</h5><p>一. 轮询：默认的策略，把每个请求按顺序逐一分配到不同的server，如果server挂掉，能自动剔除。</p>
<p>二.权重：使用weight来指定server访问比率，weight默认是1。以下配置会是server2访问的比例是server1的两倍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　server 127.0.0.1:4501  weight&#x3D;1; #服务器A</span><br><span class="line">　　server 127.0.0.1:4502  weight&#x3D;2; #服务器B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三. 最少连接：把请求分配到连接数最少的server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　least_conn;</span><br><span class="line">　　server 127.0.0.1:4501; #真实服务器A(sxwgf-PC)</span><br><span class="line">　　server 127.0.0.1:4502; #真实服务器B(hzdk-vpc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四. ip_hash：每个请求会按照访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一server进行处理，可以解决session的问题。如果server挂掉，能自动剔除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　ip_hash;</span><br><span class="line">　　server 127.0.0.1:4501; #真实服务器A(sxwgf-PC)</span><br><span class="line">　　server 127.0.0.1:4502; #真实服务器B(hzdk-vpc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>五. fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　server 127.0.0.1:4501; #真实服务器A(sxwgf-PC)</span><br><span class="line">　　server 127.0.0.1:4502; #真实服务器B(hzdk-vpc)</span><br><span class="line">    fair</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理实例二</title>
    <url>/2020/04/17/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B%E4%BA%8C/</url>
    <content><![CDATA[<h5 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h5><p>实现效果：使用Nginx反向代理，根据访问的路径跳转到不同服务端口的服务中。<br>Nginx监听端口为9001<br>访问：<a href="http://127.0.0.1:9001/edu/" target="_blank" rel="noopener">http://127.0.0.1:9001/edu/</a> 直接跳转到127.0.0.1:8080<br>访问：<a href="http://127.0.0.1:9001/vod/" target="_blank" rel="noopener">http://127.0.0.1:9001/vod/</a> 直接跳转到127.0.0.1:8081</p>
<p>首先使用Django新建两个项目server1和server2，并且分别添加一个index.html，index的路由分别是edu/和vod/</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZhqSS.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZ4KfK.png" alt="avatar"></p>
<p>接下来需要在 nginx.conf 进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我们通过Django创建了两个项目，那么就是两个服务器，端口号分别是 8080 和 8081</span><br><span class="line"># Nginx通过监听 192.168.1.165:9001 这个端口，然后分别将 edu&#x2F; 和 vod&#x2F; 的 url 分发至服务器 127.0.0.1:8080 和 127.0.0.1:8081</span><br><span class="line"># location 使我们新加的一个字段</span><br><span class="line"># ‘~’ 用于表示URI包含正则表达式，并且区分大小写</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       9001;</span><br><span class="line">    server_name  192.168.1.165;</span><br><span class="line"></span><br><span class="line">    location ~ &#x2F;edu&#x2F; &#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ &#x2F;vod&#x2F; &#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8081;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们试着在浏览器里输入<a href="http://192.168.1.165:9001/edu/" target="_blank" rel="noopener">http://192.168.1.165:9001/edu/</a> 和 <a href="http://192.168.1.165:9001/vod/" target="_blank" rel="noopener">http://192.168.1.165:9001/vod/</a></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZ5iNt.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZ5E38.png" alt="avatar"></p>
<p>实验成功。</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理实例一</title>
    <url>/2020/04/16/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B%E4%B8%80/</url>
    <content><![CDATA[<p>我使用了Nginx + Django自带的服务器来进行反向代理的实例</p>
<p>首先新建一个Django项目，然后进入 settings 进行配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS = [<span class="string">'*'</span>,]</span><br></pre></td></tr></table></figure>
<p>然后启动Django，使用如下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
<p>因为我设置的服务器端的ip地址是：192.168.1.165，所以在浏览器输入 192.168.1.165：8000，可以看到Django启动页面</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JE8YZV.png" alt="avatar"></p>
<p>然后在本地的HOST文件进行ip映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.165 www.mydjango.com</span><br></pre></td></tr></table></figure>
<p>试着在浏览器输入 mydjango.com:8000</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JE8NIU.png" alt="avatar"></p>
<p>假如我们想通过 mydjango.com:80 来访问服务器，那么我们需要添加一个Nginx反向代理服务器，它通过监听 mydjango.com:80，然后将请求转发给目标服务器的8000端口。接下来配置nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我们找到server块</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.1.165; # 目标服务器的ip地址</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8000 # 反向代理的目标服务器</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mydjango.com</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/04/17/JE8RiD.png" alt="avatar"><br>成功访问。</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门</title>
    <url>/2020/04/16/Nginx%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h5 id="Nginx的介绍"><a href="#Nginx的介绍" class="headerlink" title="Nginx的介绍"></a>Nginx的介绍</h5><p>Nginx 是一个高性能的HTTP和反向代理web服务器。</p>
<p>其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</p>
<p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是<strong>占有内存少，并发能力强</strong>。中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<h5 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h5><p>一. 可以高并发连接：官方测试Nginx能够支撑5万并发连接。</p>
<p>二. 内存消耗少。</p>
<p>三. 成本低廉：购买F5BIG-IP、NetScaler等硬件负载均衡交换机，需要十多万到几十万人民币；Nginx为开源软件，可以免费试用并用于商业用途。</p>
<p>BSD开源协议可以自由使用、修改源代码、也可以将修改后的代码作为开源或专用软件再发布。</p>
<p>四. 配置文件非常简单。</p>
<p>五. 支持Rewrite重写：能够根据域名、URL的不同，将http请求分到不同的后端服务器群组。</p>
<p>六. 内置的健康检查功能：如果NginxProxy后端的某台Web服务器宕机了，不会影响前端的访问。</p>
<p>七. 稳定性高：用于反向代理，宕机的概率微乎其微。</p>
<p>八. 支持热部署：它的自动特别容易，几乎可以7天*24小时不间断的运行。即使运行数个月也无需重启，还能在不间断服务的情况下，升级软件版本。</p>
<h5 id="Nginx的相关特性"><a href="#Nginx的相关特性" class="headerlink" title="Nginx的相关特性"></a>Nginx的相关特性</h5><p><strong>正向代理</strong> ：是位于客户端和目标服务器之间的代理（中间）服务器。为了从目标服务器取得内容，客户端向代理服务器发送请求并指定目标服务器。代理服务器向目标服务器转交并且将获得的内容返回给客户端。</p>
<p>正向代理需要客户端进行一些设置才能使用。</p>
<p><img src="https://pic4.zhimg.com/v2-b2c357e187a1259829f0d08e1de16737_b.jpg" alt="avatar"></p>
<p><strong>反向代理</strong> ：客户端对代理服务器是无感知的，客户端无需任何配置。用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。反向代理服务器和目标服务器对外而言就是一个服务器，只暴露了代理服务器地址，隐藏了真实服务器的IP地址。</p>
<p><img src="https://pic2.zhimg.com/v2-7a3cf7885df57a322cab8c9d8dc25cc5_b.jpg" alt="avatar"></p>
<p><strong>负载均衡</strong> ：将原先请求集中到单个服务器上的情况改为增加服务器的数量。将请求分发到各个服务器上，将负载分发到不同的服务器，即负载均衡。</p>
<p><img src="https://pic2.zhimg.com/v2-744d9c94b3fcdebceab2ae1b7c7798e9_b.jpg" alt="avatar"></p>
<p><strong>动静分离</strong> ：为了加快网站的解析速度，把静态页面和动态页面由不同服务器解析，加快解析速度，降低单个服务器的压力。</p>
<p><img src="https://pic1.zhimg.com/v2-8257f63059cd86ff676d3e2e4a9d10d0_b.jpg" alt="avatar"></p>
<p><strong>高可用</strong> ：为了提高系统的可用性和容错能力，可以增加nginx服务器的数量，当主服务器发生故障或宕机，备份服务器可以立即充当主服务器进行不间断工作。</p>
<p><img src="https://pic1.zhimg.com/v2-d26d65f53f88cec4d7553637ca56cb00_b.jpg" alt="avatar"></p>
<h5 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h5><h6 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h6><p>Nginx 配置文件由全局块、events块和http块三部分组成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123;</span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN]</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一. 第一部分 全局块<br>主要设置一些影响 Nginx 服务器整体运行的配置指令。  比如： worker_processes 1; ， worker_processes 值越大，可以支持的并发处理量就越多。</p>
<p>二. 第二部分 events块<br>events 块涉及的指令主要影响Nginx服务器与用户的网络连接。  比如： worker_connections 1024; ，支持的最大连接数。</p>
<p>三. 第三部分 http块<br>http 块又包括 http 全局块和 server 块，是服务器配置中最频繁的部分，包括配置代理、缓存、日志定义等绝大多数功能。</p>
<p>server块：配置虚拟主机的相关参数。<br>location块：配置请求路由，以及各种页面的处理情况。</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程进阶</title>
    <url>/2020/03/24/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h5 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h5><p><code>threading.currentThread(): 返回当前的线程变量。</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(threading.currentThread)</span><br><span class="line">print(threading.current_thread)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;function current_thread at <span class="number">0x000001DB08FAE1F8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;function current_thread at <span class="number">0x000001DB08FAE1F8</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return a list of all Thread objects currently alive.</span></span><br><span class="line">print(threading.enumerate())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[&lt;_MainThread(MainThread, started <span class="number">24368</span>)&gt;]</span><br><span class="line"></span><br><span class="line">print(len(threading.enumerate()))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return the number of Thread objects currently alive.</span></span><br><span class="line">print(threading.activeCount())</span><br><span class="line">print(threading.active_count())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>线程模块还提供了Thread类来处理线程:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">run(): 表示线程活动的方法。</span><br><span class="line">start():启动线程活动。</span><br><span class="line">join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</span><br><span class="line">isAlive(): 返回线程是否活动。</span><br><span class="line">getName(): 返回线程名。</span><br><span class="line">setName(): 设置线程名。</span><br></pre></td></tr></table></figure>
<h5 id="自定义线程"><a href="#自定义线程" class="headerlink" title="自定义线程"></a>自定义线程</h5><p>继承threading.Thread自定义线程类，本质是重构Thread类中的run方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"task&#123;&#125;\n"</span>.format(self.n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'2s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'1s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'0s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"t1"</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">"t2"</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task t1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task t2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>s</span><br></pre></td></tr></table></figure>
<h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p><strong>守护线程的理解：</strong><br>守护线程是“不重要”的。“不重要”意味着如果<strong>它的主进程结束了但它没运行完，它会被强制结束。如果线程是非守护线程，那么父进程只有等到非守护线程运行完毕后再结束。</strong>  </p>
<p>在python中，线程通过<code>threadName.setDaemon(True|False)</code>来设置是否为守护线程。</p>
<p><strong>守护线程的作用：</strong>  </p>
<p>为其他线程提供便利服务，守护线程最典型的应用就是 GC (垃圾收集器)。</p>
<p><strong>守护线程的特点：</strong>  </p>
<p>如果主线程的任一非守护线程未结束，那么守护线程就全部工作；只有当全部非守护线程结束时，守护线程随主线程一同结束工作。</p>
<p>情况一：线程为非守护线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start fun"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end fun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main thread"</span>)</span><br><span class="line">    t1 = threading.Thread(target=fun)</span><br><span class="line">    t1.setDaemon(<span class="literal">False</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">"main thread end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>start fun</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>end fun</span><br></pre></td></tr></table></figure>
<p>说明程序在等待子线程结束再退出。  </p>
<p>情况二：线程为守护线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start fun"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end fun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main thread"</span>)</span><br><span class="line">    t1 = threading.Thread(target=fun)</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">"main thread end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>start fun</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread end</span><br></pre></td></tr></table></figure>
<p>说明程序在主线程结束后直接退出，子线程没有运行完。</p>
<h5 id="多线程共享全局变量"><a href="#多线程共享全局变量" class="headerlink" title="多线程共享全局变量"></a>多线程共享全局变量</h5><p>线程是进程的执行单元，进程是系统分配资源的最小单位。同一个进程中的多线程可以共享资源。</p>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>线程之间随机调度，多个线程同时修改同一数据时可能出现脏数据。如果没有很好地保护该对象，会造成程序结果的不可预期(“线程不安全”)。</p>
<p>线程锁：<strong>同一时刻只允许一个线程执行操作</strong>。线程锁用于锁定资源，<strong>我们可以定义多个锁, 当线程需要独占某一资源时，任何一个锁都可以锁资源，就好比用不同的锁都可以锁住相同的一个门。</strong></p>
<p>未使用线程锁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">my_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum1:&#123;&#125;"</span>.format(my_num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum2:&#123;&#125;"</span>.format(my_num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    first_thread = threading.Thread(target=sum1)</span><br><span class="line">    second_thread = threading.Thread(target=sum2)</span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum1:<span class="number">1014346</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum2:<span class="number">1071272</span></span><br></pre></td></tr></table></figure>
<p>互斥锁为资源引入一个状态：锁定/非锁定。</p>
<p>某个线程要更改共享数据时，先将其锁定，此时资源状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源状态变成“非锁定”，其他线程才能锁定该资源。<strong>互斥锁保证每次只有一个线程运行，保证了多线程情况下数据的正确性。</strong>    </p>
<p>当一个线程调用锁的<code>acquire()</code>获得锁时，锁进入“locked”状态。</p>
<p>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态(“阻塞”)。直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。</p>
<p>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">my_num = <span class="number">0</span>  <span class="comment"># 全局变量</span></span><br><span class="line">lock = threading.Lock()  <span class="comment"># 创建互斥锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum1:"</span>, my_num)</span><br><span class="line">    lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum2:"</span>, my_num)</span><br><span class="line">    lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    first_thread = threading.Thread(target=sum1)</span><br><span class="line">    second_thread = threading.Thread(target=sum2)</span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 互斥锁:能保证统一时刻只有一个线程执行，哪个线程抢到这个互斥锁我们决定不了，但能保证数据最终不会有问题</span></span><br><span class="line">    <span class="comment"># 加上互斥锁把多任务瞬间变成单任务，执行效率会下降。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum1:<span class="number">1000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum2:<span class="number">2000000</span></span><br></pre></td></tr></table></figure>
<p>锁的好处：</p>
<ol>
<li>确保了某段代码只由一个线程执行。</li>
</ol>
<p>锁的坏处：</p>
<ol>
<li>阻止了多线程并发执行，包含锁的代码实际上以单线程模式执行，效率下降。</li>
<li>由于可以存在多个锁，不同的线程持有不同的锁，当试图获取对方持有的锁时，可能造成死锁。</li>
</ol>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>举个生活中死锁的例子</p>
<ol>
<li>A拿了苹果</li>
<li>B拿了香蕉</li>
<li>A现在想拿香蕉，就等待B释放香蕉</li>
<li>B想拿苹果，就等待A释放苹果</li>
<li>AB陷入僵局(死锁)</li>
</ol>
<p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并同时等待对方释放资源，就会造成死锁。因为这部分资源都正在使用，所以这两个线程在无外力作用下将一直等待下去。下面是一个死锁的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock_apple = threading.Lock()</span><br><span class="line">lock_banana = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fun1()</span><br><span class="line">        self.fun2()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock_apple.acquire()  <span class="comment"># 如果锁被占用,则阻塞在这里,等待锁的释放</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line"></span><br><span class="line">        lock_banana.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line">        lock_banana.release()</span><br><span class="line"></span><br><span class="line">        lock_apple.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock_banana.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line"></span><br><span class="line">        lock_apple.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line">        lock_apple.release()</span><br><span class="line"></span><br><span class="line">        lock_banana.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):  <span class="comment">#建立10个线程</span></span><br><span class="line">        my_thread = MyThread()</span><br><span class="line">        my_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-1</span> , 想拿: 苹果</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-2</span> , 想拿: 苹果</span><br></pre></td></tr></table></figure>
<p>我们来看执行流程：</p>
<ol>
<li>fun1中，线程1先拿了苹果又拿了香蕉，然后释放香蕉和苹果.然后在在fun2中拿了香蕉。</li>
<li>在线程1执行时，线程2开始执行。苹果被线程1释放，线程2获得了苹果，然后想拿香蕉。</li>
<li>线程1拿完香蕉后想拿苹果，发现苹果被线程2拿到了；线程2拿完苹果后想拿香蕉，发现香蕉被线程1持有。</li>
<li>双向等待，出现死锁，代码执行不下去。</li>
</ol>
<p>上面就是大概的执行流程和死锁出现的原因。这就是同一线程中多次请求同一资源时候出现的问题。</p>
<h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>递归锁就是维护一个计数器。<strong>比如A线程获得一个锁,计数器+1；释放锁，计数器-1。如果计数器不为0，其他线程无法获得锁，只能等待。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock = threading.RLock()  <span class="comment">#递归锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fun1()</span><br><span class="line">        self.fun2()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock.acquire()  <span class="comment"># 如果锁被占用,则阻塞在这里,等待锁的释放</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line"></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):  <span class="comment">#建立10个线程</span></span><br><span class="line">        my_thread = MyThread()</span><br><span class="line">        my_thread.start()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 苹果</span><br></pre></td></tr></table></figure>
<h5 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h5><p>semaphore是一个内置的计数器</p>
<ol>
<li>调用<code>acquire()</code>，计数器-1</li>
<li>调用<code>release()</code>，计数器+1</li>
</ol>
<p>计数器不能小于0。当计数器为0时，<code>acquire()</code>将阻塞，直到其他线程调用<code>release()</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"ok &#123;&#125;\n"</span>.format(time.ctime()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t1 = threading.Thread(target=foo)</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>
<p>程序会在很短时间内生成10个线程来打印一句话。</p>
<p>如果在主机执行IO密集型任务的时候执行这类程序，主机很可能宕机。可以为程序添加计数器功能，来限制一个时间点内的线程数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">s1=threading.Semaphore(<span class="number">5</span>)	<span class="comment">#添加一个计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	s1.acquire()</span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line">	print(<span class="string">"ok&#123;&#125;\n"</span>.format(time.ctime()))</span><br><span class="line">	s1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	t1=threading.Thread(target=foo)</span><br><span class="line">	t1.start()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>
<h5 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set() — 全局内置标志Flag，将标志Flag 设置为 <span class="literal">True</span>,通知在等待状态(wait)的线程恢复运行;</span><br><span class="line"></span><br><span class="line">isSet() — 获取标志Flag当前状态，返回<span class="literal">True</span> 或者 <span class="literal">False</span>;</span><br><span class="line"></span><br><span class="line">wait() — 一旦调用，线程将会处于阻塞状态，直到等待其他线程调用set()函数恢复运行;</span><br><span class="line"></span><br><span class="line">clear() — 将标志设置为<span class="literal">False</span>；</span><br></pre></td></tr></table></figure>
<p>事件event中有一个全局内置标志Flag，值为 True 或者False。使用wait()函数的线程会处于阻塞状态,此时Flag指为False，直到有其他线程调用set()函数让全局标志Flag置为True，其阻塞的线程立刻恢复运行，还可以用isSet()函数检查当前的Flag状态.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建event事件</span></span><br><span class="line">eEvent = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_girl_friend</span><span class="params">(id)</span>:</span></span><br><span class="line">    print(<span class="string">"单身狗&#123;&#125;都准备完毕，Flag状态：&#123;&#125;\n"</span>.format(id,eEvent.isSet()))</span><br><span class="line">    eEvent.wait()</span><br><span class="line">    print(<span class="string">"单身狗&#123;&#125;告别单身\n"</span>.format(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    thread_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> id <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        t = threading.Thread(target=get_girl_friend,args=(id,))</span><br><span class="line">        t.start()</span><br><span class="line">        thread_list.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 所有线程准备完毕，将event内置Flag设置为True,恢复正在阻塞的线程</span></span><br><span class="line">    eEvent.set()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历列表，阻塞主线程</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        <span class="comment"># 阻塞主线程，等待所有子线程结束</span></span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">单身狗<span class="number">1</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">2</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">3</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">4</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">5</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">6</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">7</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">8</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">9</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">10</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">1</span>告别单身</span><br><span class="line">单身狗<span class="number">2</span>告别单身</span><br><span class="line">单身狗<span class="number">3</span>告别单身</span><br><span class="line">单身狗<span class="number">4</span>告别单身</span><br><span class="line">单身狗<span class="number">6</span>告别单身</span><br><span class="line">单身狗<span class="number">7</span>告别单身</span><br><span class="line">单身狗<span class="number">5</span>告别单身</span><br><span class="line">单身狗<span class="number">8</span>告别单身</span><br><span class="line">单身狗<span class="number">9</span>告别单身</span><br><span class="line">单身狗<span class="number">10</span>告别单身</span><br></pre></td></tr></table></figure>
<p>注意互斥锁Lock与事件Event区别，需求不同，使用方式也不同：</p>
<ol>
<li><p>互斥锁Lock主要针对多个线程同时操作同一个数据，使用互斥锁可以保证数据正常修改或者访问；</p>
</li>
<li><p>事件Event主要用于唤醒正在阻塞等待状态的线程;</p>
</li>
</ol>
<h5 id="线程优先级队列（Queue）"><a href="#线程优先级队列（Queue）" class="headerlink" title="线程优先级队列（Queue）"></a>线程优先级队列（Queue）</h5><p>Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。</p>
<p>这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p>
<p>Queue 模块中的常用方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Queue.qsize() 返回队列的大小</span><br><span class="line">Queue.empty() 如果队列为空，返回<span class="literal">True</span>,反之<span class="literal">False</span></span><br><span class="line">Queue.full() 如果队列满了，返回<span class="literal">True</span>,反之<span class="literal">False</span></span><br><span class="line">Queue.full 与 maxsize 大小对应</span><br><span class="line">Queue.get([block[, timeout]])获取队列，timeout等待时间</span><br><span class="line">Queue.get_nowait() 相当Queue.get(<span class="literal">False</span>)</span><br><span class="line">Queue.put(item) 写入队列，timeout等待时间</span><br><span class="line">Queue.put_nowait(item) 相当Queue.put(item, <span class="literal">False</span>)</span><br><span class="line">Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</span><br><span class="line">Queue.join() 实际上意味着等到队列为空，再执行别的操作</span><br></pre></td></tr></table></figure>
<h5 id="GIL（Global-Interpreter-Lock）全局解释器锁"><a href="#GIL（Global-Interpreter-Lock）全局解释器锁" class="headerlink" title="GIL（Global Interpreter Lock）全局解释器锁"></a>GIL（Global Interpreter Lock）全局解释器锁</h5><p>在非python环境中，单核CPU同时只能有一个任务执行。多核CPU支持多个线程同时执行。但在python中,无论CPU有多少核,同时只能执行一个线程。这是GIL导致的。</p>
<p>GIL：Global Interpreter Lock(全局解释器锁)，是python设计之初为了数据安全所做的决定。某个线程想要执行前，必须先拿到GIL(“通行证”)。在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许执行。GIL只在cpython中才有，因为cpython调用c语言的原生线程，所以它不直接操作cpu，只能利用GIL保证同一时间只有一个线程拿到数据。而在pypy和jpython中是没有GIL的。</p>
<p>Python多线程的工作过程：</p>
<p>python在使用多线程的时候，调用的是c语言的原生线程。</p>
<ol>
<li>拿到公共数据</li>
<li>申请GIL</li>
<li>python解释器调用os原生线程</li>
<li>os操作cpu执行运算</li>
<li>当该线程执行时间到后，无论运算是否执行完，GIL都被释放</li>
<li>其他线程重复上面的过程</li>
<li>等其他线程执行完后，又会切换到之前的线程（从他记录的上下文继续执行），整个过程是每个线程执行自己的运算，当执行时间到就进行切换。</li>
</ol>
<p>python针对不同类型的代码执行效率也是不同的：</p>
<ol>
<li>CPU密集型代码(各种循环处理、计算等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。</li>
<li>IO密集型代码(文件处理、网络爬虫等涉及文件读写的操作)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。</li>
</ol>
<p>使用建议:</p>
<p>python下想要充分利用多核CPU，就用多进程。因为每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。</p>
<p>GIL在python中的版本差异：</p>
<ol>
<li>在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100时进行释放。（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过sys.setcheckinterval 来调整）。而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。</li>
<li>在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程基础</title>
    <url>/2020/03/23/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>多线程是多个任务同时运行的一种方式</strong>。假设一个循环就是一个任务，我们希望第一次循环运行还没结束时，就能开始第二次循环，以此节省时间。</p>
<p>使用多线程的目的是最大化利用CPU的计算能力，利用等待的时间。如果程序耗时不是因为等待的时间，而是任务非常多，那么多线程无法改善运行时间。</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><p>先看下面这个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<p>运行10次<code>myfun()</code>，运行时间主要取决于每次<code>time.sleep(1)</code>，a的计算耗时可以忽略不计。这种情况可以用多线程提高效率。</p>
<p>不使用多线程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    myfun()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5.000431537628174</span></span><br></pre></td></tr></table></figure>
<p>使用多线程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br></pre></td></tr></table></figure>
<p>运行1秒后同时打印5个2，说明5次循环几乎同时运行。因为5次1秒的等待时间同时进行，所以最后只等待了1秒。</p>
<p>这里多线程包括了两步：</p>
<ol>
<li>Thread创建新线程，每一次循环创建新线程并执行<code>myfun()</code>。</li>
<li><code>start()</code>运行线程，每个线程都需要这样显式开启才会运行。一个线程开启后，无需等待它运行完成，就能继续向下运行，即下一次循环（然后又新建了第二个线程，运行未结束即开启第三个……）</li>
</ol>
<h5 id="join的使用"><a href="#join的使用" class="headerlink" title="join的使用"></a>join的使用</h5><p>线程的join()方法表示等这个线程运行完毕，程序再往下运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">    th.join()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5.0054051876068115</span></span><br></pre></td></tr></table></figure>
<p><code>start()</code>之后马上<code>join()</code>，表示每个线程都要运行结束才能进行下一次循环。这样就和单线程一样了。</p>
<p>未使用<code>join()</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.0019860267639160156</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">22</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>程序立即输出了结果，但5个2是在打印秒数之后才打印的。这是因为<code>print(time.time() - t)</code>是区别于5次循环线程外的第6个线程。它不会等待5个线程运行结束再开始运行，所以无法获得5个线程的运行时间，需要用<code>join()</code>等待5个线程都运行结束。</p>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line">ths = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">    ths.append(th)</span><br><span class="line"><span class="keyword">for</span> th <span class="keyword">in</span> ths:</span><br><span class="line">    th.join()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为 1.0038363933563232</span></span><br></pre></td></tr></table></figure>
<p>定义ths列表存储线程，最后用循环确保每一个线程都已经运行完成再计算时间差。</p>
<p><code>join()</code>不只适用于这种情形。当当前代码运行依赖之前代码运行完成时，就要加入<code>join()</code>命令。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程</title>
    <url>/2020/03/23/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>整理自<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376" target="_blank" rel="noopener">廖雪峰的官方网站——Python进程和线程</a>  </p>
<p><strong>现代操作系统都是支持“多任务”的操作系统。</strong></p>
<p>“多任务”是操作系统能同时运行多个任务。比如我们一边用浏览器上网，一边听MP3，一边用Word赶作业。这就是多任务，至少同时有3个任务在运行。还有很多任务悄悄地在后台同时运行，只是桌面上没有显示而已。</p>
<p>除了多核CPU，单核CPU也能执行多任务。由于CPU顺序执行代码，那单核CPU怎么执行多任务呢？</p>
<p>答案就是<strong>操作系统轮流让各个任务交替执行</strong>。任务1执行0.01秒，切换到任务2。任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行。每个任务交替执行，但CPU执行速度太快了，我们感觉就像所有任务都在同时执行。</p>
<p>真正的并行执行多任务只能在多核CPU上实现。因为任务数量远远多于CPU的核心数量，所以操作系统会自动把很多任务轮流调度到每个核心上执行。</p>
<p>对于操作系统来说，<strong>一个任务就是一个进程（Process）</strong>。打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还同时干很多事，比如Word，它可以同时进行打字、拼写检查、打印等事情。<strong>在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</strong></p>
<p><strong>由于每个进程至少要干一件事，所以一个进程至少有一个线程。</strong> 像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。真正地同时执行多线程需要多核CPU才可能实现。</p>
<p>平时编写的Python程序都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p>
<p>有三种解决方案：</p>
<ol>
<li><p>启动多个进程，每个进程只有一个线程，但多个进程一块执行多个任务。</p>
</li>
<li><p>启动一个进程，在一个进程内启动多个线程，多个线程一块执行多个任务。</p>
</li>
<li><p>启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了。这种模型更复杂，实际很少采用。</p>
</li>
</ol>
<p>总结一下就是，多任务的实现有3种方式：</p>
<ol>
<li><p>多进程模式；</p>
</li>
<li><p>多线程模式；</p>
</li>
<li><p>多进程+多线程模式。</p>
</li>
</ol>
<p>同时执行多个任务通常各个任务之间是有关联的，需要相互通信和协调。有时，任务1必须暂停等待任务2完成后才能继续执行；有时，任务3和任务4又不能同时执行。</p>
<p>多任务是必须的。例如在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频。否则单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频。</p>
<p>小结：</p>
<ol>
<li><p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定何时执行，执行多久。</p>
</li>
<li><p>多进程和多线程的程序涉及到同步、数据共享的问题，编写复杂。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>对可迭代对象、迭代器和生成器的理解</title>
    <url>/2020/03/23/%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h5 id="可迭代对象和迭代器"><a href="#可迭代对象和迭代器" class="headerlink" title="可迭代对象和迭代器"></a>可迭代对象和迭代器</h5><p>序列可以迭代的原因：<strong>iter</strong> 函数。Python解释器需要迭代对象 x 时，会自动调用 iter(x)。内置的 iter 函数作用如下：</p>
<ol>
<li><p>检查对象是否实现了 __ <strong>iter__</strong> 方法，实现了就调用它，获取一个迭代器。</p>
</li>
<li><p>没有实现 __ <strong>iter__</strong> 方法，但实现了 __ <strong>getitem__</strong> 方法，而且参数是从零开始的索引，Python会创建一个迭代器，尝试按顺序（从索引 0 开始）获取元素。</p>
</li>
<li><p>如果前两步都失败，Python抛出 TypeError 异常，通常会提示“C object is not iterable”，其中 C 是目标对象所属的类。</p>
</li>
</ol>
<p>由此可以明确可迭代对象（Iterable）： 使用 iter 内置函数可以获取迭代器（Iterator）的对象。即对象实现了能返回迭代器的 __ <strong>iter__</strong> 方法或实现了 __ <strong>getitem__</strong> 方法，而且其参数是从零开始的索引。</p>
<p>一个实现 __ <strong>getitem__</strong> 的demo：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.text[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o1 = Test(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o1:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>下面来看一个实现 __ <strong>iter__</strong> 的例子。因为用到了迭代器，所以先明确一下迭代器的用法。 标准的迭代器接口有两个方法：  </p>
<ol>
<li><p>__ <strong>next__</strong> ：返回下一个可用的元素，如果没有元素了就抛出 <strong>StopIteration</strong> 异常。</p>
</li>
<li><p>__ <strong>iter__</strong> ：返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如 for 循环。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Eg2Iterator(self.text) <span class="comment"># 获取一个迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg2Iterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            subtext = self.text[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> subtext</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o2 = Eg2(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o2:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>我们明确可迭代的对象和迭代器之间的关系：</p>
<ol>
<li><p>Python 从可迭代对象中获取迭代器。</p>
</li>
<li><p>__ <strong>iter__</strong> 方法从我们自己创建的迭代器类中获取迭代器，而__ <strong>getitem__</strong> 方法是python内部自动创建迭代器。</p>
</li>
</ol>
<p>我们来了解一下使用更符合 Python 的方式实现 Eg2类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg3</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.text:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o3 = Eg3(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o3:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>
<p>这里使用了 <strong>yield</strong> 关键字， 只要 Python 函数体中有 yield 关键字，该函数就是生成器函数。调用生成器函数时会返回一个生成器对象。也就是说生成器函数是生成器工厂。 上述代码还可以使用yield from进一步简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg3</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o3 = Eg3(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o3:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>还可以使用生成器表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg5</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (item <span class="keyword">for</span> item <span class="keyword">in</span> self.text) <span class="comment"># 生成器表达式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o5 = Eg5(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o5:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><p>可迭代对象（Iterable）要么实现了能返回迭代器的 __ <strong>iter__</strong> 方法，要么实现了 __ <strong>getitem__</strong> 方法而且其参数是从零开始的索引。</p>
</li>
<li><p>迭代器（Iterator）是这样的对象：实现了无参数的 __ <strong>next__</strong> 方法，返回下一个元素，如果没有元素就抛出 StopIteration 异常；并且实现 __ <strong>iter__</strong> 方法，返回迭代器本身。</p>
</li>
<li><p>生成器是带有 yield 关键字的函数。调用生成器函数时，会返回一个生成器对象。</p>
</li>
<li><p>生成器表达式是创建生成器的简洁句法，这样无需先定义函数再调用。</p>
</li>
<li><p>什么是迭代器模式？按需一次获取一个数据项。</p>
</li>
<li><p>生成器和迭代器有什么不同？</p>
<p>相同点：所有生成器都是迭代器，因为生成器完全实现了迭代器接口。</p>
<p>不同点：迭代器用于从集合中取出元素；生成器用于凭空生成元素。</p>
</li>
</ol>
<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>迭代是处理大量数据的好方法。以列表为例，迭代存在两个问题。第一，列表中的元素太多将大量占用内存。第二，我们有时候只需要使用一次数据，如果用列表把数据全部保存起来，将会造成内存浪费。</p>
<p>生成器是创建迭代器的工具。它们像常规函数一样撰写，但是在需要返回数据时使用yield语句。每当对它调用next()函数，生成器从它上次停止的地方重新开始（它会记住所有的数据值和上次执行的语句）。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的property动态属性</title>
    <url>/2020/03/21/Python%E7%9A%84property%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>我们首先定义一个User类，包含两个属性 name 和 birthday</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br></pre></td></tr></table></figure>
<p>如果想获得User实例的年龄，我们可以定义一个方法，然后使用函数调用的方式获得年龄。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br></pre></td></tr></table></figure>
<p>举例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User(<span class="string">"zqy"</span>, date(year=<span class="number">1997</span>, month=<span class="number">6</span>, day=<span class="number">15</span>))</span><br><span class="line">    print(user.get_age()) <span class="comment"># 返回23</span></span><br></pre></td></tr></table></figure>
<p>如果我们想使用调用属性的方式获得年龄（user.age），那么就可以使用property装饰器。<br>为了区别上面的代码，以下是完整的使用property装饰器的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" 将函数调用装饰成属性调用 """</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(<span class="string">"zqy"</span>, date(year=<span class="number">1997</span>, month=<span class="number">6</span>, day=<span class="number">15</span>))</span><br><span class="line">    print(user.age)</span><br></pre></td></tr></table></figure>
<p>我们并没有定义age属性，但是通过property装饰器装饰的age函数，可以直接通过实例调用函数名的方式，作为一个属性返回。<br>那么setter装饰器又是什么呢？  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br><span class="line">        self._age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" 取函数调用的模式编程取属性调用 """</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._age = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(<span class="string">"zqy"</span>, date(year=<span class="number">1997</span>, month=<span class="number">6</span>, day=<span class="number">15</span>))</span><br><span class="line">    user.age = <span class="number">30</span></span><br><span class="line">    print(user._age) <span class="comment"># 30</span></span><br><span class="line">    print(user.age) <span class="comment"># 23</span></span><br></pre></td></tr></table></figure>
<p>1、只有 @property 表示只读。<br>2、同时有 @property 和 @*.setter 表示可读可写。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>

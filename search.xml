<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx动静分离实例一</title>
    <url>/2020/04/17/Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%AE%9E%E4%BE%8B%E4%B8%80/</url>
    <content><![CDATA[<p>首先创建一个文件夹data，文件夹目录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data</span><br><span class="line">|</span><br><span class="line">|---image</span><br><span class="line">|     |---final.jpg</span><br><span class="line">|</span><br><span class="line">|---www</span><br><span class="line">      |---test.html</span><br></pre></td></tr></table></figure>
<p>接下来需要在 nginx.conf 进行动静分离的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        # 监听192.168.1.165：9080 这个服务器端口</span><br><span class="line">        listen       9080;</span><br><span class="line">        server_name  192.168.1.165;</span><br><span class="line"></span><br><span class="line">        location &#x2F;www&#x2F; &#123;</span><br><span class="line">            # 文件夹存储路径</span><br><span class="line">            root   C:&#x2F;Users&#x2F;qiany&#x2F;Desktop&#x2F;data&#x2F;;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location &#x2F;image&#x2F; &#123;</span><br><span class="line">            root   C:&#x2F;Users&#x2F;qiany&#x2F;Desktop&#x2F;data&#x2F;;</span><br><span class="line">            autoindex  on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/04/18/JeVykj.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/18/JeV2pq.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/18/JeVR10.png" alt="avatar"></p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx负载均衡实例一</title>
    <url>/2020/04/17/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%E4%B8%80/</url>
    <content><![CDATA[<h5 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h5><p>实现效果：在浏览器地址栏输入地址 <a href="http://192.168.1.165:8088/edu/" target="_blank" rel="noopener">http://192.168.1.165:8088/edu/</a> ,实现负载均衡效果，平均在8080和8081两个端口中。</p>
<p>首先使用Django新建两个项目server1和server2，并且分别添加一个index.html，端口号分别是8080和8081，index的路由都是edu/</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZbr8I.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZbgr8.png" alt="avatar"></p>
<p>接下来需要在 nginx.conf 进行负载均衡的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">		server 192.168.1.165:8080;</span><br><span class="line">		server 192.168.1.165:8081;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8088;</span><br><span class="line">        server_name  192.168.1.165;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">			proxy_pass  http:&#x2F;&#x2F;myserver;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们试着在浏览器里输入<a href="http://192.168.1.165:8088/edu/" target="_blank" rel="noopener">http://192.168.1.165:8088/edu/</a> ，试着多刷新几次，会发现界面来回跳转，说明负载均衡在8080和8081两个服务器上成功实现。</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZbjIJ.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZqPsK.png" alt="avatar"></p>
<h5 id="几种不同的负载均衡的实现方式"><a href="#几种不同的负载均衡的实现方式" class="headerlink" title="几种不同的负载均衡的实现方式"></a>几种不同的负载均衡的实现方式</h5><p>一. 轮询：默认的策略，把每个请求按顺序逐一分配到不同的server，如果server挂掉，能自动剔除。</p>
<p>二.权重：使用weight来指定server访问比率，weight默认是1。以下配置会是server2访问的比例是server1的两倍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　server 127.0.0.1:4501  weight&#x3D;1; #服务器A</span><br><span class="line">　　server 127.0.0.1:4502  weight&#x3D;2; #服务器B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三. 最少连接：把请求分配到连接数最少的server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　least_conn;</span><br><span class="line">　　server 127.0.0.1:4501; #真实服务器A(sxwgf-PC)</span><br><span class="line">　　server 127.0.0.1:4502; #真实服务器B(hzdk-vpc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四. ip_hash：每个请求会按照访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一server进行处理，可以解决session的问题。如果server挂掉，能自动剔除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　ip_hash;</span><br><span class="line">　　server 127.0.0.1:4501; #真实服务器A(sxwgf-PC)</span><br><span class="line">　　server 127.0.0.1:4502; #真实服务器B(hzdk-vpc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>五. fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream a.com&#123;</span><br><span class="line">　　server 127.0.0.1:4501; #真实服务器A(sxwgf-PC)</span><br><span class="line">　　server 127.0.0.1:4502; #真实服务器B(hzdk-vpc)</span><br><span class="line">    fair</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理实例二</title>
    <url>/2020/04/17/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B%E4%BA%8C/</url>
    <content><![CDATA[<h5 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h5><p>实现效果：使用Nginx反向代理，根据访问的路径跳转到不同服务端口的服务中。<br>Nginx监听端口为9001<br>访问：<a href="http://127.0.0.1:9001/edu/" target="_blank" rel="noopener">http://127.0.0.1:9001/edu/</a> 直接跳转到127.0.0.1:8080<br>访问：<a href="http://127.0.0.1:9001/vod/" target="_blank" rel="noopener">http://127.0.0.1:9001/vod/</a> 直接跳转到127.0.0.1:8081</p>
<p>首先使用Django新建两个项目server1和server2，并且分别添加一个index.html，index的路由分别是edu/和vod/</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZhqSS.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZ4KfK.png" alt="avatar"></p>
<p>接下来需要在 nginx.conf 进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我们通过Django创建了两个项目，那么就是两个服务器，端口号分别是 8080 和 8081</span><br><span class="line"># Nginx通过监听 192.168.1.165:9001 这个端口，然后分别将 edu&#x2F; 和 vod&#x2F; 的 url 分发至服务器 127.0.0.1:8080 和 127.0.0.1:8081</span><br><span class="line"># location 使我们新加的一个字段</span><br><span class="line"># ‘~’ 用于表示URI包含正则表达式，并且区分大小写</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       9001;</span><br><span class="line">    server_name  192.168.1.165;</span><br><span class="line"></span><br><span class="line">    location ~ &#x2F;edu&#x2F; &#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ &#x2F;vod&#x2F; &#123;</span><br><span class="line">      proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8081;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们试着在浏览器里输入<a href="http://192.168.1.165:9001/edu/" target="_blank" rel="noopener">http://192.168.1.165:9001/edu/</a> 和 <a href="http://192.168.1.165:9001/vod/" target="_blank" rel="noopener">http://192.168.1.165:9001/vod/</a></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZ5iNt.png" alt="avatar"></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JZ5E38.png" alt="avatar"></p>
<p>实验成功。</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理实例一</title>
    <url>/2020/04/16/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B%E4%B8%80/</url>
    <content><![CDATA[<p>我使用了Nginx + Django自带的服务器来进行反向代理的实例</p>
<p>首先新建一个Django项目，然后进入 settings 进行配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS = [<span class="string">'*'</span>,]</span><br></pre></td></tr></table></figure>
<p>然后启动Django，使用如下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
<p>因为我设置的服务器端的ip地址是：192.168.1.165，所以在浏览器输入 192.168.1.165：8000，可以看到Django启动页面</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JE8YZV.png" alt="avatar"></p>
<p>然后在本地的HOST文件进行ip映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.165 www.mydjango.com</span><br></pre></td></tr></table></figure>
<p>试着在浏览器输入 mydjango.com:8000</p>
<p><img src="https://s1.ax1x.com/2020/04/17/JE8NIU.png" alt="avatar"></p>
<p>假如我们想通过 mydjango.com:80 来访问服务器，那么我们需要添加一个Nginx反向代理服务器，它通过监听 mydjango.com:80，然后将请求转发给目标服务器的8000端口。接下来配置nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我们找到server块</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.1.165; # 目标服务器的ip地址</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8000 # 反向代理的目标服务器</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mydjango.com</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/04/17/JE8RiD.png" alt="avatar"><br>成功访问。</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门</title>
    <url>/2020/04/16/Nginx%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h5 id="Nginx的介绍"><a href="#Nginx的介绍" class="headerlink" title="Nginx的介绍"></a>Nginx的介绍</h5><p>Nginx 是一个高性能的HTTP和反向代理web服务器。</p>
<p>其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</p>
<p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是<strong>占有内存少，并发能力强</strong>。中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<h5 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h5><p>一. 可以高并发连接：官方测试Nginx能够支撑5万并发连接。</p>
<p>二. 内存消耗少。</p>
<p>三. 成本低廉：购买F5BIG-IP、NetScaler等硬件负载均衡交换机，需要十多万到几十万人民币；Nginx为开源软件，可以免费试用并用于商业用途。</p>
<p>BSD开源协议可以自由使用、修改源代码、也可以将修改后的代码作为开源或专用软件再发布。</p>
<p>四. 配置文件非常简单。</p>
<p>五. 支持Rewrite重写：能够根据域名、URL的不同，将http请求分到不同的后端服务器群组。</p>
<p>六. 内置的健康检查功能：如果NginxProxy后端的某台Web服务器宕机了，不会影响前端的访问。</p>
<p>七. 稳定性高：用于反向代理，宕机的概率微乎其微。</p>
<p>八. 支持热部署：它的自动特别容易，几乎可以7天*24小时不间断的运行。即使运行数个月也无需重启，还能在不间断服务的情况下，升级软件版本。</p>
<h5 id="Nginx的相关特性"><a href="#Nginx的相关特性" class="headerlink" title="Nginx的相关特性"></a>Nginx的相关特性</h5><p><strong>正向代理</strong> ：是位于客户端和目标服务器之间的代理（中间）服务器。为了从目标服务器取得内容，客户端向代理服务器发送请求并指定目标服务器。代理服务器向目标服务器转交并且将获得的内容返回给客户端。</p>
<p>正向代理需要客户端进行一些设置才能使用。</p>
<p><img src="https://pic4.zhimg.com/v2-b2c357e187a1259829f0d08e1de16737_b.jpg" alt="avatar"></p>
<p><strong>反向代理</strong> ：客户端对代理服务器是无感知的，客户端无需任何配置。用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。反向代理服务器和目标服务器对外而言就是一个服务器，只暴露了代理服务器地址，隐藏了真实服务器的IP地址。</p>
<p><img src="https://pic2.zhimg.com/v2-7a3cf7885df57a322cab8c9d8dc25cc5_b.jpg" alt="avatar"></p>
<p><strong>负载均衡</strong> ：将原先请求集中到单个服务器上的情况改为增加服务器的数量。将请求分发到各个服务器上，将负载分发到不同的服务器，即负载均衡。</p>
<p><img src="https://pic2.zhimg.com/v2-744d9c94b3fcdebceab2ae1b7c7798e9_b.jpg" alt="avatar"></p>
<p><strong>动静分离</strong> ：为了加快网站的解析速度，把静态页面和动态页面由不同服务器解析，加快解析速度，降低单个服务器的压力。</p>
<p><img src="https://pic1.zhimg.com/v2-8257f63059cd86ff676d3e2e4a9d10d0_b.jpg" alt="avatar"></p>
<p><strong>高可用</strong> ：为了提高系统的可用性和容错能力，可以增加nginx服务器的数量，当主服务器发生故障或宕机，备份服务器可以立即充当主服务器进行不间断工作。</p>
<p><img src="https://pic1.zhimg.com/v2-d26d65f53f88cec4d7553637ca56cb00_b.jpg" alt="avatar"></p>
<h5 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h5><h6 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h6><p>Nginx 配置文件由全局块、events块和http块三部分组成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123;</span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN]</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一. 第一部分 全局块<br>主要设置一些影响 Nginx 服务器整体运行的配置指令。  比如： worker_processes 1; ， worker_processes 值越大，可以支持的并发处理量就越多。</p>
<p>二. 第二部分 events块<br>events 块涉及的指令主要影响Nginx服务器与用户的网络连接。  比如： worker_connections 1024; ，支持的最大连接数。</p>
<p>三. 第三部分 http块<br>http 块又包括 http 全局块和 server 块，是服务器配置中最频繁的部分，包括配置代理、缓存、日志定义等绝大多数功能。</p>
<p>server块：配置虚拟主机的相关参数。<br>location块：配置请求路由，以及各种页面的处理情况。</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>百度翻译PythonAPI的简单使用</title>
    <url>/2020/04/12/%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91PythonAPI%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>美国疫情一天比一天严重了，回国的计划也被打乱了。现在有大把的时间来写一写Python简单的小demo来娱乐一下。  </p>
<p>百度翻译API链接：<a href="http://api.fanyi.baidu.com/doc/21" target="_blank" rel="noopener">http://api.fanyi.baidu.com/doc/21</a></p>
<p>下面是官方给的Python3的demo</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#百度通用翻译API,不包含词典、tts语音合成等资源，如有相关需求请联系translate_api@baidu.com</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">appid = <span class="string">''</span>  <span class="comment"># 填写你的appid</span></span><br><span class="line">secretKey = <span class="string">''</span>  <span class="comment"># 填写你的密钥</span></span><br><span class="line"></span><br><span class="line">httpClient = <span class="literal">None</span></span><br><span class="line">myurl = <span class="string">'/api/trans/vip/translate'</span></span><br><span class="line"></span><br><span class="line">fromLang = <span class="string">'auto'</span>   <span class="comment">#原文语种</span></span><br><span class="line">toLang = <span class="string">'zh'</span>   <span class="comment">#译文语种</span></span><br><span class="line">salt = random.randint(<span class="number">32768</span>, <span class="number">65536</span>)</span><br><span class="line">q= <span class="string">'apple'</span></span><br><span class="line">sign = appid + q + str(salt) + secretKey</span><br><span class="line">sign = hashlib.md5(sign.encode()).hexdigest()</span><br><span class="line">myurl = myurl + <span class="string">'?appid='</span> + appid + <span class="string">'&amp;q='</span> + urllib.parse.quote(q) + <span class="string">'&amp;from='</span> + fromLang + <span class="string">'&amp;to='</span> + toLang + <span class="string">'&amp;salt='</span> + str(</span><br><span class="line">salt) + <span class="string">'&amp;sign='</span> + sign</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    httpClient = http.client.HTTPConnection(<span class="string">'api.fanyi.baidu.com'</span>)</span><br><span class="line">    httpClient.request(<span class="string">'GET'</span>, myurl)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># response是HTTPResponse对象</span></span><br><span class="line">    response = httpClient.getresponse()</span><br><span class="line">    result_all = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    result = json.loads(result_all)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">print</span> (e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> httpClient:</span><br><span class="line">        httpClient.close()</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'from'</span>: <span class="string">'en'</span>, <span class="string">'to'</span>: <span class="string">'zh'</span>, <span class="string">'trans_result'</span>: [&#123;<span class="string">'src'</span>: <span class="string">'apple'</span>, <span class="string">'dst'</span>: <span class="string">'苹果'</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>简单地用面向对象方式改写一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaiduTranslate</span>:</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, q)</span>:</span></span><br><span class="line">       self.q = q</span><br><span class="line">       self.__appid = <span class="string">''</span>  <span class="comment"># appid</span></span><br><span class="line">       self.__secretKey = <span class="string">''</span>  <span class="comment"># 密钥</span></span><br><span class="line">       self.__myurl = <span class="string">"http://api.fanyi.baidu.com/api/trans/vip/translate"</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">       fromLang = <span class="string">'auto'</span>  <span class="comment"># 原文语种</span></span><br><span class="line">       toLang = <span class="string">'zh'</span>  <span class="comment"># 译文语种</span></span><br><span class="line">       salt = random.randint(<span class="number">32768</span>, <span class="number">65536</span>)  <span class="comment"># 随机数</span></span><br><span class="line">       sign = self.__appid + self.q + str(salt) + self.__secretKey</span><br><span class="line">       sign = hashlib.md5(sign.encode()).hexdigest()  <span class="comment"># "appid+q+salt+密钥 的MD5值"</span></span><br><span class="line"></span><br><span class="line">       params = &#123;<span class="string">'appid'</span>: self.__appid, <span class="string">'q'</span>: self.q, <span class="string">'from'</span>: fromLang, <span class="string">'to'</span>: toLang, <span class="string">'salt'</span>: salt, <span class="string">'sign'</span>: sign&#125;</span><br><span class="line">       r = requests.get(self.__myurl, params=params)</span><br><span class="line">       print(r.url)</span><br><span class="line">       dict_json = json.loads(r.content.decode())</span><br><span class="line">       print(<span class="string">"查询的英文单词: "</span>, dict_json[<span class="string">'trans_result'</span>][<span class="number">0</span>][<span class="string">'src'</span>])</span><br><span class="line">       print(<span class="string">"结果为: "</span>, dict_json[<span class="string">'trans_result'</span>][<span class="number">0</span>][<span class="string">'dst'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   bt = BaiduTranslate(<span class="string">'sunflower'</span>)</span><br><span class="line">   bt.run()</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>查询的英文单词:  sunflower</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>结果为:  向日葵</span><br></pre></td></tr></table></figure>
<p>难度系数为0，非常简单。之所以选择官方的api是因为我爬网页版的百度翻译爬不到了，具体原因之后有时间会解决。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程进阶</title>
    <url>/2020/03/24/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h5 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.currentThread(): 返回当前的线程变量。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(threading.currentThread)</span><br><span class="line">print(threading.current_thread)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;function current_thread at <span class="number">0x000001DB08FAE1F8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;function current_thread at <span class="number">0x000001DB08FAE1F8</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return a list of all Thread objects currently alive.</span></span><br><span class="line">print(threading.enumerate())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[&lt;_MainThread(MainThread, started <span class="number">24368</span>)&gt;]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return the number of Thread objects currently alive.</span></span><br><span class="line">print(threading.activeCount())</span><br><span class="line">print(threading.active_count())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>线程模块还提供了Thread类来处理线程:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">run(): 表示线程活动的方法。</span><br><span class="line">start():启动线程活动。</span><br><span class="line">join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</span><br><span class="line">isAlive(): 返回线程是否活动。</span><br><span class="line">getName(): 返回线程名。</span><br><span class="line">setName(): 设置线程名。</span><br></pre></td></tr></table></figure>
<h5 id="自定义线程"><a href="#自定义线程" class="headerlink" title="自定义线程"></a>自定义线程</h5><p>继承threading.Thread来自定义线程类，本质是重构Thread类中的run方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)<span class="comment"># 重构run函数必须要写</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"task&#123;&#125;\n"</span>.format(self.n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'2s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'1s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'0s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"t1"</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">"t2"</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task t1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>task t2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>s</span><br></pre></td></tr></table></figure>
<h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p><strong>守护线程的理解：</strong>  </p>
<p>如果当前线程是守护线程，那么此线程就是“不重要”的。“不重要”意味着如果<strong>它的主进程结束了但该守护线程没有运行完，守护进程就会被强制结束。如果线程是非守护线程，那么父进程只有等到守护线程运行完毕后才能结束。</strong>  </p>
<p>在python中，线程通过threadName.setDaemon(True|False)来设置是否为守护线程。</p>
<p><strong>守护线程的作用：</strong>  </p>
<p>为其他线程提供便利服务，守护线程最典型的应用就是 GC (垃圾收集器)。</p>
<p><strong>守护线程的特点：</strong>  </p>
<p>如果主线程的任一非守护线程未结束，那么守护线程就全部工作；只有当全部非守护线程结束时，守护线程随主线程一同结束工作。</p>
<p>情况一：线程为非守护线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start fun"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end fun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main thread"</span>)</span><br><span class="line">    t1 = threading.Thread(target=fun)</span><br><span class="line">    t1.setDaemon(<span class="literal">False</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">"main thread end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>start fun</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>end fun</span><br></pre></td></tr></table></figure>
<p>说明程序在等待子线程结束再退出。  </p>
<p>情况二：线程为守护线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start fun"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end fun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main thread"</span>)</span><br><span class="line">    t1 = threading.Thread(target=fun)</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">"main thread end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>start fun</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main thread end</span><br></pre></td></tr></table></figure>
<p>说明程序在主线程结束后直接退出，子线程没有运行完。</p>
<h5 id="多线程共享全局变量"><a href="#多线程共享全局变量" class="headerlink" title="多线程共享全局变量"></a>多线程共享全局变量</h5><p>线程是进程的执行单元，进程是系统分配资源的最小单位。同一个进程中的多线程可以共享资源。</p>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>线程之间是随机调度，多个线程同时修改同一数据时可能出现脏数据。如果没有很好地保护该对象，会造成程序结果的不可预期(“线程不安全”)。</p>
<p>线程锁：<strong>同一时刻只允许一个线程执行操作</strong>。线程锁用于锁定资源，<strong>我们可以定义多个锁, 当线程需要独占某一资源时，任何一个锁都可以锁资源，就好比用不同的锁都可以锁住相同的一个门。</strong></p>
<p>未使用线程锁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">my_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum1:&#123;&#125;"</span>.format(my_num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum2:&#123;&#125;"</span>.format(my_num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    first_thread = threading.Thread(target=sum1)</span><br><span class="line">    second_thread = threading.Thread(target=sum2)</span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum1:<span class="number">1014346</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum2:<span class="number">1071272</span></span><br></pre></td></tr></table></figure>
<p>互斥锁为资源引入一个状态：锁定/非锁定。</p>
<p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他线程才能锁定该资源。<strong>互斥锁保证每次只有一个线程运行，保证了多线程情况下数据的正确性。</strong>    </p>
<p>当一个线程调用锁的acquire()方法获得锁时，锁进入“locked”状态。</p>
<p>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态(“阻塞”)。直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。</p>
<p>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">my_num = <span class="number">0</span>  <span class="comment"># 全局变量</span></span><br><span class="line">lock = threading.Lock()  <span class="comment"># 创建互斥锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum1:"</span>, my_num)</span><br><span class="line">    lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环给全局变量每次加上1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">    <span class="keyword">global</span> my_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        my_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"sum2:"</span>, my_num)</span><br><span class="line">    lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    first_thread = threading.Thread(target=sum1)</span><br><span class="line">    second_thread = threading.Thread(target=sum2)</span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 互斥锁:能保证统一时刻只有一个线程执行，哪个线程抢到这个互斥锁我们决定不了，但能保证数据最终不会有问题</span></span><br><span class="line">    <span class="comment"># 加上互斥锁把多任务瞬间变成单任务，执行效率会下降。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum1:<span class="number">1000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum2:<span class="number">2000000</span></span><br></pre></td></tr></table></figure>
<p>锁的好处：</p>
<ol>
<li>确保了某段代码只由一个线程执行。</li>
</ol>
<p>锁的坏处：</p>
<ol>
<li>阻止了多线程并发执行，包含锁的代码实际上以单线程模式执行，效率下降。</li>
<li>由于可以存在多个锁，不同的线程持有不同的锁，当试图获取对方持有的锁时，可能造成死锁。</li>
</ol>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>举个生活中死锁的例子</p>
<ol>
<li>A拿了苹果</li>
<li>B拿了香蕉</li>
<li>A现在想拿香蕉，就等待B释放香蕉</li>
<li>B想拿苹果，就等待A释放苹果</li>
<li>AB陷入僵局(死锁)</li>
</ol>
<p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并同时等待对方释放资源，就会造成死锁。因为这部分资源都正在使用，所以这两个线程在无外力作用下将一直等待下去。下面是一个死锁的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock_apple = threading.Lock()</span><br><span class="line">lock_banana = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fun1()</span><br><span class="line">        self.fun2()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock_apple.acquire()  <span class="comment"># 如果锁被占用,则阻塞在这里,等待锁的释放</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line"></span><br><span class="line">        lock_banana.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line">        lock_banana.release()</span><br><span class="line"></span><br><span class="line">        lock_apple.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock_banana.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line"></span><br><span class="line">        lock_apple.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line">        lock_apple.release()</span><br><span class="line"></span><br><span class="line">        lock_banana.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):  <span class="comment">#建立10个线程</span></span><br><span class="line">        my_thread = MyThread()</span><br><span class="line">        my_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-1</span> , 想拿: 苹果</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>线程 Thread<span class="number">-2</span> , 想拿: 苹果</span><br></pre></td></tr></table></figure>
<p>我们来看执行流程：</p>
<ol>
<li>fun1中，线程1先拿了苹果又拿了香蕉，然后释放香蕉和苹果.然后在在fun2中拿了香蕉。</li>
<li>在线程1执行时，线程2开始执行。苹果被线程1释放，线程2获得了苹果，然后想拿香蕉。</li>
<li>线程1拿完香蕉后想拿苹果，发现苹果被线程2拿到了；线程2拿完苹果后想拿香蕉，发现香蕉被线程1持有。</li>
<li>双向等待，出现死锁，代码执行不下去。</li>
</ol>
<p>上面就是大概的执行流程和死锁出现的原因。这就是同一线程中多次请求同一资源时候出现的问题。</p>
<h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>递归锁就是维护一个计数器。<strong>比如A线程获得一个锁,计数器+1；释放锁，计数器-1。如果计数器不为0，其他线程无法获得锁，只能等待。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock = threading.RLock()  <span class="comment">#递归锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fun1()</span><br><span class="line">        self.fun2()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock.acquire()  <span class="comment"># 如果锁被占用,则阻塞在这里,等待锁的释放</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line"></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"香蕉"</span>))</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"线程 %s , 想拿: %s"</span> %(self.name, <span class="string">"苹果"</span>))</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):  <span class="comment">#建立10个线程</span></span><br><span class="line">        my_thread = MyThread()</span><br><span class="line">        my_thread.start()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-1</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-2</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-4</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-6</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-8</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-10</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-5</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-9</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-7</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 苹果</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 香蕉</span><br><span class="line">线程 Thread<span class="number">-3</span> , 想拿: 苹果</span><br></pre></td></tr></table></figure>
<h5 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h5><p>semaphore是一个内置的计数器</p>
<ol>
<li>调用acquire()，计数器-1</li>
<li>调用release()，计数器+1</li>
</ol>
<p>计数器不能小于0。当计数器为0时，acquire()将阻塞，直到其他线程调用release()。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"ok &#123;&#125;\n"</span>.format(time.ctime()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t1 = threading.Thread(target=foo)</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br><span class="line">ok Tue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">19</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>
<p>程序会在很短时间内生成10个线程来打印一句话。</p>
<p>如果在主机执行IO密集型任务的时候执行这类程序，主机很可能宕机。可以为程序添加计数器功能，来限制一个时间点内的线程数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">s1=threading.Semaphore(<span class="number">5</span>)	<span class="comment">#添加一个计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">	s1.acquire()</span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line">	print(<span class="string">"ok&#123;&#125;\n"</span>.format(time.ctime()))</span><br><span class="line">	s1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	t1=threading.Thread(target=foo)</span><br><span class="line">	t1.start()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">57</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br><span class="line">okTue Mar <span class="number">24</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">59</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>
<h5 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set() — 全局内置标志Flag，将标志Flag 设置为 <span class="literal">True</span>,通知在等待状态(wait)的线程恢复运行;</span><br><span class="line"></span><br><span class="line">isSet() — 获取标志Flag当前状态，返回<span class="literal">True</span> 或者 <span class="literal">False</span>;</span><br><span class="line"></span><br><span class="line">wait() — 一旦调用，线程将会处于阻塞状态，直到等待其他线程调用set()函数恢复运行;</span><br><span class="line"></span><br><span class="line">clear() — 将标志设置为<span class="literal">False</span>；</span><br></pre></td></tr></table></figure>
<p>事件event中有一个全局内置标志Flag，值为 True 或者False。使用wait()函数的线程会处于阻塞状态,此时Flag指为False，直到有其他线程调用set()函数让全局标志Flag置为True，其阻塞的线程立刻恢复运行，还可以用isSet()函数检查当前的Flag状态.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建event事件</span></span><br><span class="line">eEvent = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_girl_friend</span><span class="params">(id)</span>:</span></span><br><span class="line">    print(<span class="string">"单身狗&#123;&#125;都准备完毕，Flag状态：&#123;&#125;\n"</span>.format(id,eEvent.isSet()))</span><br><span class="line">    eEvent.wait()</span><br><span class="line">    print(<span class="string">"单身狗&#123;&#125;告别单身\n"</span>.format(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    thread_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> id <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        t = threading.Thread(target=get_girl_friend,args=(id,))</span><br><span class="line">        t.start()</span><br><span class="line">        thread_list.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 所有线程准备完毕，将event内置Flag设置为True,恢复正在阻塞的线程</span></span><br><span class="line">    eEvent.set()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历列表，阻塞主线程</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        <span class="comment"># 阻塞主线程，等待所有子线程结束</span></span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">单身狗<span class="number">1</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">2</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">3</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">4</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">5</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">6</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">7</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">8</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">9</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">10</span>都准备完毕，Flag状态：<span class="literal">False</span></span><br><span class="line">单身狗<span class="number">1</span>告别单身</span><br><span class="line">单身狗<span class="number">2</span>告别单身</span><br><span class="line">单身狗<span class="number">3</span>告别单身</span><br><span class="line">单身狗<span class="number">4</span>告别单身</span><br><span class="line">单身狗<span class="number">6</span>告别单身</span><br><span class="line">单身狗<span class="number">7</span>告别单身</span><br><span class="line">单身狗<span class="number">5</span>告别单身</span><br><span class="line">单身狗<span class="number">8</span>告别单身</span><br><span class="line">单身狗<span class="number">9</span>告别单身</span><br><span class="line">单身狗<span class="number">10</span>告别单身</span><br></pre></td></tr></table></figure>
<p>注意互斥锁Lock与事件Event区别，需求不同，使用方式也不同：</p>
<ol>
<li><p>互斥锁Lock主要针对多个线程同时操作同一个数据，使用互斥锁可以保证数据正常修改或者访问；</p>
</li>
<li><p>事件Event主要用于唤醒正在阻塞等待状态的线程;</p>
</li>
</ol>
<h5 id="线程优先级队列（Queue）"><a href="#线程优先级队列（Queue）" class="headerlink" title="线程优先级队列（Queue）"></a>线程优先级队列（Queue）</h5><p>Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。</p>
<p>这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p>
<p>Queue 模块中的常用方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Queue.qsize() 返回队列的大小</span><br><span class="line">Queue.empty() 如果队列为空，返回<span class="literal">True</span>,反之<span class="literal">False</span></span><br><span class="line">Queue.full() 如果队列满了，返回<span class="literal">True</span>,反之<span class="literal">False</span></span><br><span class="line">Queue.full 与 maxsize 大小对应</span><br><span class="line">Queue.get([block[, timeout]])获取队列，timeout等待时间</span><br><span class="line">Queue.get_nowait() 相当Queue.get(<span class="literal">False</span>)</span><br><span class="line">Queue.put(item) 写入队列，timeout等待时间</span><br><span class="line">Queue.put_nowait(item) 相当Queue.put(item, <span class="literal">False</span>)</span><br><span class="line">Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</span><br><span class="line">Queue.join() 实际上意味着等到队列为空，再执行别的操作</span><br></pre></td></tr></table></figure>
<h5 id="GIL（Global-Interpreter-Lock）全局解释器锁"><a href="#GIL（Global-Interpreter-Lock）全局解释器锁" class="headerlink" title="GIL（Global Interpreter Lock）全局解释器锁"></a>GIL（Global Interpreter Lock）全局解释器锁</h5><p>在非python环境中，单核CPU同时只能有一个任务执行。多核CPU支持多个线程同时执行。但在python中,无论CPU有多少核,同时只能执行一个线程。这是GIL导致的。</p>
<p>GIL：Global Interpreter Lock(全局解释器锁)，是python设计之初为了数据安全所做的决定。某个线程想要执行前，必须先拿到GIL(“通行证”)。在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许执行。GIL只在cpython中才有，因为cpython调用c语言的原生线程，所以它不直接操作cpu，只能利用GIL保证同一时间只有一个线程拿到数据。而在pypy和jpython中是没有GIL的。</p>
<p>Python多线程的工作过程：</p>
<p>python在使用多线程的时候，调用的是c语言的原生线程。</p>
<ol>
<li>拿到公共数据</li>
<li>申请GIL</li>
<li>python解释器调用os原生线程</li>
<li>os操作cpu执行运算</li>
<li>当该线程执行时间到后，无论运算是否执行完，GIL都被释放</li>
<li>其他线程重复上面的过程</li>
<li>等其他线程执行完后，又会切换到之前的线程（从他记录的上下文继续执行），整个过程是每个线程执行自己的运算，当执行时间到就进行切换。</li>
</ol>
<p>python针对不同类型的代码执行效率也是不同的：</p>
<ol>
<li>CPU密集型代码(各种循环处理、计算等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。</li>
<li>IO密集型代码(文件处理、网络爬虫等涉及文件读写的操作)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。</li>
</ol>
<p>使用建议:</p>
<p>python下想要充分利用多核CPU，就用多进程。因为每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。</p>
<p>GIL在python中的版本差异：</p>
<ol>
<li>在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100时进行释放。（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过sys.setcheckinterval 来调整）。而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。</li>
<li>在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程基础</title>
    <url>/2020/03/23/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h5 id="多线程理解"><a href="#多线程理解" class="headerlink" title="多线程理解"></a>多线程理解</h5><p><strong>多线程是多个任务同时运行的一种方式</strong>。比如一个循环中，每个循环看做一个任务，我们希望第一次循环运行还没结束时，就能开始第二次循环，以此节省时间。</p>
<p>Python中这种同时运行的使用多线程目的是最大化利用CPU的计算能力，将很多等待时间利用起来。如果程序耗时不是因为等待时间，而是任务非常多。计算时间较长，则多线程无法改善运行时间。</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><p>先看下面这个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<p>如果我们要运行10次myfun，运行时间主要取决于每次sleep的1s，a的计算耗时可以忽略不计。这种情况可以用多线程提高效率。</p>
<p>不使用多线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    myfun()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5.000431537628174</span></span><br></pre></td></tr></table></figure>
<p>使用多线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br></pre></td></tr></table></figure>
<p>运行后会发现大概1秒后5个2同时出来，说明5次循环几乎同时运行，5次1秒的等待时间同时进行，最后只等待了1秒。</p>
<p>这里多线程只包括了两步：</p>
<ol>
<li>用Thread增加一个线程，这里将每一次循环作为一次新线程，一个线程执行一次myfun函数。</li>
<li>用start()开始运行线程，每个线程都需要这样显式开启才会运行。一个线程开启后，无需等待它运行完成，就能继续向下运行，即下一次循环（然后又新建了第二个线程，运行未结束即开启第三个……）</li>
</ol>
<h5 id="join的使用"><a href="#join的使用" class="headerlink" title="join的使用"></a>join的使用</h5><p>线程的join()方法表示等这个线程运行完毕，程序再往下运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">    th.join()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5.0054051876068115</span></span><br></pre></td></tr></table></figure>
<p>start()之后马上join()，表示每一个线程都要运行结束才能进行下一次循环。这样就和没使用多线程一样了。</p>
<p>下面是未使用join()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.0019860267639160156</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">22</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>程序几乎马上输出了结果，而且5个2是在打印秒数之后才打印的。这是因为print(time.time() - t)是区别于那5次循环线程之外的第6个线程，它不会等待5个线程运行结束就会开始运行。所以这样是无法获得上面5个线程的运行时间的，我们需要用join()等待5个线程都运行结束。</p>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line">ths = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">    ths.append(th)</span><br><span class="line"><span class="keyword">for</span> th <span class="keyword">in</span> ths:</span><br><span class="line">    th.join()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为 1.0038363933563232</span></span><br></pre></td></tr></table></figure>
<p>上面定义ths列表存储这些线程，最后用循环确保每一个线程都已经运行完成再计算时间差。</p>
<p>join()不只适用于这种情形。当当前代码运行依赖之前代码运行完成时，就要加入join()命令。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程</title>
    <url>/2020/03/23/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>整理并加上了自己的理解，来源自<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376" target="_blank" rel="noopener">廖雪峰的官方网站——Python进程和线程</a>  </p>
<p>现代操作系统都是支持“多任务”的操作系统。</p>
<p>“多任务”就是操作系统可以能同时运行多个任务。比如我们一边用浏览器上网，一边听MP3，一边用Word赶作业。这就是多任务，至少同时有3个任务在运行。还有很多任务悄悄地在后台同时运行，只是桌面上没有显示而已。</p>
<p>多核CPU已经非常普及了，但单核CPU也可以执行多任务。由于CPU执行代码都是顺序执行的，那么单核CPU是怎么执行多任务的呢？</p>
<p>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2。任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上每个任务都是交替执行，但CPU的执行速度太快了，我们感觉就像所有任务都在同时执行。</p>
<p>真正的并行执行多任务只能在多核CPU上实现，但由于任务数量远远多于CPU的核心数量，所以操作系统会自动把很多任务轮流调度到每个核心上执行。</p>
<p>对于操作系统来说，<strong>一个任务就是一个进程（Process）</strong>。打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还同时干很多事，比如Word，它可以同时进行打字、拼写检查、打印等事情。<strong>在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</strong></p>
<p><strong>由于每个进程至少要干一件事，所以一个进程至少有一个线程。</strong> 像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。真正地同时执行多线程需要多核CPU才可能实现。</p>
<p>平时编写的Python程序都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p>
<p>有两种解决方案：</p>
<ol>
<li><p>启动多个进程，每个进程只有一个线程，但多个进程一块执行多个任务。</p>
</li>
<li><p>启动一个进程，在一个进程内启动多个线程，多个线程一块执行多个任务。</p>
</li>
</ol>
<p>还有第三种方法：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了。这种模型更复杂，实际很少采用。</p>
<p>总结一下就是，多任务的实现有3种方式：</p>
<ol>
<li><p>多进程模式；</p>
</li>
<li><p>多线程模式；</p>
</li>
<li><p>多进程+多线程模式。</p>
</li>
</ol>
<p>同时执行多个任务通常各个任务之间是有关联的，需要相互通信和协调。有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于单进程单线程的程序。</p>
<p>多任务是必须的。例如在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频。否则单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频。</p>
<p>小结：</p>
<ol>
<li><p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
</li>
<li><p>多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>对可迭代对象、迭代器和生成器的理解</title>
    <url>/2020/03/23/%E5%AF%B9%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h5 id="可迭代对象和迭代器"><a href="#可迭代对象和迭代器" class="headerlink" title="可迭代对象和迭代器"></a>可迭代对象和迭代器</h5><p>序列可以迭代的原因：<strong>iter</strong> 函数。Python解释器需要迭代对象 x 时，会自动调用 iter(x)。内置的 iter 函数作用如下：</p>
<ol>
<li><p>检查对象是否实现了 __ <strong>iter__</strong> 方法，实现了就调用它，获取一个迭代器。</p>
</li>
<li><p>没有实现 __ <strong>iter__</strong> 方法，但实现了 __ <strong>getitem__</strong> 方法，而且参数是从零开始的索引，Python会创建一个迭代器，尝试按顺序（从索引 0 开始）获取元素。</p>
</li>
<li><p>如果前两步都失败，Python抛出 TypeError 异常，通常会提示“C object is not iterable”，其中 C 是目标对象所属的类。</p>
</li>
</ol>
<p>由此可以明确可迭代对象（Iterable）： 使用 iter 内置函数可以获取迭代器（Iterator）的对象。即对象实现了能返回迭代器的 __ <strong>iter__</strong> 方法或实现了 __ <strong>getitem__</strong> 方法，而且其参数是从零开始的索引。</p>
<p>一个实现 __ <strong>getitem__</strong> 的demo：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.text[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o1 = Test(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o1:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>下面来看一个实现 __ <strong>iter__</strong> 的例子。因为用到了迭代器，所以先明确一下迭代器的用法。 标准的迭代器接口有两个方法：  </p>
<ol>
<li><p>__ <strong>next__</strong> ：返回下一个可用的元素，如果没有元素了就抛出 <strong>StopIteration</strong> 异常。</p>
</li>
<li><p>__ <strong>iter__</strong> ：返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如 for 循环。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Eg2Iterator(self.text) <span class="comment"># 获取一个迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg2Iterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            subtext = self.text[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> subtext</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o2 = Eg2(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o2:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>我们明确可迭代的对象和迭代器之间的关系：</p>
<ol>
<li><p>Python 从可迭代对象中获取迭代器。</p>
</li>
<li><p>__ <strong>iter__</strong> 方法从我们自己创建的迭代器类中获取迭代器，而__ <strong>getitem__</strong> 方法是python内部自动创建迭代器。</p>
</li>
</ol>
<p>我们来了解一下使用更符合 Python 的方式实现 Eg2类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg3</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.text:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o3 = Eg3(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o3:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>
<p>这里使用了 <strong>yield</strong> 关键字， 只要 Python 函数体中有 yield 关键字，该函数就是生成器函数。调用生成器函数时会返回一个生成器对象。也就是说生成器函数是生成器工厂。 上述代码还可以使用yield from进一步简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg3</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o3 = Eg3(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o3:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>还可以使用生成器表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg5</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (item <span class="keyword">for</span> item <span class="keyword">in</span> self.text) <span class="comment"># 生成器表达式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o5 = Eg5(<span class="string">'Hello, the wonderful new world!'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o5:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果:  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>the</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wonderful</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>world!</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><p>可迭代对象（Iterable）要么实现了能返回迭代器的 __ <strong>iter__</strong> 方法，要么实现了 __ <strong>getitem__</strong> 方法而且其参数是从零开始的索引。</p>
</li>
<li><p>迭代器（Iterator）是这样的对象：实现了无参数的 __ <strong>next__</strong> 方法，返回下一个元素，如果没有元素就抛出 StopIteration 异常；并且实现 __ <strong>iter__</strong> 方法，返回迭代器本身。</p>
</li>
<li><p>生成器是带有 yield 关键字的函数。调用生成器函数时，会返回一个生成器对象。</p>
</li>
<li><p>生成器表达式是创建生成器的简洁句法，这样无需先定义函数再调用。</p>
</li>
<li><p>什么是迭代器模式？按需一次获取一个数据项。</p>
</li>
<li><p>生成器和迭代器有什么不同？</p>
<p>相同点：所有生成器都是迭代器，因为生成器完全实现了迭代器接口。</p>
<p>不同点：迭代器用于从集合中取出元素；生成器用于凭空生成元素。</p>
</li>
</ol>
<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>迭代是处理大量数据的好方法。以列表为例，迭代存在两个问题。第一，列表中的元素太多将大量占用内存。第二，我们有时候只需要使用一次数据，如果用列表把数据全部保存起来，将会造成内存浪费。</p>
<p>生成器是创建迭代器的工具。它们像常规函数一样撰写，但是在需要返回数据时使用yield语句。每当对它调用next()函数，生成器从它上次停止的地方重新开始（它会记住所有的数据值和上次执行的语句）。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的property动态属性</title>
    <url>/2020/03/21/Python%E7%9A%84property%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>我们首先定义一个User类，包含两个属性 name 和 birthday</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br></pre></td></tr></table></figure>
<p>如果想获得User实例的年龄，我们可以定义一个方法，然后使用函数调用的方式获得年龄。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br></pre></td></tr></table></figure>
<p>举例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User(<span class="string">"zqy"</span>, date(year=<span class="number">1997</span>, month=<span class="number">6</span>, day=<span class="number">15</span>))</span><br><span class="line">    print(user.get_age()) <span class="comment"># 返回23</span></span><br></pre></td></tr></table></figure>
<p>如果我们想使用调用属性的方式获得年龄（user.age），那么就可以使用property装饰器。<br>为了区别上面的代码，以下是完整的使用property装饰器的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" 将函数调用装饰成属性调用 """</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(<span class="string">"zqy"</span>, date(year=<span class="number">1997</span>, month=<span class="number">6</span>, day=<span class="number">15</span>))</span><br><span class="line">    print(user.age)</span><br></pre></td></tr></table></figure>
<p>我们并没有定义age属性，但是通过property装饰器装饰的age函数，可以直接通过实例调用函数名的方式，作为一个属性返回。<br>那么setter装饰器又是什么呢？  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br><span class="line">        self._age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" 取函数调用的模式编程取属性调用 """</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._age = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(<span class="string">"zqy"</span>, date(year=<span class="number">1997</span>, month=<span class="number">6</span>, day=<span class="number">15</span>))</span><br><span class="line">    user.age = <span class="number">30</span></span><br><span class="line">    print(user._age) <span class="comment"># 30</span></span><br><span class="line">    print(user.age) <span class="comment"># 23</span></span><br></pre></td></tr></table></figure>
<p>1、只有 @property 表示只读。<br>2、同时有 @property 和 @*.setter 表示可读可写。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB的简单介绍</title>
    <url>/2020/03/14/MongoDB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>首先将下载好的文件夹的bin目录添加到系统环境变量中</p>
<p><img src="https://s1.ax1x.com/2020/03/14/81S88f.png" alt="81S88f.png"></p>
<p>在cmd命令行里输入 <strong>mongo</strong> 测试连接</p>
<p><img src="https://s1.ax1x.com/2020/03/14/81Sgr4.png" alt="81Sgr4.png"><br><strong>mongo</strong> 适用于本地连接MongoDB， MongoDB的<strong>默认端口号是27017</strong>。</p>
<h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db</span><br><span class="line">test</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>此命令返回的是MongoDB默认的数据库<strong>test</strong>，下面是返回全部数据库的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show databases;</span><br><span class="line">Qianyi_Zhang_lab6  0.000GB</span><br><span class="line">admin              0.000GB</span><br><span class="line">config             0.000GB</span><br><span class="line">local              0.000GB</span><br><span class="line">students           0.000GB</span><br><span class="line">test               0.000GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h5 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use test</span><br><span class="line">switched to db test</span><br><span class="line">&gt; use students</span><br><span class="line">switched to db students</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h5 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h5><p>官方文档：<a href="https://docs.mongodb.com/manual/reference/insert-methods/" target="_blank" rel="noopener">Insert Methods</a><br>The <strong>db.myCollection.insertOne()</strong> 是 mongo shell 中的一种方法。  </p>
<ul>
<li>db：是当前的数据库</li>
<li>myCollection：当前的collection名字                      </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use myNewDatabase</span><br><span class="line">switched to db myNewDatabase</span><br><span class="line">&gt; db.myCollection.insertOne(&#123;x:1&#125;);</span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedId&quot; : ObjectId(&quot;5e6d1ff57ea55eb9ea1ab738&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.myCollection.insertOne(&#123;x:2, y:3&#125;);</span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedId&quot; : ObjectId(&quot;5e6d203d7ea55eb9ea1ab739&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>MongoDB Compass展示数据库：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/81KET0.png" alt="81KET0.png"></p>
<h5 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h5><p>使用 <strong>db.collection.insertMany()</strong> 方法向inventory collection插入多个新文档（documents）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.inventory.insertMany([</span><br><span class="line">...    &#123; item: &quot;journal&quot;, qty: 25, status: &quot;A&quot;, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, tags: [ &quot;blank&quot;, &quot;red&quot; ] &#125;,</span><br><span class="line">...    &#123; item: &quot;notebook&quot;, qty: 50, status: &quot;A&quot;, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, tags: [ &quot;red&quot;, &quot;blank&quot; ] &#125;,</span><br><span class="line">...    &#123; item: &quot;paper&quot;, qty: 10, status: &quot;D&quot;, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, tags: [ &quot;red&quot;, &quot;blank&quot;, &quot;plain&quot; ] &#125;,</span><br><span class="line">...    &#123; item: &quot;planner&quot;, qty: 0, status: &quot;D&quot;, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, tags: [ &quot;blank&quot;, &quot;red&quot; ] &#125;,</span><br><span class="line">...    &#123; item: &quot;postcard&quot;, qty: 45, status: &quot;A&quot;, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, tags: [ &quot;blue&quot; ] &#125;</span><br><span class="line">... ]);</span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedIds&quot; : [</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace112fe&quot;),</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace112ff&quot;),</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace11300&quot;),</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace11301&quot;),</span><br><span class="line">                ObjectId(&quot;5e6d2361c5e27d91ace11302&quot;)</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>MongoDB Compass展示数据库：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/81M9N6.png" alt="81M9N6.png">   </p>
<p>其中一个对象的完整内容：  </p>
<p><img src="https://s1.ax1x.com/2020/03/15/81MC4K.png" alt="81MC4K.png"></p>
<h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>数据库内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.insertMany([</span><br><span class="line">   &#123; item: &quot;journal&quot;, qty: 25, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;notebook&quot;, qty: 50, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;A&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;paper&quot;, qty: 100, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;D&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;planner&quot;, qty: 75, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, status: &quot;D&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;postcard&quot;, qty: 45, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/15/81MQC8.png" alt="81MQC8.png"></p>
<p>查询所有数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.inventory.find(&#123;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11304&quot;), &quot;item&quot; : &quot;notebook&quot;, &quot;qty&quot; : 50, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11305&quot;), &quot;item&quot; : &quot;paper&quot;, &quot;qty&quot; : 100, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11306&quot;), &quot;item&quot; : &quot;planner&quot;, &quot;qty&quot; : 75, &quot;size&quot; : &#123; &quot;h&quot; : 22.85, &quot;w&quot; : 30, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11307&quot;), &quot;item&quot; : &quot;postcard&quot;, &quot;qty&quot; : 45, &quot;size&quot; : &#123; &quot;h&quot; : 10, &quot;w&quot; : 15.25, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>按条件查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用这种格式：&#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;</span><br><span class="line"></span><br><span class="line">查询 status&#x3D;D 的数据</span><br><span class="line">&gt; db.inventory.find( &#123; status: &quot;D&quot; &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11305&quot;), &quot;item&quot; : &quot;paper&quot;, &quot;qty&quot; : 100, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11306&quot;), &quot;item&quot; : &quot;planner&quot;, &quot;qty&quot; : 75, &quot;size&quot; : &#123; &quot;h&quot; : 22.85, &quot;w&quot; : 30, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&gt;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询 status&#x3D;A or D 的数据</span><br><span class="line">&gt; db.inventory.find( &#123; status: &#123; $in: [ &quot;A&quot;, &quot;D&quot; ] &#125; &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11304&quot;), &quot;item&quot; : &quot;notebook&quot;, &quot;qty&quot; : 50, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11305&quot;), &quot;item&quot; : &quot;paper&quot;, &quot;qty&quot; : 100, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11306&quot;), &quot;item&quot; : &quot;planner&quot;, &quot;qty&quot; : 75, &quot;size&quot; : &#123; &quot;h&quot; : 22.85, &quot;w&quot; : 30, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;D&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11307&quot;), &quot;item&quot; : &quot;postcard&quot;, &quot;qty&quot; : 45, &quot;size&quot; : &#123; &quot;h&quot; : 10, &quot;w&quot; : 15.25, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;   </span><br><span class="line">等价于：SELECT * FROM inventory WHERE status in (&quot;A&quot;, &quot;D&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询 status&#x3D;A and qty&lt;30 的数据</span><br><span class="line">&gt; db.inventory.find( &#123; status: &quot;A&quot;, qty: &#123; $lt: 30 &#125; &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">等价于：SELECT * FROM inventory WHERE status &#x3D; &quot;A&quot; AND qty &lt; 30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询 status&#x3D;A or qty&lt;30 的数据</span><br><span class="line">&gt; db.inventory.find( &#123; $or: [ &#123; status: &quot;A&quot; &#125;, &#123; qty: &#123; $lt: 30 &#125; &#125; ] &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11304&quot;), &quot;item&quot; : &quot;notebook&quot;, &quot;qty&quot; : 50, &quot;size&quot; : &#123; &quot;h&quot; : 8.5, &quot;w&quot; : 11, &quot;uom&quot; : &quot;in&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11307&quot;), &quot;item&quot; : &quot;postcard&quot;, &quot;qty&quot; : 45, &quot;size&quot; : &#123; &quot;h&quot; : 10, &quot;w&quot; : 15.25, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;   </span><br><span class="line">等价于：SELECT * FROM inventory WHERE status &#x3D; &quot;A&quot; OR qty &lt; 30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询 status&#x3D;A and (qty&lt;30 or item以p开头) 的数据</span><br><span class="line">&gt; db.inventory.find( &#123;</span><br><span class="line">...      status: &quot;A&quot;,</span><br><span class="line">...      $or: [ &#123; qty: &#123; $lt: 30 &#125; &#125;, &#123; item: &#x2F;^p&#x2F; &#125; ]</span><br><span class="line">... &#125; )</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11303&quot;), &quot;item&quot; : &quot;journal&quot;, &quot;qty&quot; : 25, &quot;size&quot; : &#123; &quot;h&quot; : 14, &quot;w&quot; : 21, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5e6d2551c5e27d91ace11307&quot;), &quot;item&quot; : &quot;postcard&quot;, &quot;qty&quot; : 45, &quot;size&quot; : &#123; &quot;h&quot; : 10, &quot;w&quot; : 15.25, &quot;uom&quot; : &quot;cm&quot; &#125;, &quot;status&quot; : &quot;A&quot; &#125;</span><br><span class="line">&gt;   </span><br><span class="line">等价于：SELECT * FROM inventory WHERE status &#x3D; &quot;A&quot; AND ( qty &lt; 30 OR item LIKE &quot;p%&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="更新一条数据"><a href="#更新一条数据" class="headerlink" title="更新一条数据"></a>更新一条数据</h5><p>官方文档：<a href="https://docs.mongodb.com/manual/reference/update-methods/" target="_blank" rel="noopener">Update Methods</a>  </p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask入门</title>
    <url>/2020/03/12/Flask%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h5 id="一个最小的应用"><a href="#一个最小的应用" class="headerlink" title="一个最小的应用"></a>一个最小的应用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 Flask 类，该类的实例成为我们的 WSGI 应用</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Flask 类的实例。第一个参数是应用模块或者包的名称</span></span><br><span class="line"><span class="comment"># 若使用一个单一模块（就像本例），则使用 __name__</span></span><br><span class="line"><span class="comment"># 名称根据模块是按应用方式使用或作为模块导入而变化</span></span><br><span class="line"><span class="comment"># （可能是 '__main__' 或实际导入的名称）</span></span><br><span class="line"><span class="comment"># 此参数是必需的，这样 Flask 才知道在哪里能找到模板和静态文件等东西</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 route() 装饰器把函数绑定到 URL:</span></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, World'</span></span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/8myzWR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8myzWR.png" alt="8myzWR.png"></a></p>
<h5 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h5><p>通过把 URL 的一部分标记为 &#60;variable_name&#62; 就可以在 URL 中添加变量。标记的部分会作为关键字参数传递给函数。通过使用 &#60;converter:variable_name&#62; ，可以选择性的加上一个转换器，为变量指定规则。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/user/&lt;username&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_user_profile</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="comment"># show the user profile for that user</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'User &#123;&#125;'</span>.format(username)</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/8m6POK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8m6POK.png" alt="8m6POK.png"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/post/&lt;int:post_id&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_post</span><span class="params">(post_id)</span>:</span></span><br><span class="line">    <span class="comment"># show the post with the given id, the id is an integer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Post &#123;&#125;'</span>.format(post_id)</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/8m6Cy6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8m6Cy6.png" alt="8m6Cy6.png"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/path/&lt;path:subpath&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_subpath</span><span class="params">(subpath)</span>:</span></span><br><span class="line">    <span class="comment"># show the subpath after /path/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Subpath &#123;&#125;'</span>.format(subpath)</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/8myvFJ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8myvFJ.png" alt="8myvFJ.png"></a></p>
<h5 id="唯一的-URL-重定向行为"><a href="#唯一的-URL-重定向行为" class="headerlink" title="唯一的 URL / 重定向行为"></a>唯一的 URL / 重定向行为</h5><p>以下两条规则的不同之处在于是否使用尾部的斜杠。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/projects/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">projects</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'The project page'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/about')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">about</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'The about page'</span></span><br></pre></td></tr></table></figure>
<p>projects 的 URL 是中规中矩的，尾部有一个斜杠，如同文件夹。 访问一个没有斜杠结尾的 URL 时 Flask 会自动进行重定并尾部加上一个斜杠。</p>
<p>about 的 URL 没有尾部斜杠，与文件类似。如果访问这个 URL 时添加了尾部斜杠就会得到一个 404 错误。这样可以保持 URL 唯一，并帮助搜索引擎避免重复索引同一页面。<br><a href="https://imgchr.com/i/8m6R6x" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/12/8m6R6x.png" alt="8m6R6x.png"></a></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">sting</td>
<td align="center">（缺省值） 接受任何不包含斜杠的文本</td>
</tr>
<tr>
<td align="left">int</td>
<td align="center">接受正整数</td>
</tr>
<tr>
<td align="left">float</td>
<td align="center">接受正浮点数</td>
</tr>
<tr>
<td align="left">path</td>
<td align="center">类似 string ，但可以包含斜杠</td>
</tr>
<tr>
<td align="left">uuid</td>
<td align="center">接受 UUID 字符串</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Python __name__</title>
    <url>/2020/03/12/%E5%85%B3%E4%BA%8EPython-name/</url>
    <content><![CDATA[<h5 id="关于-name"><a href="#关于-name" class="headerlink" title="关于 __ name__"></a>关于 __ <strong>name__</strong></h5><p>__ <strong>name__</strong> 属于 python 的内置类属性，它天生存在于一个 python 程序中，代表对应程序名称。  </p>
<p>比如下面的代码里面（app.py），当运行此代码时，这个代码的 <strong>name</strong> 的值为 <strong>main</strong> （一段程序作为主线运行程序时其内置名称就是 <strong>main</strong>）。  </p>
<p>文件夹目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">folder</span><br><span class="line">│</span><br><span class="line">└─── __init__.py</span><br><span class="line">│</span><br><span class="line">└─── app.py</span><br><span class="line">│</span><br><span class="line">└─── task_name.py</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(__name__)</span><br><span class="line">&gt;&gt;&gt;__main__</span><br></pre></td></tr></table></figure>
<p>当 app.py 作为模块被 (task_name.py) 调用时，则它的 <strong>name</strong> 就是它自己的名字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># task_name.py</span></span><br><span class="line"><span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line">print(app.__name__)</span><br><span class="line">&gt;&gt;&gt;app</span><br></pre></td></tr></table></figure>
<p>自己的 __ <strong>name__</strong> 在自己用时就是 main，当自己作为模块被调用时就是自己的名字。  </p>
<h5 id="实际项目的应用"><a href="#实际项目的应用" class="headerlink" title="实际项目的应用"></a>实际项目的应用</h5><p>如果在a.py里写了一个函数并且写了测试用例a_test， 运行a.py会显示测试用例a_test的结果。在b.py导入a并在b.py写了测试用例b_test，如果直接运行b.py会返回a_test和b_test的结果。显然a_test的结果不是我们想要的，我们只需要在b.py的b_test之前加上“if __ <strong>name__</strong> == __ <strong>name__</strong>:”，这样就不会返回a_test的结果了。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAlchemy的基本使用</title>
    <url>/2020/03/11/SQLAlchemy%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>数据库表是一个二维表，包含多行多列。用Python的数据结构表示表的数据，可以用一个list表示多行，list的每一个元素是tuple，表示一行记录，比如，包含id和name的user表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   (<span class="string">'1'</span>, <span class="string">'Michael'</span>),</span><br><span class="line">   (<span class="string">'2'</span>, <span class="string">'Bob'</span>),</span><br><span class="line">   (<span class="string">'3'</span>, <span class="string">'Adam'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Python的DB-API返回的数据结构如上所示。<br>但用tuple表示一行很难看出表的结构。如果把一个tuple用class实例来表示，就可以更容易地看出表的结构来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name)</span>:</span></span><br><span class="line">        self.id = id</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    User(<span class="string">'1'</span>, <span class="string">'Michael'</span>),</span><br><span class="line">    User(<span class="string">'2'</span>, <span class="string">'Bob'</span>),</span><br><span class="line">    User(<span class="string">'3'</span>, <span class="string">'Adam'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这就是ORM技术(Object-Relational Mapping)，把关系数据库的表结构映射到对象上。由ORM框架来做转换。<br>Python中最有名的ORM框架是SQLAlchemy。以下是SQLAlchemy的常用用法。   </p>
<h6 id="Install-SQLAlchemy-via-pip"><a href="#Install-SQLAlchemy-via-pip" class="headerlink" title="Install SQLAlchemy via pip:"></a>Install SQLAlchemy via pip:</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ pip install sqlalchemy</span><br></pre></td></tr></table></figure>
<h6 id="Version-Check"><a href="#Version-Check" class="headerlink" title="Version Check:"></a>Version Check:</h6><p>A quick check to verify that we are on at least version 1.3 of SQLAlchemy:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sqlalchemy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqlalchemy.__version__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.3</span><span class="number">.14</span></span><br></pre></td></tr></table></figure>
<h6 id="Connecting"><a href="#Connecting" class="headerlink" title="Connecting:"></a>Connecting:</h6><p>To connect we use create_engine():</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root : MySQL username</span></span><br><span class="line"><span class="comment"># mysql://root:(MySQL password, if the password is '', add nothing)</span></span><br><span class="line"><span class="comment"># news_test: the new defined database name</span></span><br><span class="line">engine = create_engine(<span class="string">'mysql://root:@localhost:3306/news_test?charset=utf8'</span>)</span><br></pre></td></tr></table></figure>
<p>The return value of create_engine() is an instance of Engine, and it represents the core interface to the database, adapted through a dialect that handles the details of the database and DBAPI in use. In this case the MySQL dialect will interpret instructions to the Python built-in MySQL module.</p>
<h6 id="Declare-a-Mapping"><a href="#Declare-a-Mapping" class="headerlink" title="Declare a Mapping:"></a>Declare a Mapping:</h6><p>When using the ORM, the configurational process starts by describing the database tables we’ll be dealing with, and then by defining our own classes which will be mapped to those tables. In modern SQLAlchemy, these two tasks are usually performed together, using a system known as Declarative, which allows us to create classes that include directives to describe the actual database table they will be mapped to.</p>
<p>Classes mapped using the Declarative system are defined in terms of a base class which maintains a catalog of classes and tables relative to that base - this is known as the declarative base class. Our application will usually have just one instance of this base in a commonly imported module. We create the base class using the declarative_base() function, as follows:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Base = declarative_base()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String, DateTime, Boolean</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">'mysql://root:@localhost:3306/news_test?charset=utf8'</span>)</span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">News</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"news"</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = Column(String(<span class="number">200</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    content = Column(String(<span class="number">2000</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    types = Column(String(<span class="number">10</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    image = Column(String(<span class="number">300</span>), )</span><br><span class="line">    author = Column(String(<span class="number">20</span>), )</span><br><span class="line">    view_count = Column(Integer)</span><br><span class="line">    created_at = Column(DateTime)</span><br><span class="line">    is_valid = Column(Boolean)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrmTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.session = Session()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        new_obj = News(</span><br><span class="line">            title=<span class="string">'标题'</span>,</span><br><span class="line">            content=<span class="string">'内容'</span>,</span><br><span class="line">            types=<span class="string">'百家'</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.session.add(new_obj)</span><br><span class="line">        self.session.commit()</span><br><span class="line">        <span class="keyword">return</span> new_obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""查询一条数据"""</span></span><br><span class="line">        <span class="keyword">return</span> self.session.query(News).get(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_more</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""查询多条数据"""</span></span><br><span class="line">        <span class="keyword">return</span> self.session.query(News).filter_by(is_valid=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_data</span><span class="params">(self, pk)</span>:</span></span><br><span class="line">        <span class="string">"""修改数据"""</span></span><br><span class="line">        new_obj = self.session.query(News).get(pk)</span><br><span class="line">        <span class="keyword">if</span> new_obj:</span><br><span class="line">            new_obj.is_valid = <span class="number">0</span></span><br><span class="line">            self.session.add(new_obj)</span><br><span class="line">            self.session.commit()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = OrmTest()</span><br><span class="line">    <span class="comment"># res = obj.add_one()</span></span><br><span class="line">    print(obj.update_data(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
</search>
